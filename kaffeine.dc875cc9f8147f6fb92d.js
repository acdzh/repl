(()=>{"use strict";function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var e=function(){function e(n,t,r,a,i,s){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.result=r,this.error=a,this.sandbox=i,this.inspect=this.sandbox.console.inspect,this.Function=this.sandbox.Function,this.sandbox.__eval=this.sandbox.eval,this.tokenizer=this.sandbox.require("kaffeine/token");var o=this.sandbox.require("kaffeine");this.kaffeine=new o,s()}var t,r;return t=e,(r=[{key:"Compile",value:function(n){var e=this.kaffeine.compile(n);try{new this.Function(e)}catch(n){e="(".concat(e,")")}return e}},{key:"Eval",value:function(n){var e;try{e=this.Compile(n)}catch(n){return n.message="Compiling: ".concat(n.message),void this.error(n)}try{var t=this.sandbox.__eval(e);this.result(void 0===t?"":this.inspect(t))}catch(n){this.error(n)}}},{key:"EvalSync",value:function(n){return this.sandbox.__eval(this.Compile(n))}},{key:"GetNextLineIndent",value:function(n){try{for(var e=this.tokenizer.ize(n);null!=e;){if(e.bang)return 0;e=e.next}}catch(n){return 1}try{var t=this.kaffeine.compile(n);try{new this.Function(t)}catch(n){t="(".concat(t,")"),new this.Function(t)}var r=n.split("\n").slice(-1)[0];return!!/^\s+/.test(r)&&0}catch(e){return/^\s*(for|while|if|else)\b|[[{(]$/.test(n)?1:0}}}])&&n(t.prototype,r),e}(),t="undefined"!=typeof window&&null!==window?window:self;t.eval.call(t,"// Brequire - CommonJS support for the browser\nfunction require(p) {\n  var path = require.resolve(p);\n\n  var module = require.modules[path];\n  if (!module) throw \"couldn't find module for: \".concat(p);\n\n  if (!module.exports) {\n    module.exports = {};\n    module.call(module.exports, module, module.exports, require.bind(path));\n  }\n\n  return module.exports;\n}\n\nrequire.modules = {};\n\nrequire.resolve = function (path) {\n  if (require.modules[path]) return path;\n\n  if (!path.match(/\\.js$/)) {\n    if (require.modules[\"\".concat(path, \".js\")]) return \"\".concat(path, \".js\");\n    if (require.modules[\"\".concat(path, \"/index.js\")]) return \"\".concat(path, \"/index.js\");\n    if (require.modules[\"\".concat(path, \"/index\")]) return \"\".concat(path, \"/index\");\n  }\n};\n\nrequire.bind = function (path) {\n  return function (p) {\n    if (!p.match(/^\\./)) return require(p);\n    var fullPath = path.split('/');\n    fullPath.pop();\n    var parts = p.split('/');\n\n    for (var i = 0; i < parts.length; i++) {\n      var part = parts[i];\n      if (part == '..') fullPath.pop();else if (part != '.') fullPath.push(part);\n    }\n\n    return require(fullPath.join('/'));\n  };\n};\n\nrequire.register = function (path, fn) {\n  require.modules[path] = fn;\n};\n\nrequire.register('kaffeine/browser.js', function (module, exports, require) {\n  // start module: kaffeine/browser.js\n  (function () {\n    var kaffeine = require(\"./kaffeine\");\n\n    function load(url, options, callback) {\n      var xhr = new (window.ActiveXObject || XMLHttpRequest)('Microsoft.XMLHTTP');\n      xhr.open('GET', url, true);\n\n      if ('overrideMimeType' in xhr) {\n        xhr.overrideMimeType('text/plain');\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          run(url, xhr.responseText, options);\n          if (callback) callback(true);\n          return;\n        }\n      };\n\n      try {\n        xhr.send(null);\n      } catch (e) {\n        console.log(\"failed loading: \" + url);\n      }\n    }\n\n    function run(src, text) {\n      var K = new kaffeine();\n      var js = K.compile(text, {\n        brequire_module: src.replace(/\\.k/, '')\n      });\n      eval(js); // (Function(js))()\n    }\n\n    if (typeof window === 'undefined' || window === null) {\n      return;\n    }\n\n    function loadExternal(callback) {\n      var scripts = document.getElementsByTagName('script');\n      var to_run = [];\n\n      for (var i = 0; i < scripts.length; i++) {\n        var s = scripts[i];\n\n        if (s.type.match(/kaffeine/) && s.src) {\n          to_run.push(s);\n        }\n\n        ;\n      }\n\n      for (var i = 0; i < to_run.length; i++) {\n        var attr = to_run[i].attributes;\n\n        for (var i = 0; i < attr.length; i++) {\n          if (attr[i].nodeName == 'src') {\n            var src = attr[i].value;\n          }\n\n          ;\n        }\n\n        load(src);\n      }\n    }\n\n    function runInternal() {\n      var scripts = document.getElementsByTagName('script');\n\n      for (var i = 0; i < scripts.length; i++) {\n        var s = scripts[i];\n\n        if (s.type.match(/kaffeine/) && !s.src) {\n          run(script.innerHTML);\n        }\n      }\n    }\n\n    if (typeof document !== 'document') loadExternal();\n\n    if (window.addEventListener) {\n      addEventListener('DOMContentLoaded', runInternal, false);\n    } else {\n      attachEvent('onload', runInternal);\n    }\n  }).call(this); // end module: kaffeine/browser.js\n});\n\nrequire.register('kaffeine/index.js', function (module, exports, require) {\n  // start module: kaffeine/index.js\n  var Token = require(\"./token\");\n\n  function Kaffeine(options) {\n    this.options = options;\n  }\n\n  Kaffeine.fn = Kaffeine.prototype;\n  Kaffeine.VERSION = '0.0.4';\n  Kaffeine.plugins = {}; // unless brackets_for_keywords reverse_blocks indented_blocks\n\n  var jsp = require(\"./uglify/parse-js\");\n\n  var pro = require(\"./uglify/process\");\n\n  var defaultDirective = 'multiline_strings string_interpolation hash at brackets_for_keywords operators prototype implicit_functions extend_for pre_pipe implicit_brackets implicit_return pipe bang default_args implicit_vars';\n\n  Kaffeine.fn.compile = function (text, uglify_opts) {\n    if (!text.match(/\\n$/)) text += '\\n'; // trailing newline\n\n    var directive = text.match(/^#\\s*([^\\n]*)\\s*\\n/) || [1, defaultDirective];\n    var plugins = directive[1].replace(/\\s+/g, ' ').replace(/ $/, '').split(' ');\n    text = text.slice(directive[0].length);\n    var ret = this.runPlugins(text, plugins);\n\n    if (uglify_opts) {\n      var ast = jsp.parse(ret); // parse code and get the initial AST\n\n      if (uglify_opts == 'uglify') {\n        ast = pro.ast_mangle(ast); // get a new AST with mangled names\n\n        ast = pro.ast_squeeze(ast); // get an AST with compression optimizations\n\n        ret = pro.gen_code(ast); // compressed code here\n      } else if (uglify_opts == 'beautify') {\n        ret = pro.gen_code(ast, {\n          beautify: true\n        });\n      }\n\n      ;\n    }\n\n    return ret;\n  };\n\n  Kaffeine.fn.runPlugins = function (text, plugins, options) {\n    text = 'function(){ ' + text + '\\n}'; // wrap in closure so we have a global closure and also no problems with start and end of text\n\n    var stream = Token.ize(text); // stream = Token.postprocess(stream);\n\n    this.currentStream = stream;\n    stream.global = stream.find(function () {\n      if (this.curly) {\n        return true;\n      }\n    });\n    stream.global.global = true;\n    options = options || {};\n\n    for (var i = 0; i < plugins.length; i++) {\n      var name = plugins[i];\n\n      var plugin = require('./plugins/' + name); // Kaffeine.plugins[name];\n\n\n      if (!plugin) {\n        throw \"\".concat(name, \" - not loaded\");\n      }\n\n      try {\n        plugin.call(this, stream, Token, options[name] || {}); // stream.normalize()\n      } catch (err) {\n        err.plugin = name;\n        throw err;\n      }\n    }\n\n    return stream.head().collectText().replace(/^function\\(\\)\\{/, '').replace(/\\n\\}$/, '');\n  }; // Kaffeine.fn.validate = function(text) {\n  //   try {\n  //     new Function(text)\n  //   }\n  //   catch (err) {\n  //     err.invalidJS = true\n  //     throw(err);\n  //   }\n  //   return text\n  // }\n  // Kaffeine.plugins[p] = require(\"./plugins/\"+p)[p]\n\n\n  if (require.extensions) {\n    require.extensions['.k'] = function (module, filename) {\n      var fs = require('fs');\n\n      var input = fs.readFileSync(filename, 'utf8');\n      var content = new Kaffeine().compile(input);\n      module.filename = \"\".concat(filename, \" (compiled)\");\n\n      module._compile(content, module.filename);\n    };\n  }\n\n  module.exports = Kaffeine; // end module: kaffeine/index.js\n});\n\nrequire.register('kaffeine/plugins/at.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/at.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.unknown && this.text == '@') {\n        var word = 'this';\n\n        if (this.next.text == '@') {\n          this.next.remove();\n          word = 'this.constructor';\n        }\n\n        var token = new Token.word(word);\n        token.was_at_symbol = true;\n        this.replaceWith(token);\n\n        if (token.next.word && !token.next.lbracket) {\n          token.after(new Token.operator(\".\"));\n        }\n\n        ;\n        return token;\n      }\n    });\n  }; // end module: kaffeine/plugins/at.js\n\n});\n\nrequire.register('kaffeine/plugins/bang.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/bang.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function (token) {\n      if (!token.bang) return;\n      var lbracket = token.next;\n\n      if (!lbracket || !lbracket.lbracket || !lbracket.round) {\n        var _pair = Token.bracket.pair('()');\n\n        token.after(_pair.L);\n\n        _pair.L.after(_pair.R);\n\n        lbracket = token.next;\n      }\n\n      var indent = token.indent();\n      var func = token.expressionStart(function () {\n        if (this.operator && this.text != '.') return true;\n      }); // break on operators\n\n      var func_before = func.prev;\n      var rbracket = lbracket.matching;\n      var before_start = func.lineStart();\n      var vars = []; // console.log(\"before_start\", before_start.collectText())\n\n      var fn = token.findClosure();\n      var x = fn.asyncBangCount || 0;\n      var args = '_' + x;\n\n      if (func_before && func_before.assign) {\n        var vars = before_start.collectText(func_before.prev).split(', ');\n        var v = [];\n\n        for (var i = 0; i < vars.length; i++) {\n          v.push('_' + (i + x));\n        }\n\n        args = v.join(', ');\n      } // debugger\n\n\n      var brackets = 0;\n      var before = null;\n\n      if (func == before_start) {\n        var brackets = 0;\n      } else {\n        var before = before_start.remove(func.prev);\n        before.each(function () {\n          if (this.lbracket) brackets++;\n          if (this.rbracket) brackets--;\n        });\n      }\n\n      var start_after_fn = rbracket.next;\n      var end_after_fn = start_after_fn.find(function () {\n        if (this.lbracket) return this.matching.next;\n\n        if (this.rbracket) {\n          if (brackets == 0) return true;\n          brackets--;\n        }\n\n        if (this.__break) return true;\n\n        if (this.next.text == \"---\") {\n          var text = this.next.myText();\n          this.next.replaceWith(text.replace(\"---\", \"   \"));\n          this.next.__break = true;\n        }\n      });\n      var after;\n\n      if (start_after_fn == end_after_fn) {// debugger\n        // if(!start_after_fn.rbracket )\n        //         after = start_after_fn.remove(end_after_fn)\n        // console.log(\"start_after_fn\", start_after_fn.text)\n      } else {\n        after = start_after_fn.remove(end_after_fn.prev);\n      }\n\n      var before_text = before ? before.collectText() : '';\n\n      if (before_text.match(/^[ \\n]*$/)) {\n        args = '';\n        if (before_text) func.before(before_text);\n      }\n\n      if (lbracket.next == rbracket) {\n        num_func_args = 0;\n      } else {\n        var func_args = lbracket.next.collectText(rbracket.prev);\n        var num_func_args = func_args.split(',').length;\n      }\n\n      if (after) {\n        after.find(function () {\n          if (this.was_at_symbol) {\n            var ffn = this.findClosure();\n\n            if (!ffn) {\n              fn.vars._this = \"this\";\n              this.text = \"_this\";\n            }\n          }\n        });\n      }\n\n      ;\n\n      if (args == '' && after && !after.myTextNoComments().match(/^[ \\n]*$/)) {\n        args = '_' + x;\n        x++;\n      }\n\n      if (vars.length > 1) {\n        var a = [];\n\n        for (var i = 0; i < vars.length; i++, x++) {\n          a.push(\"\".concat(vars[i], \" = \") + \"_\".concat(x));\n        }\n\n        before_text = a.join(', ');\n      } else {\n        x++;\n        before_text += args;\n      }\n\n      var funct = before_text + (after ? after.collectText() : '');\n      var body = Token.ize('function(' + args + ') { ' + funct + ' }');\n      if (num_func_args > 0) rbracket.before(', ');\n      rbracket.before(body);\n      token.text = token.text.replace(/!/, '');\n      body.next.matching.nextNW().updateBlock(); // implicit vars etc\n\n      body.block.asyncBangCount = x; // func.before(indent)\n    });\n  }; // var Token = require(\"../token\");\n  //\n  // module.exports = function(stream) {\n  //   stream.each(function(token) {\n  //\n  //     if(!token.bang) return\n  //\n  //     var lbracket = token.next\n  //\n  //     var func = token.expressionStart()\n  //\n  //     var indent = token.indent()\n  //\n  //     var vars = \"\"\n  //     if(func.prev.assign) {\n  //       var e = func.prev.prev\n  //       var s = e.expressionStart()\n  //       vars = s.remove(e).collectText()\n  //       func.prev.remove()\n  //     }\n  //\n  //     var rbracket = lbracket.matching\n  //\n  //     var start_fn = rbracket.next\n  //     var end_fn = start_fn.find(function() {\n  //       if(this.lbracket) return this.matching.next\n  //       if(this.rbracket) return true\n  //     })\n  //\n  //     var body = start_fn.remove(end_fn.prev)\n  //\n  //     var fn = this.findClosure()\n  //     body.find(function() {\n  //       if(this.was_at_symbol) {\n  //         var ffn = this.findClosure()\n  //         if(!ffn) {\n  //           fn.vars._this = \"this\"\n  //           this.text = \"_this\"\n  //         }\n  //       }\n  //     })\n  //\n  //     body = body.collectText()\n  //     var endsWithNL = body.match(/\\n *$/)\n  //     body = body.replace(/\\n/g, \"\\n  \")\n  //     // if(!body.match(/\\n$/))\n  //     //       body += \"\\n\"\n  //     //     body += indent\n  //     body += \" \"\n  //\n  //     body = body.replace(/\\s*\\n( *)$/, function(a, b) {\n  //       return \"\\n\" + b;\n  //     })\n  //\n  //\n  //     if(!endsWithNL)\n  //       body = body.replace(/\\n *$/, \" \")\n  //     var text = \"function(\" + vars + \") {\"  + body + \"}\"\n  //\n  //     if(lbracket.next != rbracket)\n  //       text = \", \" + text\n  //\n  //     var tokens = Token.ize(text)\n  //     tokens.banged_function = true\n  //\n  //     rbracket.before(tokens)\n  //     // if(!rbracket.next.newline)\n  //     //   rbracket.after(\"\\n\")\n  //     //token.bang = false\n  //     token.text = token.text.slice(0,token.text.length-1)\n  //     return token.next\n  //   })\n  // }\n  // end module: kaffeine/plugins/bang.js\n\n});\n\nrequire.register('kaffeine/plugins/brackets_for_keywords.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/brackets_for_keywords.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    var ks = ['if', 'for', 'while', 'catch'];\n    stream.each(function () {\n      if (ks.indexOf(this.text) < 0) return;\n      var n = this.nextNW();\n      if (n.lbracket && n.round) return;\n      var pair = Token.bracket.pair('()');\n      var tok = this;\n      var end = this.find(function (token) {\n        if (token.lbracket && token.curly) return true;\n        if (token.lbracket) return token.matching;\n        if (token.newline) return true;\n\n        if (token.text == ',') {\n          if (token.prev.prev != tok) {\n            return true;\n          }\n        }\n      }); // console.log(\"end\", end.text)\n      // var end = this.nextNW().expressionEnd(function() {\n      //   if(this.text == \",\") return true\n      // }).next\n\n      if (end.text == ',') {\n        end.spitRight();\n        end = end.next;\n        end.prev.remove();\n      }\n\n      if (end.operator && !end.unary_operator) {\n        end = end.expressionEnd().next;\n      }\n\n      if (!end.whitespace) {\n        end.spitRight();\n      }\n\n      ;\n      if (this.next.whitespace) this.next.remove();\n      this.after(pair.L);\n      var eaten = pair.L.next.eaten.left[0];\n\n      if (eaten && eaten.space) {\n        pair.L.next.spitLeft().remove();\n      }\n\n      ;\n      var eaten = this.eaten.right[0];\n\n      if (eaten && eaten.space) {\n        this.spitRight().remove();\n      }\n\n      ;\n      var curly = end.curly ? end : null;\n      if (end.prev.whitespace) end = end.prev;\n\n      if (end.operator) {\n        end.spit(function () {\n          return this.whitespace;\n        });\n        end = end.next;\n      }\n\n      end.before(pair.R);\n      var eaten = pair.R.prev.eaten.right[0];\n\n      if (eaten && eaten.space) {\n        pair.R.prev.spitRight().remove();\n        pair.R.after(' ');\n      }\n\n      if (curly) {\n        curly.updateBlock();\n      }\n\n      ; // if(end.operator) end.replaceWith(new Token.whitespace(\" \"))\n\n      this.addImpliedBraces();\n    });\n  }; // end module: kaffeine/plugins/brackets_for_keywords.js\n\n});\n\nrequire.register('kaffeine/plugins/default_args.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/default_args.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.text != 'function') return;\n      var block = this.block;\n      var bracket = this.block.prevNW().matching;\n      var inserts = [];\n      this.find(function () {\n        if (this == bracket.matching) return true;\n\n        if (this.text == '=') {\n          var v = this.prev.text;\n          var e = this.next.expressionEnd(function () {\n            if (this.text == ',') return true;\n          });\n          var val = this.next.remove(e).collectText();\n          var _ret = this.prev;\n          this.remove();\n          inserts.push(\"\".concat(v, \" = \").concat(v, \"==null ? \").concat(val, \" : \").concat(v));\n          return _ret;\n        }\n      });\n\n      if (inserts.length) {\n        this.block.after(\" \" + inserts.join(\", \") + \";\");\n      }\n\n      ;\n      block.args = block.findArgs();\n    });\n  }; // end module: kaffeine/plugins/default_args.js\n\n});\n\nrequire.register('kaffeine/plugins/extend_for.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/extend_for.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.keyword && this.text == \"for\") {\n        var text = \"\",\n            bracket = this.next,\n            skip = false,\n            toks = [],\n            var2,\n            var1,\n            loopWord,\n            complex;\n        var closingBracket = bracket.matching;\n        bracket.next.find(function () {\n          if (this.next == closingBracket) return true;\n\n          if (this.semi) {\n            skip = true;\n            return true;\n          }\n\n          if (this.word && (this.text == \"in\" || this.text == \"of\")) loopWord = this;\n          if (this.round) complex = true;\n          toks.push(this);\n        });\n        var var1 = toks[0];\n        if (toks[1].text == \",\") var2 = toks[2];\n        if (skip) return closingBracket.next;\n\n        if (complex) {\n          loopWord.next.next.cacheExpression();\n        }\n\n        var expressionText = loopWord.next.next.collectText(closingBracket.prev);\n        if (expressionText.match(/ /)) expressionText = \"(\" + expressionText + \")\";\n        var iter, val;\n        var closure = this.findClosure();\n        /*function wrapSingleLineBlock() {\n          if(!this.block) {\n            var pair = Token.bracket.pair(\"{}\")\n            closingBracket.after(\" \").after(pair.L)\n            var nl = 2\n            var indent = brace.indent()\n            \n            var next = pair.L.nextNW()\n            if(next.block) {\n              var tok = next.block.matching\n              if(tok.next.whitespace)\n                tok = tok.next\n            }\n            else if(next.bracelessBlock) {\n              var tok = next.bracelessBlock.end\n              if(tok.next.whitespace)\n                tok = tok.next\n            }\n            else {\n              var tok = closingBracket.find(function() {\n                if(this.newline) nl--\n                if(nl == 0) return true\n              })\n            }\n            \n            tok.after(pair.R)\n            if(indent)\n              pair.R.before(indent)\n            pair.R.after(\"\\n\")\n            pair.L.updateBlock()\n          }\n        }*/\n\n        var brace = bracket.matching.find(function () {\n          if (this.curly) return true;\n        });\n\n        if (loopWord.text == \"in\") {\n          if (!var2) return; // nothing to do !\n\n          brace.implied = false;\n          brace.matching.implied = false;\n          var2.prev.remove(var2);\n          iter = var1.text;\n          val = var2.text;\n          closure.vars[iter] = true;\n          closure.vars[val] = true;\n        } else {\n          brace.implied = false;\n          brace.matching.implied = false;\n          bracket.next.remove(closingBracket.prev);\n          iter = var2 ? var2.text : closure.getUnusedVar();\n          val = var1.text;\n          closure.vars[iter] = true;\n          closure.vars[val] = true;\n          var string = iter + \" = 0; \" + iter + \" < \" + expressionText + \".length; \" + iter + \"++\";\n          bracket.after(string);\n        }\n\n        var text = \" \"\n        /* + this.indent()*/\n        + val + \" = \" + (complex ? \"_xpr\" : expressionText) + \"[\" + iter + \"];\";\n        this.block.after(text);\n      }\n    });\n  }; // end module: kaffeine/plugins/extend_for.js\n\n});\n\nrequire.register('kaffeine/plugins/hash.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/hash.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.unknown && this.text == '#') {\n        var word = 'arguments';\n\n        if (!this.next.word) {\n          word += \"[0]\";\n        } else {\n          word += '[' + this.next.remove().collectText() + ']';\n        }\n\n        ret = this.next;\n        this.replaceWith(word);\n        return ret;\n      }\n    });\n  }; // end module: kaffeine/plugins/hash.js\n\n});\n\nrequire.register('kaffeine/plugins/implicit_brackets.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/implicit_brackets.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    var nobrackets_keywords = {\n      \"for\": 1,\n      \"if\": 1,\n      \"while\": 1,\n      \"new\": 1,\n      \"return\": 1,\n      \"var\": 1,\n      \"throw\": 1,\n      \"in\": 1,\n      of: 1,\n      \"typeof\": 1,\n      \"instanceof\": 1,\n      \"else\": 1,\n      \"try\": 1,\n      \"catch\": 1,\n      \"class\": 1\n    };\n    stream.tail().each(function () {\n      var ws = this.next;\n      if (!ws || !ws.space || !ws.next) return;\n      if (this.word && (nobrackets_keywords[this.text] && this.prev.text != '.' || this.block)) return;\n      if (nobrackets_keywords[ws.next.text]) return;\n\n      if (this.matching) {\n        var prev = this.matching.prevNW();\n\n        if (['for', 'if', 'while', 'else', 'catch'].indexOf(prev.text) >= 0) {\n          return;\n        }\n\n        ;\n      }\n\n      var nn = ws.next;\n      var match = (this.word || this.rbracket) && (nn.word || nn.lbracket || nn.string) && nn.blockType != 'function';\n      if (!match) return;\n      var end = nn.expressionEnd(function () {\n        if (this.text == ',' && this.next.next.text == ':') return true;\n      });\n      if (end == null) return;\n      var pair = Token.bracket.pair('()');\n      ws.replaceWith(pair.L);\n      if (end.whitespace) end = end.prev;\n      end.after(pair.R);\n    }, 'prev');\n  }; // end module: kaffeine/plugins/implicit_brackets.js\n\n});\n\nrequire.register('kaffeine/plugins/implicit_functions.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/implicit_functions.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function (token) {\n      if (token.blockType != 'object') return;\n      if (token.next == token.matching) return; // empty object\n\n      if (token.nextNW().next.text == ':') return; // must be an object\n\n      var text = 'function';\n      var prev = token.prevNW();\n\n      if (prev.text == ')') {\n        prev.matching.before(\"function\");\n      } else {\n        token.before(\"function() \");\n      }\n\n      ;\n      token.updateBlock();\n    });\n  }; // end module: kaffeine/plugins/implicit_functions.js\n\n});\n\nrequire.register('kaffeine/plugins/implicit_return.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/implicit_return.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (!this.blockType || this.blockType != 'function') return;\n      if (this.global) return;\n      var end = this.matching.prev.findRev(function (tok) {\n        return tok.whitespace || tok.semi ? null : true;\n      });\n      if (end == this || end.text == 'return') return; // probably an empty function\n      // sure this could be a bit neater\n\n      var start = end.findRev(function (tok) {\n        if (tok.rbracket) {\n          return tok.matching;\n        } else if (tok.lbracket && tok.curly) {\n          var type = tok.blockType;\n\n          if (type == 'function') {\n            return tok.prev.findRev(function (t) {\n              if (t.text == 'function') return true;\n            });\n          } else if (type == 'object') {\n            if (tok.prev.whitespace || tok.prev.semi || tok.prev.lbracket) {\n              return true;\n            }\n\n            ;\n          } else return false;\n        } else if (tok.prev.whitespace) {\n          if (tok.prev.prev.text == 'new') return tok.prev.prev;else return true;\n        } else if (tok.prev.semi || tok.prev.lbracket) {\n          return true;\n        } else {\n          return null;\n        }\n\n        ;\n      });\n      if (!start) return;\n      if (start.text == 'return') return;\n\n      if (start.prev.prev) {\n        var t = start.prev.prev.text;\n        if (t == 'throw' || t == 'return') return;\n      }\n\n      start.before(new Token.whitespace(' ')).before(new Token.word('return'));\n    });\n  }; // end module: kaffeine/plugins/implicit_return.js\n\n});\n\nrequire.register('kaffeine/plugins/implicit_vars.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/implicit_vars.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    var stack = [];\n    var variable;\n    var current;\n    var closure; // remove vars\n\n    stream.each(function (token) {\n      var ret = token.prev;\n      if (token.text != 'var') return;\n\n      if (token.next.space) {\n        token.next.remove();\n      }\n\n      ;\n      token.remove();\n      return ret;\n    });\n    stream.each(function (token) {\n      if (!token.assign) return;\n      variable = token.prev.text;\n      if (!/^[A-Za-z0-9$_]*$/.test(variable)) return;\n      if (token.prev.prev.operator && token.prev.prev.text != ',') return;\n      if (token.prev.prev.prev.text == 'var') return;\n      current = closure = this.findClosure();\n      var found = false;\n\n      while (current) {\n        if (current.vars[variable] || current.args[variable]) {\n          found = true;\n          break;\n        }\n\n        current = current.parent;\n      }\n\n      if (!found) {\n        // console.log(\"current\", variable)\n        closure.vars[variable] = true;\n      }\n    });\n  }; // end module: kaffeine/plugins/implicit_vars.js\n\n});\n\nrequire.register('kaffeine/plugins/multiline_strings.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/multiline_strings.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    var reg = /\\n/;\n    stream.each(function () {\n      if (!this.string || !reg.test(this.text)) return;\n      this.text = this.text.replace(/(\\\\)?\\n/g, function (str, escape) {\n        return escape ? '\\\\\\n' : '\\\\n\\\\\\n';\n      });\n    });\n  }; // end module: kaffeine/plugins/multiline_strings.js\n\n});\n\nrequire.register('kaffeine/plugins/operators.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/operators.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function (token) {\n      if (!token.operator) return;\n\n      if (token.text == '||=') {\n        var op = \"|| \";\n      } else if (token.text == '.=') {\n        var op = \".\";\n      } else return;\n\n      optoken = token.after(op);\n      token.text = '=';\n      var lhs = '';\n      token.prev.findRev(function (token) {\n        if (token.whitespace || token.unknown) return true;\n        lhs = token.text + lhs;\n      });\n      var tokens = Token.ize(lhs);\n      if (op != '.') tokens.tail().eaten.right.push(Token.ize(' '));\n      token.after(tokens, tokens.tail());\n    }); // extend\n\n    var inserted = false;\n    stream.each(function (token) {\n      if (token.text != '<-') return;\n      var arrow = this;\n      var L = this.expressionStart();\n      var lhs = L.remove(arrow.prev).collectText();\n      var R = arrow.next.expressionEnd(function () {});\n      var rhs = arrow.next.remove(R).collectText();\n      var ret = arrow.prev;\n      arrow.replaceWith('__extend(' + lhs + ', ' + rhs + ')'); // token.global.vars['__extend'] = __extend.toString()\n\n      if (!inserted) {\n        var g = stream.block;\n        if (!g.global) throw 'WTF!';\n        g.matching.before(new Token.word(__extend));\n        inserted = true;\n      }\n\n      return ret;\n    });\n  };\n\n  var __extend = '\\nfunction __extend(a,b) {\\n\\\n  var c = {}, i;\\n\\\n  a = a || {};\\n\\\n  for(i in a) c[i] = a[i];\\n\\\n  for(i in b) c[i] = b[i];\\n\\\n  return c;\\n\\\n}'; // end module: kaffeine/plugins/operators.js\n});\n\nrequire.register('kaffeine/plugins/pipe.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/pipe.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.text != '|') return;\n      var pipe = this;\n      var L = this.expressionStart();\n      var lhs = L.remove(pipe.prev); // .collectText()\n\n      var R = pipe.next.expressionEnd(function () {\n        return this.text == '|';\n      });\n      var rhs = pipe.next.remove(R); // .collectText()\n\n      var ret = pipe.prev;\n      pair = Token.bracket.pair('()');\n      tokens = Token.ize('__.' + pipe.pipe_function + '.call');\n      tokens.append(pair.L);\n      tokens.append('this, ');\n      tokens.append(lhs);\n      tokens.append(', ');\n      tokens.append(rhs);\n      tokens.append(pair.R);\n      pipe.replaceWith(tokens); // \"__.\" + pipe.pipe_function + \".call(this, \" + lhs + \", \" + rhs + \")\")\n\n      return ret;\n    });\n  }; // end module: kaffeine/plugins/pipe.js\n\n});\n\nrequire.register('kaffeine/plugins/pre_pipe.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/pre_pipe.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.text == '|' || this.text == '|.') {\n        var L = this.expressionStart();\n\n        if (this.text == '|.' || this.next.assign) {\n          this.text = '__' + this.text.slice(1);\n          delete this.operator;\n          this.word = true;\n          return;\n        }\n\n        if (this.text != '|') {\n          throw \"unknown pipe operation\";\n        }\n\n        ;\n        var fn = this.next;\n        this.pipe_function = this.next.text;\n        this.next.remove();\n        if (this.next.whitespace) this.next.remove();\n        return this.next;\n      }\n    });\n  }; // end module: kaffeine/plugins/pre_pipe.js\n\n});\n\nrequire.register('kaffeine/plugins/prototype.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/prototype.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    var klass = '';\n    stream.each(function () {\n      if (this.namedFunction) {\n        klass = this.namedFunction.text;\n        return;\n      }\n\n      if (this.word && this.text == 'prototype') {\n        if (this.prev.text == '.') {\n          klass = this.prev.prev.text;\n        }\n\n        ;\n        return;\n      }\n\n      var ret = this.next;\n\n      if (this.text == '::') {\n        this.spit(function () {\n          return this.whitespace;\n        });\n        var text = '.prototype.';\n\n        if (this.prev.word) {\n          klass = this.prev.text;\n        } else {\n          text = klass + text;\n        }\n\n        ;\n        this.replaceWith(text);\n      }\n\n      return ret;\n    });\n  }; // end module: kaffeine/plugins/prototype.js\n\n});\n\nrequire.register('kaffeine/plugins/string_interpolation.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/string_interpolation.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (!this.string) return; // combine nested\n\n      if (/#{\"$/.test(this.text)) {\n        var text = \"\";\n        var end = this.next.find(function () {\n          text += this.text;\n          if (this.string && /^\"}/.test(this.text)) return true;\n        });\n        this.text += text;\n        this.next.remove(end);\n      }\n\n      if (/^\".*[#]/.test(this.text)) {\n        var ret = this.next;\n        var string = expandOnce(this.text);\n        this.replaceWith(string);\n        return ret;\n      }\n    }); // remove double brackets\n\n    stream.each(function () {\n      if (this.lbracket && this.round && this.next.lbracket && this.next.round) {\n        var n = this.matching.prev;\n\n        if (n.rbracket && n.round) {\n          this.next.remove();\n          n.remove();\n        }\n      }\n    });\n  }; // partially borrowed from visionmedia's Jade\n  // var regSimple = /(\\\\)?[$]([A-Za-z0-9.@_]+)/g\n\n\n  var regComplex = /(\\\\)?#{(.*?)}/g;\n\n  function expandOnce(text) {\n    var changed = false;\n    var interp = text.replace(regComplex, function (str, esc, code) {\n      if (!esc) changed = true;\n      return esc ? str.slice(1) : \"\\\" + (\".concat(code.replace(/\\\\\"/g, '\"'), \") + \\\"\");\n    });\n\n    if (changed) {\n      interp = \"(\" + interp + \")\";\n    }\n\n    ; // interp = interp.replace('\"\" + ', \"\")\n\n    interp = interp.replace(' + \"\"', '');\n    return interp;\n  } // end module: kaffeine/plugins/string_interpolation.js\n\n});\n\nrequire.register('kaffeine/plugins/undouble_brackets.js', function (module, exports, require) {\n  // start module: kaffeine/plugins/undouble_brackets.js\n  var Token = require(\"../token\");\n\n  module.exports = function (stream) {\n    stream.each(function () {\n      if (this.lbracket && this.round && this.next.lbracket && this.next.round) {\n        var n = this.matching.prev;\n\n        if (n.rbracket && n.round) {\n          this.next.remove();\n          n.remove();\n        }\n      }\n    });\n  }; // end module: kaffeine/plugins/undouble_brackets.js\n\n});\n\nrequire.register('kaffeine/token.js', function (module, exports, require) {\n  // start module: kaffeine/token.js\n  var inherits = function inherits(child, parent) {\n    var ctor = function ctor() {};\n\n    ctor.prototype = parent.prototype;\n    child.__super__ = parent.prototype;\n    child.prototype = new ctor();\n    child.prototype.constructor = child;\n    child.fn = child.prototype;\n  };\n\n  function base(text) {\n    this.text = text;\n    this.id = base.id++;\n    this.eaten = {\n      left: [],\n      right: []\n    };\n  }\n\n  base.id = 0;\n  base.fn = base.prototype;\n  base.klasses = [whitespace, word, string, comment, regex, operator, bracket, semi];\n\n  function preprocess(text) {\n    text = text.replace(/\\t/g, '  ').replace(/ *\\n/g, '\\n').replace(/\\r\\n|\\r/g, '');\n    return text;\n  }\n\n  function\n  /*Token */\n  ize(input) {\n    input = preprocess(input);\n    var klass;\n    var match;\n    var i;\n    var index = 0;\n    var head;\n    var tail;\n\n    for (i = 0; i < base.klasses.length; i++) {\n      base.klasses[i].match = undefined;\n    }\n\n    ;\n\n    while (index < input.length) {\n      for (i = 0; i < base.klasses.length; i++) {\n        klass = base.klasses[i];\n        match = base.getMatch(klass, index, input);\n        if (match) break;\n      }\n\n      if (match) {\n        emit(new klass(match));\n        index += match.length;\n      } else {\n        emit(new unknown(input.charAt(index)));\n        index += 1;\n      }\n    }\n\n    function emit(token) {\n      if (tail) {\n        tail.next = token;\n        token.prev = tail;\n        tail = token;\n      } else {\n        head = tail = token;\n      }\n\n      ;\n    }\n\n    head = postprocess(head);\n    return head;\n  }\n\n  function postprocess(stream) {\n    // match brackets\n    var stack = [];\n    stream.each(function () {\n      if (this.bracket) {\n        if (this.lbracket) stack.push(this);else this.matchWith(stack.pop());\n      }\n\n      ;\n    });\n\n    if (stack.length) {\n      throw \"unmatching number of brackets\";\n    }\n\n    ; // sort out block types\n\n    stream.each(function () {\n      if (this.curly && this.lbracket) this.updateBlock();\n    }); // remove comments & hungry operators & hungry left round brackets\n\n    stream.normalize();\n    return stream;\n  } // normalize is at the start and run after ever plugin\n  // it ensures various assumptions are true ...\n\n\n  base.fn.normalize = function () {\n    this.each(function () {\n      var next = this.next; // there are never 2 space tokens next to each other\n\n      if (this.next && this.next.whitespace && ['for'].indexOf(this.text) >= 0) {\n        this.eatRight();\n      }\n\n      if (this.space) {\n        if (next && next.space) {\n          this.eatRight(function () {\n            return this.space;\n          });\n        }\n      } else if (this.comment) {\n        // comments are eaten by their next..\n        next.eatLeft();\n        return next.prev;\n      } else if (this.operator) {\n        // operators are never adjacent to whitespace\n        this.eat(function () {\n          return this.whitespace;\n        });\n        this.eat(function () {\n          return this.whitespace;\n        });\n      } else {\n        // brackets next have previous whitespace\n        if (this.rbracket && this.prev.whitespace && !this.matching.global) {\n          this.eatLeft();\n        }\n\n        ;\n      }\n    }); // now let's assign code blocks to keywords without {}'s\n\n    this.each(function () {\n      this.addImpliedBraces();\n    });\n  };\n\n  base.fn.addImpliedBraces = function () {\n    if (this.block || [\"if\", \"for\", \"while\", \"try\", \"else\", \"catch\"].indexOf(this.text) < 0) return;\n    var closingBracket = this.next.matching; // require's brackets\n\n    if (!closingBracket) return;\n\n    function end(tok) {\n      if (tok.block) return tok.block.matching;\n      if ([\"if\", \"for\", \"while\", \"try\", \"else\", \"catch\"].indexOf(tok.text) >= 0) return end(tok.next.matching.nextNW());\n      return tok.find(function () {\n        if (this.lbracket) return this.matching;\n        if (this.next.newline) return true;\n        if (this.next.rbracket && this.next.curly) return true;\n      });\n    }\n\n    var pair = bracket.pair(\"{}\");\n    pair.L.implied = true;\n    pair.R.implied = true;\n    var next = closingBracket.nextNW();\n    end(next).after(pair.R);\n    closingBracket.after(\" \").after(pair.L);\n    var indent = this.indent();\n    pair.R.before(\" \"); //pair.R.before(pair.L.next.newline ? \"\\n\" + indent : \" \")  \n\n    pair.L.updateBlock();\n    pair.L.eatLeft();\n    pair.R.eatLeft();\n    if (pair.R.prev.whitespace) pair.R.eatLeft();\n  };\n\n  base.fn.after = function (head) {\n    if (typeof head === 'string') head =\n    /*Token. */\n    ize(head);\n    tail = head.tail();\n\n    if (this.next) {\n      this.next.prev = tail;\n      tail.next = this.next;\n    }\n\n    this.next = head;\n    head.prev = this;\n    return tail;\n  };\n\n  base.fn.before = function (head) {\n    if (typeof head === 'string') head =\n    /*Token. */\n    ize(head);\n    tail = head.tail();\n\n    if (this.prev) {\n      this.prev.next = head;\n      head.prev = this.prev;\n    }\n\n    this.prev = tail;\n    tail.next = this;\n    return head;\n  };\n\n  base.fn.head = function () {\n    var tok = this;\n\n    while (tok.prev) {\n      tok = tok.prev;\n    }\n\n    return tok;\n  };\n\n  base.fn.tail = function () {\n    var tok = this;\n\n    while (tok.next) {\n      tok = tok.next;\n    }\n\n    return tok;\n  };\n\n  base.fn.remove = function (tail) {\n    tail = tail || this;\n    if (tail.next) tail.next.prev = this.prev;\n    if (this.prev) this.prev.next = tail.next;\n    tail.next = null;\n    this.prev = null;\n    return this;\n  };\n\n  base.fn.replaceWith = function (head) {\n    if (typeof head === 'string') head =\n    /*Token. */\n    ize(head);\n    var tail = this.after(head);\n    this.remove();\n    return tail;\n  };\n\n  base.fn.append = function (tokens) {\n    if (typeof tokens === 'string') tokens =\n    /*Token */\n    ize(tokens);\n    var tail = this.tail();\n    tail.next = tokens;\n    tokens.prev = tail;\n  };\n\n  base.fn.find = function (fn, skip) {\n    var token = this;\n    var i = 0;\n\n    while (token) {\n      var result = fn.call(token, token, i++);\n\n      if (result === true) {\n        if (!skip) return token;\n        skip--;\n      }\n\n      if (result === false) return null;\n      token = result ? result : token.next;\n    }\n  };\n\n  base.fn.findRev = function (fn, skip) {\n    var token = this;\n    var i = 0;\n\n    while (token) {\n      var result = fn.call(token, token, i++);\n\n      if (result === true) {\n        if (!skip) return token;\n        skip--;\n      }\n\n      if (result === false) return null;\n      token = result ? result : token.prev;\n    }\n  };\n\n  base.fn.prevNW = function () {\n    return this.prev.findRev(function () {\n      if (!this.whitespace) return true;\n    });\n  };\n\n  base.fn.nextNW = function () {\n    return this.next.find(function () {\n      if (!this.whitespace) return true;\n    });\n  };\n\n  base.fn.lineStart = function (breakFn) {\n    var s = this.findRev(function () {\n      var x = this;\n      if (this.rbracket) return this.matching;\n      x = x.prev;\n      y = x.prev;\n\n      if (x.lbracket && x.curly && x.blockType != 'object') {\n        return true;\n      } // if(x.assign) return true\n\n\n      if (x.semi) {\n        return true;\n      }\n\n      if (x.whitespace) {\n        if (y.word) return true;\n        if (y.rbracket) return true; // if(y.whitespace) return true\n      } // if(breakFn && breakFn.call(x,x)) return true\n\n    });\n    if (s.whitespace) s = s.nextNW();\n    return s;\n  };\n\n  base.fn.expressionStart = function (breakFn) {\n    return this.findRev(function () {\n      var x = this;\n      if (this.rbracket) return this.matching;\n      x = x.prev;\n      if (x.whitespace || x.semi || x.assign || x.lbracket) return true; // || x.comparison\n\n      if (breakFn && breakFn.call(x, x)) return true;\n    });\n  };\n\n  base.fn.expressionEnd = function (breakFn) {\n    return this.find(function () {\n      if (this.lbracket) return this.matching;\n      if (this.block) return this.block;\n      var x = this.next;\n      if (x.whitespace || x.semi || x.assign || x.rbracket) return true; // || x.comparison\n\n      if (breakFn && breakFn.call(x, x)) return true;\n    });\n  };\n\n  base.getMatch = function (klass, index, input) {\n    if (klass.match === false) return;\n\n    if (!klass.match || klass.match.index < index) {\n      klass.match = null;\n      klass.regex.lastIndex = index;\n      klass.match = klass.regex.exec(input);\n      if (!klass.match) klass.match = false;\n    }\n\n    if (klass.match && klass.match.index == index) {\n      return klass.extract ? klass.extract(index, input) : klass.match[0];\n    }\n\n    ;\n  };\n\n  base.fn.each = function (fn, dir) {\n    var tok = this;\n    dir = dir || 'next';\n\n    while (tok) {\n      var result = fn.call(tok, tok);\n      if (result === false) break;\n      last = tok;\n      tok = result instanceof base ? result : tok[dir]; // skip to result if it's a token\n    }\n\n    return last.head();\n  };\n\n  base.fn.eat = function (test) {\n    this.eatLeft(test);\n    this.eatRight(test);\n  };\n\n  base.fn.eatLeft = function (test) {\n    var token = this.prev;\n\n    if (token && (!test || test.call(token))) {\n      token.remove();\n      this.eaten.left.unshift(token);\n      this.newline = this.myText().match(/\\n/);\n    }\n  };\n\n  base.fn.eatRight = function (test) {\n    var token = this.next;\n\n    if (token && (!test || test.call(token))) {\n      token.remove();\n      this.eaten.right.push(token);\n      this.newline = this.myText().match(/\\n/);\n    }\n  };\n\n  base.fn.spit = function (test) {\n    this.spitLeft(test);\n    this.spitRight(test);\n  };\n\n  base.fn.spitLeft = function (test) {\n    var token = this.eaten.left.shift();\n\n    if (token && (!test || test.call(token))) {\n      this.before(token);\n      this.newline = this.myText().match(/\\n/);\n    }\n\n    return token;\n  };\n\n  base.fn.spitRight = function (test) {\n    var token = this.eaten.right.pop();\n\n    if (token && (!test || test.call(token))) {\n      this.after(token);\n      this.newline = this.myText().match(/\\n/);\n    }\n\n    return token;\n  };\n\n  base.fn.myTextNoComments = function () {\n    return this.comment ? '' : this.myText();\n  };\n\n  base.fn.myText = function () {\n    var text = [];\n    var vars;\n    if (this.implied) return '';\n\n    for (var i = 0; i < this.eaten.left.length; i++) {\n      text.push(this.eaten.left[i].myText());\n    }\n\n    ;\n    text.push(this.text);\n\n    if (this.vars) {\n      vars = this.declareVariables();\n      this.nextNW().before(new word(vars)); // text.push(vars)\n    }\n\n    for (var i = 0; i < this.eaten.right.length; i++) {\n      text.push(this.eaten.right[i].myText());\n    }\n\n    ;\n    return text.join('');\n  };\n\n  base.fn.collectText = function (end) {\n    var text = [];\n    var token = this;\n\n    while (token) {\n      text.push(token.myText());\n      if (token == end) break;\n      token = token.next;\n    }\n\n    return text.join('');\n  };\n\n  base.fn.collectTextNoComments = function (end) {\n    var text = [];\n    var token = this;\n\n    while (token) {\n      text.push(token.myTextNoComments());\n      if (token == end) break;\n      token = token.next;\n    }\n\n    return text.join('');\n  };\n\n  base.fn.findClosure = function () {\n    var parent = this.prev.findRev(function (tok) {\n      if (tok.rbracket) return tok.matching.prev; // skip behind\n\n      if (tok.blockType == 'function') return true;\n    });\n    this.parent = parent; // || this.head() // i,e if not found we're in the global scope\n\n    return this.parent;\n  };\n\n  base.fn.prevNewline = function (includeThis, skipBrackets) {\n    var start = includeThis ? this : this.prev;\n    var nl = start.findRev(function (tok) {\n      if (tok.newline) return true;\n      if (skipBrackets && tok.rbracket) return tok.matching.prev; // skip behind\n    });\n    return nl;\n  };\n\n  base.fn.nextNewline = function (includeThis, skipBrackets) {\n    var start = includeThis ? this : this.next;\n    var nl = start.find(function (tok) {\n      if (tok.newline) return true;\n      if (skipBrackets && tok.lbracket) return tok.matching.next; // skip over\n    });\n    return nl;\n  };\n\n  base.fn.nextNewlineOrRbracket = function () {\n    return this.next.find(function (tok) {\n      if (tok.rbracket) return true;\n      if (tok.newline) return true;\n      if (tok.lbracket) return tok.matching.next; // skip over\n    });\n  };\n\n  base.fn.followingWhitespaceWithNewline = function () {\n    return this.next.find(function () {\n      if (this.newline) return true;\n      if (this.whitespace) return null;\n      return false;\n    });\n  };\n\n  base.fn.indent = function () {\n    var nl = this.prevNewline('include');\n    if (!nl) return ''; // return nl.next.whitespace ? nl.next : \"\"\n\n    var text = nl.next.myText();\n    var match = text.match(/^( *)/);\n    return match ? match[1] : '';\n  };\n\n  base.fn.getUnusedVar = function (prefix) {\n    var num = 10;\n    var name;\n    prefix = prefix || '_';\n\n    while (true) {\n      name = num.toString(36);\n\n      if (!this.vars[prefix + name]) {\n        break;\n      }\n\n      ;\n      num++;\n    }\n\n    return prefix + name;\n  };\n\n  base.fn.cacheExpression = function (name) {\n    name = name || '_xpr';\n    var pair = bracket.pair('()');\n    var closure = this.findClosure();\n    closure.vars[name] = true;\n    this.expressionStart().before(new operator('=')).before(new word(name)).before(pair.L);\n    this.expressionEnd().after(pair.R);\n  };\n\n  function unknown(text) {\n    base.call(this, text);\n  }\n\n  inherits(unknown, base);\n  unknown.fn.unknown = true;\n\n  function whitespace(text) {\n    base.call(this, text);\n    this.newline = /\\n/.test(text);\n    this.space = !this.newline;\n  }\n\n  inherits(whitespace, base);\n  whitespace.fn.whitespace = true;\n  whitespace.regex = / +|\\n/g;\n  var keywords = 'if for while else try catch function return var'.split(' ');\n\n  function word(text) {\n    base.call(this, text);\n\n    if (keywords.indexOf(text) >= 0) {\n      this.keyword = true;\n    }\n\n    ;\n\n    if (text.match(/!$/)) {\n      this.bang = true;\n    }\n\n    ;\n  }\n\n  inherits(word, base);\n  word.fn.word = true;\n  word.regex = /[A-Za-z0-9_$]+!?/g;\n\n  function string(text) {\n    base.call(this, text);\n  }\n\n  inherits(string, base);\n  string.fn.string = true;\n  string.regex = /['\"]/g;\n\n  function regex(text) {\n    base.call(this, text);\n  }\n\n  inherits(regex, base);\n  regex.fn.regex = true;\n  regex.fn.string = true;\n  regex.regex = /\\/[^*\\/ ][^\\n]*\\//g;\n\n  function comment(text) {\n    base.call(this, text);\n    this.single = this.text.match(/^\\/\\//);\n  }\n\n  inherits(comment, base);\n  comment.fn.comment = true;\n  comment.regex = /\\/\\*|\\/\\//g;\n  var comparisonOperators = ['<=', '<', '>=', '>', '==', '!=', '===', '!==', '||', '&&'];\n  var unaryOperators = ['++', '--', '!', '~', '&', '|'];\n\n  function operator(text) {\n    base.call(this, text); // this.op = this.text\n\n    this.assign = /^=$/.test(text);\n    this.comparison = comparisonOperators.indexOf(this.text) >= 0;\n    this.unary_operator = unaryOperators.indexOf(this.text) >= 0;\n  }\n\n  inherits(operator, base);\n  operator.fn.operator = true;\n  operator.regex = /[!%^&*\\-=+:,.|\\\\~<>\\?]+|\\/|\\/=/g; // we dont support operators containing forward slash other than '/' and '/='  (too difficult to compare with // and /*)\n\n  function semi(text) {\n    base.call(this, text);\n  }\n\n  inherits(semi, base);\n  semi.fn.semi = true;\n  semi.regex = /;/g;\n\n  function bracket(text) {\n    base.call(this, text);\n    this.lbracket = text.match(/[\\(\\[\\{]/);\n    this.rbracket = !this.lbracket;\n\n    if (text == '{' || text == '}') {\n      this.curly = true;\n    } else if (text == '(' || text == ')') {\n      this.round = true;\n    } else if (text == '[' || text == ']') {\n      this.square = true;\n    }\n\n    ;\n  }\n\n  inherits(bracket, base);\n  bracket.fn.bracket = true;\n  bracket.regex = /[\\(\\)\\[\\]\\{\\}]/g;\n\n  bracket.fn.matchWith = function (other) {\n    other.matching = this;\n    this.matching = other;\n  };\n\n  bracket.pair = function (s) {\n    var letters = s.split('');\n    var L = new bracket(letters[0]);\n    var R = new bracket(letters[1]);\n    L.matchWith(R);\n    return {\n      L: L,\n      R: R\n    };\n  };\n\n  var blockKeywords = 'if for while else try catch function'.split(' ');\n\n  bracket.fn.updateBlock = function () {\n    var state = {\n      bracket: false,\n      name: false\n    };\n    var type;\n\n    if (this.prev) {\n      type = this.prev.findRev(function (token) {\n        if (token.whitespace) return null; // skip whitespace\n        else if (token.rbracket && token.rbracket) {\n            state.bracket = token.matching;\n            return token.matching.prev; // skip before matching bracket\n          } else if (token.word) {\n            if (blockKeywords.indexOf(token.text) >= 0) {\n              return true;\n            } // found it!\n            else if (!state.name) {\n                state.name = token;\n                return null; // skip variables\n              } else return false;\n          } else return false; // fail no keyword found\n      });\n    }\n\n    if (type) {\n      this.blockType = type.text;\n      type.block = this;\n      type.namedFunction = state.name;\n      type.bracketExpression = state.bracket;\n    } else {\n      this.blockType = 'object';\n    }\n\n    if (this.blockType == 'function') {\n      this.findClosure();\n      this.args = this.findArgs();\n      this.vars = {};\n    }\n  };\n\n  bracket.fn.findArgs = function () {\n    if (!this.prev) return {};\n    var args = {};\n    var prev = this.prev.whitespace ? this.prev.prev : this.prev;\n    if (!prev.matching) return;\n    var text = prev.matching.collectText(prev).replace(/[\\(\\) ]/g, '');\n    var words = text.split(',');\n\n    if (text.length) {\n      for (var i = 0; i < words.length; i++) {\n        args[words[i]] = true;\n      }\n    }\n\n    ;\n    return args;\n  };\n\n  bracket.fn.declareVariables = function () {\n    var vars = [];\n\n    for (var j in this.vars) {\n      var text = j;\n\n      if (typeof this.vars[j] === 'string') {\n        text += \" = \" + this.vars[j];\n      }\n\n      ;\n      vars.push(text);\n    }\n\n    if (!vars.length) return '';\n    var string = 'var ' + vars.join(', ') + '; ';\n    var space = this.global ? '' : ' ';\n    string = string; // should find current indent really\n\n    return string;\n  };\n\n  string.extract = function (index, input) {\n    var mode = input.charAt(index);\n    var i = index + 1;\n    var last;\n    var word = mode;\n\n    while (i < input.length) {\n      var ch = input.charAt(i);\n      word += ch;\n      if (ch == mode && last != '\\\\') return word;\n      last = ch;\n      i += 1;\n    }\n  };\n\n  comment.extract = function (index, input) {\n    var comment = '';\n    var prev = '';\n    var type = input.charAt(index + 1);\n\n    while (index < input.length) {\n      var ch = input.charAt(index);\n      if (type == '/' && ch == '\\n') return comment;\n\n      if (type == '*' && ch == '/' && prev == '*') {\n        return comment + \"/\";\n      }\n\n      ;\n      comment += ch;\n      index += 1;\n      prev = ch;\n    }\n  };\n\n  regex.extract = function (index, input) {\n    var regex = \"/\",\n        prev = \"\",\n        esc,\n        inSQ;\n\n    while (index < input.length) {\n      var ch = input.charAt(index + 1);\n      regex += ch;\n      esc = prev == \"\\\\\";\n\n      if (ch == \"/\" && !esc && !inSQ) {\n        var next = input.charAt(index + 2);\n        if (next == \"m\" || next == \"g\" || next == \"i\") regex += next;\n        return regex;\n      }\n\n      if (ch == \"[\" && !esc) inSQ = true;else if (ch == \"]\" && !esc && inSQ) inSQ = false;\n      index += 1;\n      prev = ch;\n    }\n  };\n\n  module.exports = {\n    whitespace: whitespace,\n    operator: operator,\n    string: string,\n    word: word,\n    comment: comment,\n    bracket: bracket,\n    unknown: unknown,\n    semi: semi,\n    ize: ize,\n    postprocess: postprocess,\n    base: base\n  }; // end module: kaffeine/token.js\n});\n\nrequire.register('kaffeine/uglify/parse-js.js', function (module, exports, require) {\n  // start module: kaffeine/uglify/parse-js.js\n\n  /***********************************************************************\n   A JavaScript tokenizer / parser / beautifier / compressor.\n   This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n   This file contains the tokenizer/parser.  It is a port to JavaScript\n  of parse-js [1], a JavaScript parser library written in Common Lisp\n  by Marijn Haverbeke.  Thank you Marijn!\n   [1] http://marijn.haverbeke.nl/parse-js/\n   Exported functions:\n     - tokenizer(code) -- returns a function.  Call the returned\n      function to fetch the next token.\n     - parse(code) -- returns an AST of the given JavaScript code.\n   -------------------------------- (C) ---------------------------------\n                            Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n   Distributed under the same terms as the original code (ZLIB license):\n     Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n     This software is provided 'as-is', without any express or implied\n    warranty. In no event will the authors be held liable for any\n    damages arising from the use of this software.\n     Permission is granted to anyone to use this software for any\n    purpose, including commercial applications, and to alter it and\n    redistribute it freely, subject to the following restrictions:\n     1. The origin of this software must not be misrepresented; you must\n       not claim that you wrote the original software. If you use this\n       software in a product, an acknowledgment in the product\n       documentation would be appreciated but is not required.\n     2. Altered source versions must be plainly marked as such, and must\n       not be misrepresented as being the original software.\n     3. This notice may not be removed or altered from any source\n       distribution.\n  ********************************************************************** */\n\n  /* -----[ Tokenizer (constants) ]----- */\n  var KEYWORDS = array_to_hash(['break', 'case', 'catch', 'const', 'continue', 'default', 'delete', 'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof', 'new', 'return', 'switch', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'NaN']);\n  var RESERVED_WORDS = array_to_hash(['abstract', 'boolean', 'byte', 'char', 'class', 'debugger', 'double', 'enum', 'export', 'extends', 'final', 'float', 'goto', 'implements', 'import', 'int', 'interface', 'long', 'native', 'package', 'private', 'protected', 'public', 'short', 'static', 'super', 'synchronized', 'throws', 'transient', 'volatile']);\n  var KEYWORDS_BEFORE_EXPRESSION = array_to_hash(['return', 'new', 'delete', 'throw']);\n  var KEYWORDS_ATOM = array_to_hash(['false', 'null', 'true', 'undefined', 'NaN']);\n  var OPERATOR_CHARS = array_to_hash(characters('+-*&%=<>!?|~^'));\n  var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n  var RE_OCT_NUMBER = /^0[0-7]+$/;\n  var RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e-?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n  var OPERATORS = array_to_hash(['in', 'instanceof', 'typeof', 'new', 'void', 'delete', '++', '--', '+', '-', '!', '~', '&', '|', '^', '*', '/', '%', '>>', '<<', '>>>', '<', '>', '<=', '>=', '==', '===', '!=', '!==', '?', '=', '+=', '-=', '/=', '*=', '%=', '>>=', '<<=', '>>>=', '~=', '%=', '|=', '^=', '&&', '||']);\n  var WHITESPACE_CHARS = array_to_hash(characters(' \\n\\r\\t'));\n  var PUNC_BEFORE_EXPRESSION = array_to_hash(characters('[{}(,.;:'));\n  var PUNC_CHARS = array_to_hash(characters('[]{}(),;:'));\n  var REGEXP_MODIFIERS = array_to_hash(characters('gmsiy'));\n  /* -----[ Tokenizer ]----- */\n\n  function is_alphanumeric_char(ch) {\n    ch = ch.charCodeAt(0);\n    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;\n  }\n\n  function is_identifier_char(ch) {\n    return is_alphanumeric_char(ch) || ch == '$' || ch == '_';\n  }\n\n  function is_digit(ch) {\n    ch = ch.charCodeAt(0);\n    return ch >= 48 && ch <= 57;\n  }\n\n  function parse_js_number(num) {\n    if (RE_HEX_NUMBER.test(num)) {\n      return parseInt(num.substr(2), 16);\n    } else if (RE_OCT_NUMBER.test(num)) {\n      return parseInt(num.substr(1), 8);\n    } else if (RE_DEC_NUMBER.test(num)) {\n      return parseFloat(num);\n    }\n  }\n\n  function JS_Parse_Error(message, line, col, pos) {\n    this.message = message;\n    this.line = line;\n    this.col = col;\n    this.pos = pos;\n\n    try {\n      ({})();\n    } catch (ex) {\n      this.stack = ex.stack;\n    }\n  }\n\n  ;\n\n  JS_Parse_Error.prototype.toString = function () {\n    return \"\".concat(this.message, \" (line: \").concat(this.line, \", col: \").concat(this.col, \", pos: \").concat(this.pos, \")\") + \"\\n\\n\".concat(this.stack);\n  };\n\n  function js_error(message, line, col, pos) {\n    throw new JS_Parse_Error(message, line, col, pos);\n  }\n\n  function is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n  }\n\n  var EX_EOF = {};\n\n  function tokenizer($TEXT, skip_comments) {\n    var S = {\n      text: $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n'),\n      pos: 0,\n      tokpos: 0,\n      line: 0,\n      tokline: 0,\n      col: 0,\n      tokcol: 0,\n      newline_before: false,\n      regex_allowed: false\n    };\n\n    function peek() {\n      return S.text.charAt(S.pos);\n    }\n\n    function next(signal_eof) {\n      var ch = S.text.charAt(S.pos++);\n\n      if (signal_eof && !ch) {\n        throw EX_EOF;\n      }\n\n      if (ch == '\\n') {\n        S.newline_before = true;\n        ++S.line;\n        S.col = 0;\n      } else {\n        ++S.col;\n      }\n\n      return ch;\n    }\n\n    function eof() {\n      return !S.peek();\n    }\n\n    function find(what, signal_eof) {\n      var pos = S.text.indexOf(what, S.pos);\n      if (signal_eof && pos == -1) throw EX_EOF;\n      return pos;\n    }\n\n    function start_token() {\n      S.tokline = S.line;\n      S.tokcol = S.col;\n      S.tokpos = S.pos;\n    }\n\n    function token(type, value) {\n      S.regex_allowed = type == 'operator' && !HOP(UNARY_POSTFIX, value) || type == 'keyword' && HOP(KEYWORDS_BEFORE_EXPRESSION, value) || type == 'punc' && HOP(PUNC_BEFORE_EXPRESSION, value);\n      var ret = {\n        type: type,\n        value: value,\n        line: S.tokline,\n        col: S.tokcol,\n        pos: S.tokpos,\n        nlb: S.newline_before\n      };\n      S.newline_before = false;\n      return ret;\n    }\n\n    function skip_whitespace() {\n      while (HOP(WHITESPACE_CHARS, peek())) {\n        next();\n      }\n    }\n\n    function read_while(pred) {\n      var ret = '';\n      var ch = peek();\n      var i = 0;\n\n      while (ch && pred(ch, i++)) {\n        ret += next();\n        ch = peek();\n      }\n\n      return ret;\n    }\n\n    function parse_error(err) {\n      js_error(err, S.tokline, S.tokcol, S.tokpos);\n    }\n\n    function read_num(prefix) {\n      var has_e = false;\n      var after_e = false;\n      var has_x = false;\n      var num = read_while(function (ch, i) {\n        if (ch == 'x' || ch == 'X') {\n          if (has_x) return false;\n          return has_x = true;\n        }\n\n        if (!has_x && (ch == 'E' || ch == 'e')) {\n          if (has_e) return false;\n          return has_e = after_e = true;\n        }\n\n        if (ch == '-') {\n          if (after_e || i == 0 && !prefix) return true;\n          return false;\n        }\n\n        after_e = false;\n        return is_alphanumeric_char(ch) || ch == '.';\n      });\n\n      if (prefix) {\n        num = prefix + num;\n      }\n\n      var valid = parse_js_number(num);\n\n      if (!isNaN(valid)) {\n        return token('num', valid);\n      } else {\n        parse_error('Invalid syntax: ' + num);\n      }\n    }\n\n    function read_escaped_char() {\n      var ch = next(true);\n\n      switch (ch) {\n        case 'n':\n          return '\\n';\n\n        case 'r':\n          return '\\r';\n\n        case 't':\n          return '\\t';\n\n        case 'b':\n          return '\\b';\n\n        case 'v':\n          return '\\v';\n\n        case 'f':\n          return '\\f';\n\n        case '0':\n          return '\\0';\n\n        case 'x':\n          return String.fromCharCode(hex_bytes(2));\n\n        case 'u':\n          return String.fromCharCode(hex_bytes(4));\n\n        default:\n          return ch;\n      }\n    }\n\n    function hex_bytes(n) {\n      var num = 0;\n\n      for (; n > 0; --n) {\n        var digit = parseInt(next(true), 16);\n\n        if (isNaN(digit)) {\n          parse_error(\"Invalid hex-character pattern in string\");\n        }\n\n        num = num << 4 | digit;\n      }\n\n      return num;\n    }\n\n    function read_string() {\n      return with_eof_error('Unterminated string constant', function () {\n        var quote = next();\n        var ret = '';\n\n        for (;;) {\n          var ch = next(true);\n          if (ch == '\\\\') ch = read_escaped_char();else if (ch == quote) break;\n          ret += ch;\n        }\n\n        return token('string', ret);\n      });\n    }\n\n    function read_line_comment() {\n      next();\n      var i = find('\\n');\n      var ret;\n\n      if (i == -1) {\n        ret = S.text.substr(S.pos);\n        S.pos = S.text.length;\n      } else {\n        ret = S.text.substring(S.pos, i);\n        S.pos = i;\n      }\n\n      return token('comment1', ret);\n    }\n\n    function read_multiline_comment() {\n      next();\n      return with_eof_error('Unterminated multiline comment', function () {\n        var i = find('*/', true);\n        var text = S.text.substring(S.pos, i);\n        var tok = token('comment2', text);\n        S.pos = i + 2;\n        S.newline_before = text.indexOf('\\n') >= 0;\n        return tok;\n      });\n    }\n\n    function read_regexp() {\n      return with_eof_error('Unterminated regular expression', function () {\n        var prev_backslash = false;\n        var regexp = \"\";\n        var ch;\n        var in_class = false;\n\n        while (ch = next(true)) {\n          if (prev_backslash) {\n            regexp += \"\\\\\" + ch;\n            prev_backslash = false;\n          } else if (ch == \"[\") {\n            in_class = true;\n            regexp += ch;\n          } else if (ch == \"]\" && in_class) {\n            in_class = false;\n            regexp += ch;\n          } else if (ch == \"/\" && !in_class) {\n            break;\n          } else if (ch == \"\\\\\") {\n            prev_backslash = true;\n          } else {\n            regexp += ch;\n          }\n        }\n\n        var mods = read_while(function (ch) {\n          return HOP(REGEXP_MODIFIERS, ch);\n        });\n        return token('regexp', [regexp, mods]);\n      });\n    }\n\n    function read_operator(prefix) {\n      function grow(op) {\n        var bigger = op + peek();\n\n        if (HOP(OPERATORS, bigger)) {\n          next();\n          return grow(bigger);\n        }\n\n        return op;\n      }\n\n      ;\n      return token('operator', grow(prefix || next()));\n    }\n\n    var handle_slash = skip_comments ? function () {\n      next();\n\n      switch (peek()) {\n        case '/':\n          read_line_comment();\n          return next_token();\n\n        case '*':\n          read_multiline_comment();\n          return next_token();\n      }\n\n      return S.regex_allowed ? read_regexp() : read_operator('/');\n    } : function () {\n      next();\n\n      switch (peek()) {\n        case '/':\n          return read_line_comment();\n\n        case '*':\n          return read_multiline_comment();\n      }\n\n      return S.regex_allowed ? read_regexp() : read_operator('/');\n    };\n\n    function handle_dot() {\n      next();\n      return is_digit(peek()) ? read_num('.') : token('punc', '.');\n    }\n\n    function read_word() {\n      var word = read_while(is_identifier_char);\n      return !HOP(KEYWORDS, word) ? token('name', word) : HOP(OPERATORS, word) ? token('operator', word) : HOP(KEYWORDS_ATOM, word) ? token('atom', word) : token('keyword', word);\n    }\n\n    function with_eof_error(eof_error, cont) {\n      try {\n        return cont();\n      } catch (ex) {\n        if (ex === EX_EOF) parse_error(eof_error);else throw ex;\n      }\n    }\n\n    function next_token() {\n      skip_whitespace();\n      start_token();\n      var ch = peek();\n      if (!ch) return token('eof');\n      if (is_digit(ch)) return read_num();\n      if (ch == '\"' || ch == \"'\") return read_string();\n      if (HOP(PUNC_CHARS, ch)) return token('punc', next());\n      if (ch == '.') return handle_dot();\n      if (ch == '/') return handle_slash();\n      if (HOP(OPERATOR_CHARS, ch)) return read_operator();\n      if (is_identifier_char(ch)) return read_word();\n      parse_error(\"Unexpected character '\".concat(ch, \"'\"));\n    }\n\n    next_token.context = function (nc) {\n      if (nc) S = nc;\n      return S;\n    };\n\n    return next_token;\n  }\n  /* -----[ Parser (constants) ]----- */\n\n\n  var UNARY_PREFIX = array_to_hash(['typeof', 'void', 'delete', '--', '++', '!', '~', '-', '+']);\n  var UNARY_POSTFIX = array_to_hash(['--', '++']);\n\n  var ASSIGNMENT = function (a, ret, i) {\n    while (i < a.length) {\n      ret[a[i]] = a[i].substr(0, a[i].length - 1);\n      i++;\n    }\n\n    return ret;\n  }([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"~=\", \"%=\", \"|=\", \"^=\"], {\n    \"=\": true\n  }, 0);\n\n  var PRECEDENCE = function (a, ret) {\n    for (var i = 0, n = 1; i < a.length; ++i, ++n) {\n      var b = a[i];\n\n      for (var j = 0; j < b.length; ++j) {\n        ret[b[j]] = n;\n      }\n    }\n\n    return ret;\n  }([[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"]], {});\n\n  var STATEMENTS_WITH_LABELS = array_to_hash(['for', 'do', 'while', 'switch']);\n  var ATOMIC_START_TOKEN = array_to_hash(['atom', 'num', 'string', 'regexp', 'name']);\n  /* -----[ Parser ]----- */\n\n  function NodeWithToken(str, start, end) {\n    this.name = str;\n    this.start = start;\n    this.end = end;\n  }\n\n  NodeWithToken.prototype.toString = function () {\n    return this.name;\n  };\n\n  function parse($TEXT, strict_semicolons, embed_tokens) {\n    var S = {\n      input: tokenizer($TEXT, true),\n      token: null,\n      prev: null,\n      peeked: null,\n      in_function: 0,\n      in_loop: 0,\n      labels: []\n    };\n    S.token = next();\n\n    function is(type, value) {\n      return is_token(S.token, type, value);\n    }\n\n    function peek() {\n      return S.peeked || (S.peeked = S.input());\n    }\n\n    function next() {\n      S.prev = S.token;\n\n      if (S.peeked) {\n        S.token = S.peeked;\n        S.peeked = null;\n      } else {\n        S.token = S.input();\n      }\n\n      return S.token;\n    }\n\n    function prev() {\n      return S.prev;\n    }\n\n    function croak(msg, line, col, pos) {\n      var ctx = S.input.context();\n      js_error(msg, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos);\n    }\n\n    function token_error(token, msg) {\n      croak(msg, token.line, token.col);\n    }\n\n    function unexpected(token) {\n      if (token == null) {\n        token = S.token;\n      }\n\n      token_error(token, 'Unexpected token: ' + token.type + ' (' + token.value + ')');\n    }\n\n    function expect_token(type, val) {\n      if (is(type, val)) {\n        return next();\n      }\n\n      token_error(S.token, 'Unexpected token ' + S.token.type + ', expected ' + type);\n    }\n\n    function expect(punc) {\n      return expect_token('punc', punc);\n    }\n\n    function can_insert_semicolon() {\n      return !strict_semicolons && (S.token.nlb || is('eof') || is('punc', '}'));\n    }\n\n    function semicolon() {\n      if (is('punc', ';')) next();else if (!can_insert_semicolon()) unexpected();\n    }\n\n    function as() {\n      return slice(arguments);\n    }\n\n    function parenthesised() {\n      expect('(');\n      var ex = expression();\n      expect(')');\n      return ex;\n    }\n\n    function add_tokens(str, start, end) {\n      return new NodeWithToken(str, start, end);\n    }\n\n    var statement = embed_tokens ? function (allow_case) {\n      var start = S.token;\n      var stmt = $statement(allow_case);\n      stmt[0] = add_tokens(stmt[0], start, prev());\n      return stmt;\n    } : $statement;\n\n    function $statement(allow_case) {\n      switch (S.token.type) {\n        case 'num':\n        case 'string':\n        case 'regexp':\n        case 'operator':\n        case 'atom':\n          return simple_statement();\n\n        case 'name':\n          return is_token(peek(), 'punc', ':') ? labeled_statement(prog1(S.token.value, next, next)) : simple_statement();\n\n        case 'punc':\n          switch (S.token.value) {\n            case '{':\n              next();\n              return block();\n\n            case '[':\n            case '(':\n              return simple_statement();\n\n            case ';':\n              next();\n              return as('block');\n\n            default:\n              unexpected();\n          }\n\n        case 'keyword':\n          switch (prog1(S.token.value, next)) {\n            case 'break':\n              return break_cont('break');\n\n            case 'continue':\n              return break_cont('continue');\n\n            case 'case':\n              if (!allow_case) {\n                unexpected();\n              }\n\n              return as('case', prog1(expression, curry(expect, ':')));\n\n            case 'debugger':\n              semicolon();\n              return as('debugger');\n\n            case 'default':\n              if (!allow_case) {\n                unexpected();\n              }\n\n              expect(':');\n              return as('default');\n\n            case 'do':\n              return function (body) {\n                expect_token('keyword', 'while');\n                return as('do', prog1(parenthesised, semicolon), body);\n              }(in_loop(statement));\n\n            case 'for':\n              return for_();\n\n            case 'function':\n              return function_(true);\n\n            case 'if':\n              return if_();\n\n            case 'return':\n              if (S.in_function == 0) {\n                croak(\"'return' outside of function\");\n              }\n\n              return as('return', is('punc', ';') ? (next(), null) : can_insert_semicolon() ? null : prog1(expression, semicolon));\n\n            case 'switch':\n              return as('switch', parenthesised(), in_loop(curry(block_, true)));\n\n            case 'throw':\n              return as('throw', prog1(expression, semicolon));\n\n            case 'try':\n              return try_();\n\n            case 'var':\n              return prog1(var_, semicolon);\n\n            case 'const':\n              return prog1(const_, semicolon);\n\n            case 'while':\n              return as('while', parenthesised(), in_loop(statement));\n\n            case 'with':\n              return as('with', parenthesised(), statement());\n\n            default:\n              unexpected();\n          }\n\n      }\n    }\n\n    function labeled_statement(label) {\n      S.labels.push(label);\n      var start = S.token;\n      var stat = statement();\n\n      if (!HOP(STATEMENTS_WITH_LABELS, stat[0])) {\n        unexpected(start);\n      }\n\n      S.labels.pop();\n      return as('label', label, stat);\n    }\n\n    function simple_statement() {\n      return as('stat', prog1(expression, semicolon));\n    }\n\n    function break_cont(type) {\n      if (S.in_loop == 0) {\n        croak(type + \" not inside a loop or switch\");\n      }\n\n      var name = is('name') ? S.token.value : null;\n\n      if (name != null) {\n        next();\n\n        if (!member(name, S.labels)) {\n          croak(\"Label \" + name + \" without matching loop or statement\");\n        }\n      }\n\n      semicolon();\n      return as(type, name);\n    }\n\n    function block() {\n      var a = [];\n\n      while (!is('punc', '}')) {\n        a.push(statement());\n      }\n\n      next();\n      return as('block', a);\n    }\n\n    function for_() {\n      expect('(');\n      var has_var = is('keyword', 'var');\n\n      if (has_var) {\n        next();\n      }\n\n      if (is('name') && is_token(peek(), 'operator', 'in')) {\n        // for (i in foo)\n        var name = S.token.value;\n        next();\n        next();\n        var obj = expression();\n        expect(')');\n        return as('for-in', has_var, name, obj, in_loop(statement));\n      } else {\n        // classic for\n        var init = is('punc', ';') ? null : has_var ? var_() : expression();\n        expect(';');\n        var test = is('punc', ';') ? null : expression();\n        expect(';');\n        var step = is('punc', ')') ? null : expression();\n        expect(')');\n        return as('for', init, test, step, in_loop(statement));\n      }\n    }\n\n    function function_(in_statement) {\n      var name = is('name') ? prog1(S.token.value, next) : null;\n\n      if (in_statement && !name) {\n        unexpected();\n      }\n\n      expect('(');\n      return as(in_statement ? 'defun' : 'function', name, // arguments\n      function (first, a) {\n        while (!is('punc', ')')) {\n          if (first) first = false;else expect(',');\n          if (!is('name')) unexpected();\n          a.push(S.token.value);\n          next();\n        }\n\n        next();\n        return a;\n      }(true, []), // body\n      function () {\n        ++S.in_function;\n        var a = block_();\n        --S.in_function;\n        return a;\n      }());\n    }\n\n    function if_() {\n      var cond = parenthesised();\n      var body = statement();\n      var belse;\n\n      if (is('keyword', 'else')) {\n        next();\n        belse = statement();\n      }\n\n      return as('if', cond, body, belse);\n    }\n\n    function block_(allow_case) {\n      expect('{');\n      var a = [];\n\n      while (!is('punc', '}')) {\n        a.push(statement(allow_case));\n      }\n\n      next();\n      return a;\n    }\n\n    function try_() {\n      var body = block_();\n      var bcatch;\n      var bfinally;\n\n      if (is('keyword', 'catch')) {\n        next();\n        expect('(');\n\n        if (!is('name')) {\n          croak(\"Name expected\");\n        }\n\n        var name = S.token.value;\n        next();\n        expect(')');\n        bcatch = [name, block_()];\n      }\n\n      if (is('keyword', 'finally')) {\n        next();\n        bfinally = block_();\n      }\n\n      return as('try', body, bcatch, bfinally);\n    }\n\n    function vardefs() {\n      var a = [];\n\n      for (;;) {\n        if (!is('name')) {\n          unexpected();\n        }\n\n        var name = S.token.value;\n        next();\n\n        if (is('operator', '=')) {\n          next();\n          a.push([name, expression(false)]);\n        } else {\n          a.push([name]);\n        }\n\n        if (!is('punc', ',')) {\n          break;\n        }\n\n        next();\n      }\n\n      return a;\n    }\n\n    function var_() {\n      return as('var', vardefs());\n    }\n\n    function const_() {\n      return as('const', vardefs());\n    }\n\n    function new_() {\n      var newexp = expr_atom(false);\n      var args;\n\n      if (is('punc', '(')) {\n        next();\n        args = expr_list(')');\n      } else {\n        args = [];\n      }\n\n      return subscripts(as('new', newexp, args), true);\n    }\n\n    function expr_atom(allow_calls) {\n      if (is('operator', 'new')) {\n        next();\n        return new_();\n      }\n\n      if (is('operator') && HOP(UNARY_PREFIX, S.token.value)) {\n        return make_unary('unary-prefix', prog1(S.token.value, next), expr_atom(allow_calls));\n      }\n\n      if (is('punc')) {\n        switch (S.token.value) {\n          case '(':\n            next();\n            return subscripts(prog1(expression, curry(expect, ')')), allow_calls);\n\n          case '[':\n            next();\n            return subscripts(array_(), allow_calls);\n\n          case '{':\n            next();\n            return subscripts(object_(), allow_calls);\n        }\n\n        unexpected();\n      }\n\n      if (is('keyword', 'function')) {\n        next();\n        return subscripts(function_(false), allow_calls);\n      }\n\n      if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\n        var atom = S.token.type == 'regexp' ? as('regexp', S.token.value[0], S.token.value[1]) : as(S.token.type, S.token.value);\n        return subscripts(prog1(atom, next), allow_calls);\n      }\n\n      unexpected();\n    }\n\n    function expr_list(closing, allow_trailing_comma) {\n      var first = true;\n      var a = [];\n\n      while (!is('punc', closing)) {\n        if (first) first = false;else expect(',');\n\n        if (allow_trailing_comma && is('punc', closing)) {\n          break;\n        }\n\n        a.push(expression(false));\n      }\n\n      next();\n      return a;\n    }\n\n    function array_() {\n      return as('array', expr_list(']', !strict_semicolons));\n    }\n\n    function object_() {\n      var first = true;\n      var a = [];\n\n      while (!is('punc', '}')) {\n        if (first) first = false;else expect(',');\n\n        if (!strict_semicolons && is('punc', '}')) // allow trailing comma\n          {\n            break;\n          }\n\n        var name = as_property_name();\n        expect(':');\n        var value = expression(false);\n        a.push([name, value]);\n      }\n\n      next();\n      return as('object', a);\n    }\n\n    function as_property_name() {\n      switch (S.token.type) {\n        case 'num':\n        case 'string':\n          return prog1(S.token.value, next);\n      }\n\n      return as_name();\n    }\n\n    function as_name() {\n      switch (S.token.type) {\n        case 'name':\n        case 'operator':\n        case 'keyword':\n        case 'atom':\n          return prog1(S.token.value, next);\n\n        default:\n          unexpected();\n      }\n    }\n\n    function subscripts(expr, allow_calls) {\n      if (is('punc', '.')) {\n        next();\n        return subscripts(as('dot', expr, as_name()), allow_calls);\n      }\n\n      if (is('punc', '[')) {\n        next();\n        return subscripts(as('sub', expr, prog1(expression, curry(expect, ']'))), allow_calls);\n      }\n\n      if (allow_calls && is('punc', '(')) {\n        next();\n        return subscripts(as('call', expr, expr_list(')')), true);\n      }\n\n      if (allow_calls && is('operator') && HOP(UNARY_POSTFIX, S.token.value)) {\n        return prog1(curry(make_unary, 'unary-postfix', S.token.value, expr), next);\n      }\n\n      return expr;\n    }\n\n    function make_unary(tag, op, expr) {\n      if ((op == '++' || op == '--') && !is_assignable(expr)) {\n        croak(\"Invalid use of \" + op + \" operator\");\n      }\n\n      return as(tag, op, expr);\n    }\n\n    function expr_op(left, min_prec) {\n      var op = is('operator') ? S.token.value : null;\n      var prec = op != null ? PRECEDENCE[op] : null;\n\n      if (prec != null && prec > min_prec) {\n        next();\n        var right = expr_op(expr_atom(true), prec);\n        return expr_op(as('binary', op, left, right), min_prec);\n      }\n\n      return left;\n    }\n\n    function expr_ops() {\n      return expr_op(expr_atom(true), 0);\n    }\n\n    function maybe_conditional(commas) {\n      if (arguments.length == 0) {\n        commas = true;\n      }\n\n      var expr = expr_ops();\n\n      if (is('operator', '?')) {\n        next();\n        var yes = expression();\n        expect(':');\n        return as('conditional', expr, yes, expression(commas));\n      }\n\n      return expr;\n    }\n\n    function is_assignable(expr) {\n      expr = expr[0];\n      return expr == 'name' || expr == 'dot' || expr == 'sub';\n    }\n\n    function maybe_assign(commas) {\n      if (arguments.length == 0) {\n        commas = true;\n      }\n\n      var left = maybe_conditional(commas);\n      var val = S.token.value;\n\n      if (is('operator') && HOP(ASSIGNMENT, val)) {\n        if (is_assignable(left)) {\n          next();\n          return as('assign', ASSIGNMENT[val], left, maybe_assign(commas));\n        }\n\n        croak('Invalid assignment');\n      }\n\n      return left;\n    }\n\n    function expression(commas) {\n      if (arguments.length == 0) {\n        commas = true;\n      }\n\n      var expr = maybe_assign(commas);\n\n      if (commas && is('punc', ',')) {\n        next();\n        return as('seq', expr, expression());\n      }\n\n      return expr;\n    }\n\n    function in_loop(cont) {\n      try {\n        ++S.in_loop;\n        return cont();\n      } finally {\n        --S.in_loop;\n      }\n    }\n\n    return as('toplevel', function (a) {\n      while (!is('eof')) {\n        a.push(statement());\n      }\n\n      return a;\n    }([]));\n  }\n  /* -----[ Utilities ]----- */\n\n\n  function curry(f) {\n    var args = slice(arguments, 1);\n    return function () {\n      return f.apply(this, args.concat(slice(arguments)));\n    };\n  }\n\n  function prog1(ret) {\n    if (ret instanceof Function) {\n      ret = ret();\n    }\n\n    for (var i = 1, n = arguments.length; --n > 0; ++i) {\n      arguments[i]();\n    }\n\n    return ret;\n  }\n\n  function array_to_hash(a) {\n    var ret = {};\n\n    for (var i = 0; i < a.length; ++i) {\n      ret[a[i]] = true;\n    }\n\n    return ret;\n  }\n\n  function slice(a, start) {\n    return Array.prototype.slice.call(a, start == null ? 0 : start);\n  }\n\n  function characters(str) {\n    return str.split('');\n  }\n\n  function member(name, array) {\n    for (var i = array.length; --i >= 0;) {\n      if (array[i] === name) return true;\n    }\n\n    return false;\n  }\n\n  function HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  /* -----[ Exports ]----- */\n\n\n  exports.tokenizer = tokenizer;\n  exports.parse = parse;\n  exports.slice = slice;\n  exports.curry = curry;\n  exports.member = member;\n  exports.array_to_hash = array_to_hash;\n  exports.PRECEDENCE = PRECEDENCE;\n  exports.KEYWORDS_ATOM = KEYWORDS_ATOM;\n  exports.RESERVED_WORDS = RESERVED_WORDS;\n  exports.KEYWORDS = KEYWORDS;\n  exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\n  exports.is_alphanumeric_char = is_alphanumeric_char; // end module: kaffeine/uglify/parse-js.js\n});\n\nrequire.register('kaffeine/uglify/process.js', function (module, exports, require) {\n  // start module: kaffeine/uglify/process.js\n\n  /***********************************************************************\n   A JavaScript tokenizer / parser / beautifier / compressor.\n   This version is suitable for Node.js.  With minimal changes (the\n  exports stuff) it should work on any JS platform.\n   This file implements some AST processors.  They work on data built\n  by parse-js.\n   Exported functions:\n     - ast_mangle(ast, include_toplevel) -- mangles the\n      variable/function names in the AST.  Returns an AST.  Pass true\n      as second argument to mangle toplevel names too.\n     - ast_squeeze(ast) -- employs various optimizations to make the\n      final generated code even smaller.  Returns an AST.\n     - gen_code(ast, beautify) -- generates JS code from the AST.  Pass\n      true (or an object, see the code for some options) as second\n      argument to get \"pretty\" (indented) code.\n   -------------------------------- (C) ---------------------------------\n                            Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n   Distributed under a ZLIB license:\n     Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\n     This software is provided 'as-is', without any express or implied\n    warranty. In no event will the authors be held liable for any\n    damages arising from the use of this software.\n     Permission is granted to anyone to use this software for any\n    purpose, including commercial applications, and to alter it and\n    redistribute it freely, subject to the following restrictions:\n     1. The origin of this software must not be misrepresented; you must\n       not claim that you wrote the original software. If you use this\n       software in a product, an acknowledgment in the product\n       documentation would be appreciated but is not required.\n     2. Altered source versions must be plainly marked as such, and must\n       not be misrepresented as being the original software.\n     3. This notice may not be removed or altered from any source\n       distribution.\n  ********************************************************************** */\n  var jsp = require(\"./parse-js\");\n\n  var slice = jsp.slice;\n  var member = jsp.member;\n  var PRECEDENCE = jsp.PRECEDENCE;\n  /* -----[ helper for AST traversal ]----- */\n\n  function ast_walker(ast) {\n    function _vardefs(defs) {\n      return defs.map(function (def) {\n        var a = [def[0]];\n\n        if (def.length > 1) {\n          a[1] = walk(def[1]);\n        }\n\n        return a;\n      });\n    }\n\n    var walkers = {\n      string: function string(str) {\n        return ['string', str];\n      },\n      num: function num(_num) {\n        return ['num', _num];\n      },\n      name: function name(_name) {\n        return ['name', _name];\n      },\n      toplevel: function toplevel(statements) {\n        return ['toplevel', statements.map(walk)];\n      },\n      block: function block(statements) {\n        var out = ['block'];\n\n        if (statements != null) {\n          out.push(statements.map(walk));\n        }\n\n        return out;\n      },\n      \"var\": function _var(defs) {\n        return ['var', _vardefs(defs)];\n      },\n      \"const\": function _const(defs) {\n        return ['const', _vardefs(defs)];\n      },\n      \"try\": function _try(t, c, f) {\n        return ['try', t.map(walk), c != null ? [c[0], c[1].map(walk)] : null, f != null ? f.map(walk) : null];\n      },\n      \"throw\": function _throw(expr) {\n        return ['throw', walk(expr)];\n      },\n      \"new\": function _new(ctor, args) {\n        return ['new', walk(ctor), args.map(walk)];\n      },\n      \"switch\": function _switch(expr, body) {\n        return ['switch', walk(expr), body.map(walk)];\n      },\n      \"case\": function _case(expr) {\n        return ['case', walk(expr)];\n      },\n      \"default\": function _default() {\n        return ['default'];\n      },\n      \"break\": function _break(label) {\n        return ['break', label];\n      },\n      \"continue\": function _continue(label) {\n        return ['continue', label];\n      },\n      conditional: function conditional(cond, t, e) {\n        return ['conditional', walk(cond), walk(t), walk(e)];\n      },\n      assign: function assign(op, lvalue, rvalue) {\n        return ['assign', op, walk(lvalue), walk(rvalue)];\n      },\n      dot: function dot(expr) {\n        return ['dot', walk(expr)].concat(slice(arguments, 1));\n      },\n      call: function call(expr, args) {\n        return ['call', walk(expr), args.map(walk)];\n      },\n      \"function\": function _function(name, args, body) {\n        return ['function', name, args.slice(), body.map(walk)];\n      },\n      defun: function defun(name, args, body) {\n        return ['defun', name, args.slice(), body.map(walk)];\n      },\n      \"if\": function _if(conditional, t, e) {\n        return ['if', walk(conditional), walk(t), walk(e)];\n      },\n      \"for\": function _for(init, cond, step, block) {\n        return ['for', walk(init), walk(cond), walk(step), walk(block)];\n      },\n      'for-in': function forIn(has_var, key, hash, block) {\n        return ['for-in', has_var, key, walk(hash), walk(block)];\n      },\n      \"while\": function _while(cond, block) {\n        return ['while', walk(cond), walk(block)];\n      },\n      \"do\": function _do(cond, block) {\n        return ['do', walk(cond), walk(block)];\n      },\n      \"return\": function _return(expr) {\n        return ['return', walk(expr)];\n      },\n      binary: function binary(op, left, right) {\n        return ['binary', op, walk(left), walk(right)];\n      },\n      'unary-prefix': function unaryPrefix(op, expr) {\n        return ['unary-prefix', op, walk(expr)];\n      },\n      'unary-postfix': function unaryPostfix(op, expr) {\n        return ['unary-postfix', op, walk(expr)];\n      },\n      sub: function sub(expr, subscript) {\n        return ['sub', walk(expr), walk(subscript)];\n      },\n      object: function object(props) {\n        return ['object', props.map(function (p) {\n          return [p[0], walk(p[1])];\n        })];\n      },\n      regexp: function regexp(rx, mods) {\n        return ['regexp', rx, mods];\n      },\n      array: function array(elements) {\n        return ['array', elements.map(walk)];\n      },\n      stat: function stat(_stat) {\n        return ['stat', walk(_stat)];\n      },\n      seq: function seq() {\n        return ['seq'].concat(slice(arguments).map(walk));\n      },\n      label: function label(name, block) {\n        return ['label', name, walk(block)];\n      },\n      \"with\": function _with(expr, block) {\n        return ['with', walk(expr), walk(block)];\n      },\n      atom: function atom(name) {\n        return ['atom', name];\n      }\n    };\n    var user = {};\n    var _stack = [];\n\n    function walk(ast) {\n      if (ast == null) {\n        return null;\n      }\n\n      try {\n        _stack.push(ast);\n\n        var type = ast[0];\n        var gen = user[type];\n\n        if (gen) {\n          var _ret2 = gen.apply(ast, ast.slice(1));\n\n          if (_ret2 != null) {\n            return _ret2;\n          }\n        }\n\n        gen = walkers[type];\n        return gen.apply(ast, ast.slice(1));\n      } finally {\n        _stack.pop();\n      }\n    }\n\n    function with_walkers(walkers, cont) {\n      var save = {};\n      var i;\n\n      for (i in walkers) {\n        if (HOP(walkers, i)) {\n          save[i] = user[i];\n          user[i] = walkers[i];\n        }\n      }\n\n      try {\n        return cont();\n      } finally {\n        for (i in save) {\n          if (HOP(save, i)) {\n            if (!save[i]) delete user[i];else user[i] = save[i];\n          }\n        }\n      }\n    }\n\n    return {\n      walk: walk,\n      with_walkers: with_walkers,\n      parent: function parent() {\n        return _stack[_stack.length - 2]; // last one is current node\n      },\n      stack: function stack() {\n        return _stack;\n      }\n    };\n  }\n  /* -----[ Scope and mangling ]----- */\n\n\n  function Scope(parent) {\n    this.names = {}; // names defined in this scope\n\n    this.mangled = {}; // mangled names (orig.name => mangled)\n\n    this.rev_mangled = {}; // reverse lookup (mangled => orig.name)\n\n    this.cname = -1; // current mangled name\n\n    this.refs = {}; // names referenced from this scope\n\n    this.uses_with = false; // will become TRUE if eval() is detected in this or any subscopes\n\n    this.uses_eval = false; // will become TRUE if with() is detected in this or any subscopes\n\n    this.parent = parent; // parent scope\n\n    this.children = []; // sub-scopes\n\n    if (parent) {\n      this.level = parent.level + 1;\n      parent.children.push(this);\n    } else {\n      this.level = 0;\n    }\n  }\n\n  var base54 = function () {\n    var DIGITS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';\n    return function (num) {\n      var ret = '';\n\n      do {\n        ret = DIGITS.charAt(num % 54) + ret;\n        num = Math.floor(num / 54);\n      } while (num > 0);\n\n      return ret;\n    };\n  }();\n\n  Scope.prototype = {\n    has: function has(name) {\n      for (var s = this; s; s = s.parent) {\n        if (HOP(s.names, name)) return s;\n      }\n    },\n    has_mangled: function has_mangled(mname) {\n      for (var s = this; s; s = s.parent) {\n        if (HOP(s.rev_mangled, mname)) return s;\n      }\n    },\n    toJSON: function toJSON() {\n      return {\n        names: this.names,\n        uses_eval: this.uses_eval,\n        uses_with: this.uses_with\n      };\n    },\n    next_mangled: function next_mangled() {\n      // we must be careful that the new mangled name:\n      //\n      // 1. doesn't shadow a mangled name from a parent\n      //    scope, unless we don't reference the original\n      //    name from this scope OR from any sub-scopes!\n      //    This will get slow.\n      //\n      // 2. doesn't shadow an original name from a parent\n      //    scope, in the event that the parent scope\n      //    doesn't support mangling (uses_eval or\n      //    uses_with) and we reference that name here OR IN\n      //    ANY SUBSCOPES!  Damn!\n      //\n      // 3. doesn't shadow a name that is referenced but not\n      //    defined (possibly global defined elsewhere).\n      for (;;) {\n        var m = base54(++this.cname),\n            prior; // case 1.\n\n        prior = this.has_mangled(m);\n        if (prior && this.refs[prior.rev_mangled[m]] === prior) continue; // case 2.\n\n        prior = this.has(m);\n        if (prior && (prior.uses_eval || prior.uses_with) && this.refs[m] === prior) continue; // case 3.\n\n        if (HOP(this.refs, m) && this.refs[m] == null) continue; // I got \"do\" once. :-/\n\n        if (!is_identifier(m)) continue;\n        return m;\n      }\n    },\n    get_mangled: function get_mangled(name, newMangle) {\n      if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use\n\n      var s = this.has(name);\n      if (!s) return name; // not in visible scope, no mangle\n\n      if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope\n\n      if (!newMangle) return name; // not found and no mangling requested\n\n      var m = s.next_mangled();\n      s.rev_mangled[m] = name;\n      return s.mangled[name] = m;\n    },\n    define: function define(name) {\n      if (name != null) return this.names[name] = name;\n    }\n  };\n\n  function ast_add_scope(ast) {\n    var current_scope = null;\n    var w = ast_walker();\n    var walk = w.walk;\n    var having_eval = [];\n\n    function with_new_scope(cont) {\n      current_scope = new Scope(current_scope);\n\n      try {\n        var _ret3 = current_scope.body = cont();\n\n        _ret3.scope = current_scope;\n        return _ret3;\n      } finally {\n        current_scope = current_scope.parent;\n      }\n    }\n\n    function define(name) {\n      return current_scope.define(name);\n    }\n\n    function reference(name) {\n      current_scope.refs[name] = true;\n    }\n\n    function _lambda(name, args, body) {\n      return [this[0], define(name), args, with_new_scope(function () {\n        args.map(define);\n        return body.map(walk);\n      })];\n    }\n\n    return with_new_scope(function () {\n      // process AST\n      var ret = w.with_walkers({\n        \"function\": _lambda,\n        defun: _lambda,\n        \"with\": function _with(expr, block) {\n          for (var s = current_scope; s; s = s.parent) {\n            s.uses_with = true;\n          }\n        },\n        \"var\": function _var(defs) {\n          defs.map(function (d) {\n            define(d[0]);\n          });\n        },\n        \"const\": function _const(defs) {\n          defs.map(function (d) {\n            define(d[0]);\n          });\n        },\n        \"try\": function _try(t, c, f) {\n          if (c != null) {\n            return [\"try\", t.map(walk), with_new_scope(function () {\n              return [define(c[0]), c[1].map(walk)];\n            }), f != null ? f.map(walk) : null];\n          }\n        },\n        name: function name(_name2) {\n          if (_name2 == 'eval') {\n            having_eval.push(current_scope);\n          }\n\n          reference(_name2);\n        },\n        'for-in': function forIn(has_var, name) {\n          if (has_var) define(name);\n        }\n      }, function () {\n        return walk(ast);\n      }); // the reason why we need an additional pass here is\n      // that names can be used prior to their definition.\n      // scopes where eval was detected and their parents\n      // are marked with uses_eval, unless they define the\n      // \"eval\" name.\n\n      having_eval.map(function (scope) {\n        if (!scope.has('eval')) {\n          while (scope) {\n            scope.uses_eval = true;\n            scope = scope.parent;\n          }\n        }\n      }); // for referenced names it might be useful to know\n      // their origin scope.  current_scope here is the\n      // toplevel one.\n\n      function fixrefs(scope, i) {\n        // do children first; order shouldn't matter\n        for (i = scope.children.length; --i >= 0;) {\n          fixrefs(scope.children[i]);\n        }\n\n        for (i in scope.refs) {\n          if (HOP(scope.refs, i)) {\n            // find origin scope and propagate the reference to origin\n            for (var origin = scope.has(i), s = scope; s; s = s.parent) {\n              s.refs[i] = origin;\n              if (s === origin) break;\n            }\n          }\n        }\n      }\n\n      fixrefs(current_scope);\n      return ret;\n    });\n  }\n  /* -----[ mangle names ]----- */\n\n\n  function ast_mangle(ast, do_toplevel) {\n    var w = ast_walker();\n    var walk = w.walk;\n    var scope;\n\n    function get_mangled(name, newMangle) {\n      if (!do_toplevel && !scope.parent) return name; // don't mangle toplevel\n\n      return scope.get_mangled(name, newMangle);\n    }\n\n    function _lambda(name, args, body) {\n      if (name) name = get_mangled(name);\n      body = with_scope(body.scope, function () {\n        args = args.map(function (name) {\n          return get_mangled(name);\n        });\n        return body.map(walk);\n      });\n      return [this[0], name, args, body];\n    }\n\n    function with_scope(s, cont) {\n      var _scope = scope;\n      scope = s;\n\n      for (var i in s.names) {\n        if (HOP(s.names, i)) {\n          get_mangled(i, true);\n        }\n      }\n\n      try {\n        var _ret4 = cont();\n\n        _ret4.scope = s;\n        return _ret4;\n      } finally {\n        scope = _scope;\n      }\n    }\n\n    ;\n\n    function _vardefs(defs) {\n      return defs.map(function (d) {\n        return [get_mangled(d[0]), walk(d[1])];\n      });\n    }\n\n    return w.with_walkers({\n      \"function\": _lambda,\n      defun: _lambda,\n      \"var\": function _var(defs) {\n        return ['var', _vardefs(defs)];\n      },\n      \"const\": function _const(defs) {\n        return ['const', _vardefs(defs)];\n      },\n      name: function name(_name3) {\n        return ['name', get_mangled(_name3)];\n      },\n      \"try\": function _try(t, c, f) {\n        return ['try', t.map(walk), c ? with_scope(c.scope, function () {\n          return [get_mangled(c[0]), c[1].map(walk)];\n        }) : null, f != null ? f.map(walk) : null];\n      },\n      toplevel: function toplevel(body) {\n        return with_scope(this.scope, function () {\n          return ['toplevel', body.map(walk)];\n        });\n      },\n      'for-in': function forIn(has_var, name, obj, stat) {\n        return ['for-in', has_var, get_mangled(name), walk(obj), walk(stat)];\n      }\n    }, function () {\n      return walk(ast_add_scope(ast));\n    });\n  } // function ast_has_side_effects(ast) {\n  //         var w = ast_walker();\n  //         var FOUND_SIDE_EFFECTS = {};\n  //         function _found() { throw FOUND_SIDE_EFFECTS };\n  //         try {\n  //                 w.with_walkers({\n  //                         \"new\": _found,\n  //                         \"call\": _found,\n  //                         \"assign\": _found,\n  //                         \"defun\": _found,\n  //                         \"var\": _found,\n  //                         \"const\": _found,\n  //                         \"throw\": _found,\n  //                         \"return\": _found,\n  //                         \"break\": _found,\n  //                         \"continue\": _found,\n  //                         \"case\": _found,\n  //                         \"default\": _found,\n  //                         \"label\": _found,\n  //                         \"function\": function(name) {\n  //                                 if (name) _found();\n  //                         }\n  //                 }, function(){\n  //                         w.walk(ast);\n  //                 });\n  //         } catch(ex) {\n  //                 if (ex === FOUND_SIDE_EFFECTS)\n  //                         return true;\n  //                 throw ex;\n  //         }\n  // };\n\n  /* -----[\n     - compress foo[\"bar\"] into foo.bar,\n     - remove block brackets {} where possible\n     - join consecutive var declarations\n     - various optimizations for IFs:\n       - if (cond) foo(); else bar();  ==>  cond?foo():bar();\n       - if (cond) foo();  ==>  cond&&foo();\n       - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw\n       - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}\n     ]----- */\n\n\n  function ast_squeeze(ast, options) {\n    options = defaults(options, {\n      make_seqs: true\n    });\n    var w = ast_walker();\n    var walk = w.walk;\n\n    function is_constant(node) {\n      return node[0] == 'string' || node[0] == 'num';\n    }\n\n    function rmblock(block) {\n      if (block != null && block[0] == 'block' && block[1] && block[1].length == 1) {\n        block = block[1][0];\n      }\n\n      return block;\n    }\n\n    function _lambda(name, args, body) {\n      return [this[0], name, args, tighten(body.map(walk))];\n    } // we get here for blocks that have been already transformed.\n    // this function does two things:\n    // 1. discard useless blocks\n    // 2. join consecutive var declarations\n\n\n    function tighten(statements) {\n      var cur;\n      var prev;\n\n      for (var i = 0, ret1 = []; i < statements.length; ++i) {\n        cur = statements[i];\n\n        if (cur[0] == 'block') {\n          if (cur[1]) {\n            ret1.push.apply(ret1, cur[1]);\n          }\n        } else {\n          ret1.push(cur);\n        }\n      }\n\n      prev = null;\n\n      for (var i = 0, ret2 = []; i < ret1.length; ++i) {\n        cur = ret1[i];\n\n        if (prev && (cur[0] == 'var' && prev[0] == 'var' || cur[0] == 'const' && prev[0] == 'const')) {\n          prev[1] = prev[1].concat(cur[1]);\n        } else {\n          ret2.push(cur);\n          prev = cur;\n        }\n      }\n\n      if (!options.make_seqs) {\n        return ret2;\n      }\n\n      prev = null;\n\n      for (var i = 0, ret3 = []; i < ret2.length; ++i) {\n        cur = ret2[i];\n\n        if (!prev) {\n          if (cur[0] == 'stat') {\n            prev = ['seq', cur[1]];\n            ret3.push(['stat', prev]);\n          } else {\n            ret3.push(cur);\n          }\n        } else if (cur[0] == 'stat') {\n          prev.push(cur[1]);\n        } else if (cur[0] == 'seq') {\n          prev.push.apply(prev, slice(cur, 1));\n        } else {\n          prev = null;\n          ret3.push(cur);\n        }\n      }\n\n      return ret3.map(walk);\n    }\n\n    function best_of(ast1, ast2) {\n      return gen_code(ast1).length > gen_code(ast2[0] == 'stat' ? ast2[1] : ast2).length ? ast2 : ast1;\n    }\n\n    function aborts(t) {\n      if (t[0] == 'block' && t[1] && t[1].length > 0) {\n        t = t[1][t[1].length - 1];\n      } // interested in last statement\n\n\n      if (t[0] == 'return' || t[0] == 'break' || t[0] == 'continue' || t[0] == 'throw') {\n        return true;\n      }\n    }\n\n    function make_conditional(c, t, e) {\n      if (c[0] == 'unary-prefix' && c[1] == '!') {\n        return e ? ['conditional', c[2], e, t] : ['binary', '||', c[2], t];\n      } else {\n        return e ? ['conditional', c, t, e] : ['binary', '&&', c, t];\n      }\n    }\n\n    function empty(b) {\n      return !b || b[0] == 'block' && (!b[1] || b[1].length == 0);\n    }\n\n    return w.with_walkers({\n      sub: function sub(expr, subscript) {\n        if (subscript[0] == 'string') {\n          var name = subscript[1];\n\n          if (is_identifier(name)) {\n            return ['dot', walk(expr), name];\n          }\n        }\n      },\n      \"if\": function _if(c, t, e) {\n        c = walk(c);\n        t = walk(t);\n        e = walk(e);\n        var negated = c[0] == 'unary-prefix' && c[1] == '!';\n\n        if (empty(t)) {\n          if (negated) c = c[2];else c = ['unary-prefix', '!', c];\n          t = e;\n          e = null;\n        }\n\n        if (empty(e)) {\n          e = null;\n        } else if (negated) {\n          c = c[2];\n          var tmp = t;\n          t = e;\n          e = tmp;\n        }\n\n        if (empty(e) && empty(t)) {\n          return [\"stat\", c];\n        }\n\n        var ret = ['if', c, t, e];\n\n        if (t[0] == 'stat') {\n          if (e) {\n            if (e[0] == 'stat') {\n              ret = best_of(ret, ['stat', make_conditional(c, t[1], e[1])]);\n            }\n          } else {\n            ret = best_of(ret, ['stat', make_conditional(c, t[1])]);\n          }\n        } else if (e && t[0] == e[0] && (t[0] == 'return' || t[0] == 'throw')) {\n          ret = best_of(ret, [t[0], make_conditional(c, t[1], e[1])]);\n        } else if (e && aborts(t)) {\n          ret = [['if', c, t]];\n\n          if (e[0] == 'block') {\n            if (e[1]) ret = ret.concat(e[1]);\n          } else {\n            ret.push(e);\n          }\n\n          ret = ['block', ret];\n        }\n\n        return ret;\n      },\n      toplevel: function toplevel(body) {\n        return ['toplevel', tighten(body.map(walk))];\n      },\n      \"switch\": function _switch(expr, body) {\n        return ['switch', walk(expr), tighten(body.map(walk))];\n      },\n      \"function\": _lambda,\n      defun: _lambda,\n      block: function block(body) {\n        if (body) return rmblock(['block', tighten(body.map(walk))]);\n      },\n      binary: function binary(op, left, right) {\n        left = walk(left);\n        right = walk(right);\n        var best = ['binary', op, left, right];\n\n        if (is_constant(left) && is_constant(right)) {\n          var val = null;\n\n          switch (op) {\n            case '+':\n              val = left[1] + right[1];\n              break;\n\n            case '*':\n              val = left[1] * right[1];\n              break;\n\n            case '/':\n              val = left[1] / right[1];\n              break;\n\n            case '-':\n              val = left[1] - right[1];\n              break;\n          }\n\n          if (val != null) {\n            best = best_of(best, [typeof val === 'string' ? 'string' : 'num', val]);\n          }\n        }\n\n        return best;\n      },\n      conditional: function conditional(c, t, e) {\n        if (c[0] == 'unary-prefix' && c[1] == '!') {\n          return [\"conditional\", walk(c[2]), walk(e), walk(t)];\n        }\n      },\n      seq: function seq() {\n        if (arguments.length == 1) {\n          return walk(arguments[0]);\n        }\n      }\n    }, function () {\n      return walk(ast);\n    });\n  }\n  /* -----[ re-generate code from the AST ]----- */\n\n\n  var DOT_CALL_NO_PARENS = jsp.array_to_hash(['name', 'array', 'string', 'dot', 'sub', 'call', 'regexp']);\n\n  function gen_code(ast, beautify) {\n    if (beautify) {\n      beautify = defaults(beautify, {\n        indent_start: 0,\n        indent_level: 4,\n        quote_keys: false,\n        space_colon: false\n      });\n    }\n\n    var indentation = 0;\n    var newline = beautify ? \"\\n\" : \"\";\n    var space = beautify ? ' ' : '';\n\n    function indent(line) {\n      if (line == null) {\n        line = \"\";\n      }\n\n      if (beautify) {\n        line = repeat_string(\" \", beautify.indent_start + indentation * beautify.indent_level) + line;\n      }\n\n      return line;\n    }\n\n    function with_indent(cont, incr) {\n      if (incr == null) incr = 1;\n      indentation += incr;\n\n      try {\n        return cont.apply(null, slice(arguments, 1));\n      } finally {\n        indentation -= incr;\n      }\n    }\n\n    function add_spaces(a) {\n      if (beautify) {\n        return a.join(\" \");\n      }\n\n      var b = [];\n\n      for (var i = 0; i < a.length; ++i) {\n        var next = a[i + 1];\n        b.push(a[i]);\n\n        if (next && (/[a-z0-9_\\x24]$/i.test(a[i].toString()) && /^[a-z0-9_\\x24]/i.test(next.toString()) || /[\\+\\-]$/.test(a[i].toString()) && /^[\\+\\-]/.test(next.toString()))) {\n          b.push(' ');\n        }\n      }\n\n      return b.join('');\n    }\n\n    function add_commas(a) {\n      return a.join(',' + space);\n    }\n\n    function parenthesize(expr) {\n      var gen = make(expr);\n\n      for (var i = 1; i < arguments.length; ++i) {\n        var el = arguments[i];\n\n        if (el instanceof Function && el(expr) || expr[0] == el) {\n          return \"(\" + gen + \")\";\n        }\n      }\n\n      return gen;\n    }\n\n    var generators = {\n      string: make_string,\n      num: function num(_num2) {\n        return String(_num2);\n      },\n      name: make_name,\n      toplevel: function toplevel(statements) {\n        return make_block_statements(statements).join(newline + newline);\n      },\n      block: make_block,\n      \"var\": function _var(defs) {\n        return 'var ' + add_commas(defs.map(make_1vardef)) + ';';\n      },\n      \"const\": function _const(defs) {\n        return 'const ' + add_commas(defs.map(make_1vardef)) + ';';\n      },\n      \"try\": function _try(tr, ca, fi) {\n        var out = ['try', make_block(tr)];\n        if (ca) out.push('catch', '(' + ca[0] + ')', make_block(ca[1]));\n        if (fi) out.push('finally', make_block(fi));\n        return add_spaces(out);\n      },\n      \"throw\": function _throw(expr) {\n        return \"\".concat(add_spaces([\"throw\", make(expr)]), \";\");\n      },\n      \"new\": function _new(ctor, args) {\n        args = args.length > 0 ? '(' + add_commas(args.map(make)) + ')' : '';\n        return add_spaces(['new', parenthesize(ctor, 'seq', 'binary', 'conditional', 'assign', 'dot') + args]);\n      },\n      \"switch\": function _switch(expr, body) {\n        return add_spaces(['switch', '(' + make(expr) + ')', make_block(body)]);\n      },\n      \"case\": function _case(expr) {\n        return add_spaces(['\\x08case', \"\".concat(make(expr), \":\")]);\n      },\n      \"default\": function _default() {\n        return '\\x08default:';\n      },\n      \"break\": function _break(label) {\n        var out = 'break';\n\n        if (label != null) {\n          out += \" \" + make_name(label);\n        }\n\n        return \"\".concat(out, \";\");\n      },\n      \"continue\": function _continue(label) {\n        var out = 'continue';\n\n        if (label != null) {\n          out += \" \" + make_name(label);\n        }\n\n        return \"\".concat(out, \";\");\n      },\n      conditional: function conditional(co, th, el) {\n        return add_spaces([parenthesize(co, 'assign', 'seq'), '?', parenthesize(th, 'seq'), ':', parenthesize(el, 'seq')]);\n      },\n      assign: function assign(op, lvalue, rvalue) {\n        if (op && op !== true) op += '=';else op = '=';\n        return add_spaces([make(lvalue), op, make(rvalue)]);\n      },\n      dot: function dot(expr) {\n        var out = make(expr);\n        var i = 1;\n\n        if (!HOP(DOT_CALL_NO_PARENS, expr[0])) {\n          out = \"(\" + out + \")\";\n        }\n\n        while (i < arguments.length) {\n          out += \".\" + make_name(arguments[i++]);\n        }\n\n        return out;\n      },\n      call: function call(func, args) {\n        var f = make(func);\n\n        if (!HOP(DOT_CALL_NO_PARENS, func[0])) {\n          f = \"(\" + f + \")\";\n        }\n\n        return \"\".concat(f, \"(\").concat(add_commas(args.map(make)), \")\");\n      },\n      \"function\": make_function,\n      defun: make_function,\n      \"if\": function _if(co, th, el) {\n        var out = ['if', '(' + make(co) + ')', el ? make_then(th) : make(th)];\n\n        if (el) {\n          out.push('else', make(el));\n        }\n\n        return add_spaces(out);\n      },\n      \"for\": function _for(init, cond, step, block) {\n        var out = ['for'];\n        init = (init != null ? make(init) : '').replace(/;*\\s*$/, ';' + space);\n        cond = (cond != null ? make(cond) : '').replace(/;*\\s*$/, ';' + space);\n        step = (step != null ? make(step) : '').replace(/;*\\s*$/, '');\n        var args = init + cond + step;\n        if (args == '; ; ') args = ';;';\n        out.push('(' + args + ')', make(block));\n        return add_spaces(out);\n      },\n      'for-in': function forIn(has_var, key, hash, block) {\n        var out = add_spaces(['for', '(']);\n\n        if (has_var) {\n          out += \"var \";\n        }\n\n        out += add_spaces([\"\".concat(make_name(key), \" in \").concat(make(hash), \")\"), make(block)]);\n        return out;\n      },\n      \"while\": function _while(condition, block) {\n        return add_spaces(['while', '(' + make(condition) + ')', make(block)]);\n      },\n      \"do\": function _do(condition, block) {\n        return \"\".concat(add_spaces([\"do\", make(block), \"while\", \"(\" + make(condition) + \")\"]), \";\");\n      },\n      \"return\": function _return(expr) {\n        var out = ['return'];\n        if (expr != null) out.push(make(expr));\n        return \"\".concat(add_spaces(out), \";\");\n      },\n      binary: function binary(operator, lvalue, rvalue) {\n        var left = make(lvalue);\n        var right = make(rvalue); // XXX: I'm pretty sure other cases will bite here.\n        //      we need to be smarter.\n        //      adding parens all the time is the safest bet.\n\n        if (member(lvalue[0], ['assign', 'conditional', 'seq']) || lvalue[0] == 'binary' && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]]) {\n          left = '(' + left + ')';\n        }\n\n        if (member(rvalue[0], ['assign', 'conditional', 'seq']) || rvalue[0] == 'binary' && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]]) {\n          right = '(' + right + ')';\n        }\n\n        return add_spaces([left, operator, right]);\n      },\n      'unary-prefix': function unaryPrefix(operator, expr) {\n        var val = make(expr);\n\n        if (!(HOP(DOT_CALL_NO_PARENS, expr[0]) || expr[0] == 'num')) {\n          val = \"(\" + val + \")\";\n        }\n\n        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? ' ' : '') + val;\n      },\n      'unary-postfix': function unaryPostfix(operator, expr) {\n        var val = make(expr);\n\n        if (!(HOP(DOT_CALL_NO_PARENS, expr[0]) || expr[0] == 'num')) {\n          val = \"(\" + val + \")\";\n        }\n\n        return val + operator;\n      },\n      sub: function sub(expr, subscript) {\n        var hash = make(expr);\n\n        if (!HOP(DOT_CALL_NO_PARENS, expr[0])) {\n          hash = \"(\" + hash + \")\";\n        }\n\n        return \"\".concat(hash, \"[\").concat(make(subscript), \"]\");\n      },\n      object: function object(props) {\n        if (props.length == 0) {\n          return \"{}\";\n        }\n\n        return '{' + newline + with_indent(function () {\n          return props.map(function (p) {\n            var key = p[0];\n            var val = make(p[1]);\n\n            if (beautify && beautify.quote_keys || !is_identifier(key)) {\n              key = make_string(key);\n            }\n\n            return indent(add_spaces(beautify && beautify.space_colon ? [key, ':', val] : [\"\".concat(key, \":\"), val]));\n          }).join(',' + newline);\n        }) + newline + indent('}');\n      },\n      regexp: function regexp(rx, mods) {\n        return '/' + rx + '/' + mods;\n      },\n      array: function array(elements) {\n        if (elements.length == 0) return '[]';\n        return add_spaces(['[', add_commas(elements.map(make)), ']']);\n      },\n      stat: function stat(stmt) {\n        return make(stmt).replace(/;*\\s*$/, ';');\n      },\n      seq: function seq() {\n        return add_commas(slice(arguments).map(make));\n      },\n      label: function label(name, block) {\n        return add_spaces([make_name(name), ':', make(block)]);\n      },\n      \"with\": function _with(expr, block) {\n        return add_spaces(['with', '(' + make(expr) + ')', make(block)]);\n      },\n      atom: function atom(name) {\n        return make_name(name);\n      },\n      comment1: function comment1(text) {\n        return '//' + text + '\\n';\n      },\n      comment2: function comment2(text) {\n        return '/*' + text + '*/';\n      }\n    }; // The squeezer replaces \"block\"-s that contain only a single\n    // statement with the statement itself; technically, the AST\n    // is correct, but this can create problems when we output an\n    // IF having an ELSE clause where the THEN clause ends in an\n    // IF *without* an ELSE block (then the outer ELSE would refer\n    // to the inner IF).  This function checks for this case and\n    // adds the block brackets if needed.\n\n    function make_then(th) {\n      var b = th;\n\n      while (true) {\n        var type = b[0];\n\n        if (type == 'if') {\n          if (!b[3]) // no else, we must add the block\n            {\n              return make([\"block\", [th]]);\n            }\n\n          b = b[3];\n        } else if (type == 'while' || type == 'do') b = b[2];else if (type == 'for' || type == 'for-in') b = b[4];else break;\n      }\n\n      return make(th);\n    }\n\n    function make_function(name, args, body) {\n      var out = 'function';\n\n      if (name) {\n        out += ' ' + make_name(name);\n      }\n\n      out += '(' + add_commas(args.map(make_name)) + ')';\n      return add_spaces([out, make_block(body)]);\n    }\n\n    function make_string(str) {\n      // return '\"' +\n      //         str.replace(/\\x5c/g, \"\\\\\\\\\")\n      //         .replace(/\\r?\\n/g, \"\\\\n\")\n      //         .replace(/\\t/g, \"\\\\t\")\n      //         .replace(/\\r/g, \"\\\\r\")\n      //         .replace(/\\f/g, \"\\\\f\")\n      //         .replace(/[\\b]/g, \"\\\\b\")\n      //         .replace(/\\x22/g, \"\\\\\\\"\")\n      //         .replace(/[\\x00-\\x1f]|[\\x80-\\xff]/g, function(c){\n      //                 var hex = c.charCodeAt(0).toString(16);\n      //                 if (hex.length < 2)\n      //                         hex = \"0\" + hex;\n      //                 return \"\\\\x\" + hex;\n      //         })\n      //         + '\"';\n      return JSON.stringify(str); // STILL cheating.\n    }\n\n    function make_name(name) {\n      return name.toString();\n    }\n\n    function make_block_statements(statements) {\n      for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {\n        var stat = statements[i];\n        var code = make(stat);\n\n        if (code != ';') {\n          if (!beautify && i == last) {\n            code = code.replace(/;+\\s*$/, \"\");\n          }\n\n          a.push(code);\n        }\n      }\n\n      return a.map(indent);\n    }\n\n    function make_block(statements) {\n      if (!statements) return ';';\n      if (statements.length == 0) return '{}';\n      return '{' + newline + with_indent(function () {\n        return make_block_statements(statements).join(newline);\n      }) + newline + indent('}');\n    }\n\n    function make_1vardef(def) {\n      var name = def[0];\n      var val = def[1];\n\n      if (val != null) {\n        name = add_spaces([name, \"=\", make(val)]);\n      }\n\n      return name;\n    }\n\n    function make(node) {\n      var type = node[0];\n      var gen = generators[type];\n\n      if (!gen) {\n        throw new Error(\"Can't find generator for \\\"\" + type + \"\\\"\");\n      }\n\n      return gen.apply(type, node.slice(1));\n    }\n\n    var out = make(ast);\n\n    if (beautify) {\n      var rx = \"\".concat(repeat_string(\" \", beautify.indent_level / 2), \"\\b\");\n      rx = new RegExp(rx, 'g');\n      out = out.replace(rx, '');\n    } else {\n      out = out.replace(/\\x08/g, '');\n    }\n\n    return out;\n  }\n  /* -----[ Utilities ]----- */\n\n\n  function repeat_string(str, i) {\n    if (i <= 0) return '';\n    if (i == 1) return str;\n    var d = repeat_string(str, i >> 1);\n    d += d;\n    if (i & 1) d += str;\n    return d;\n  }\n\n  function defaults(args, defs) {\n    var ret = {};\n\n    if (args === true) {\n      args = {};\n    }\n\n    for (var i in defs) {\n      if (HOP(defs, i)) {\n        ret[i] = args && HOP(args, i) ? args[i] : defs[i];\n      }\n    }\n\n    return ret;\n  }\n\n  function is_identifier(name) {\n    return /^[a-z_$][a-z0-9_$]*$/i.test(name) && !HOP(jsp.KEYWORDS_ATOM, name) && !HOP(jsp.RESERVED_WORDS, name) && !HOP(jsp.KEYWORDS, name);\n  }\n\n  function HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n  /* -----[ Exports ]----- */\n\n\n  exports.ast_walker = ast_walker;\n  exports.ast_mangle = ast_mangle;\n  exports.ast_squeeze = ast_squeeze;\n  exports.gen_code = gen_code;\n  exports.ast_add_scope = ast_add_scope; // end module: kaffeine/uglify/process.js\n});"),t.REPLEngine=e})();