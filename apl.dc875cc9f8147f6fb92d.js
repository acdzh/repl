(()=>{"use strict";function n(n,e){for(var r=0;r<e.length;r++){var t=e[r];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}var e=function(){function e(n,r,t,a,i,s){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.input=n,this.output=r,this.result=t,this.error=a,this.sandbox=i,this.ready=s;var o=function(){throw Error("I/O is not supported")};this.ws=this.sandbox.apl.ws({in:o,out:o}),this.ready()}var r,t;return r=e,(t=[{key:"Eval",value:function(n){try{var e=(this.ws(n)||"").toString();this.result(e?-1!==e.indexOf("\n")?"\n".concat(e):e:"")}catch(n){this.error(n)}}},{key:"GetNextLineIndent",value:function(n){return!1}}])&&n(r.prototype,t),e}(),r="undefined"!=typeof window&&null!==window?window:self;r.eval.call(r,'import _typeof from "@babel/runtime/helpers/typeof";\n//usr/bin/env node "$0" $@ ; exit $?\n// Generated by CoffeeScript 1.6.3\n(function () {\n  var ADVERB,\n      APLArray,\n      _Beta,\n      CONJUNCTION,\n      Complex,\n      DYA,\n      EMB,\n      GET,\n      JEQ,\n      LAM,\n      LDC,\n      MON,\n      NOUN,\n      POP,\n      RET,\n      SET,\n      SPL,\n      VEC,\n      VERB,\n      addVocabulary,\n      adverb,\n      all,\n      _apl,\n      aplError,\n      _aplify,\n      _approx,\n      arrayEquals,\n      bool,\n      compileAST,\n      complexify,\n      compressOrReplicate,\n      conjunction,\n      contains,\n      cps,\n      deal,\n      _depthOf,\n      domainError,\n      _enlist,\n      eq,\n      exec,\n      exp,\n      expand,\n      extend,\n      first,\n      _format,\n      getAxisList,\n      grade,\n      indexAtSingleAxis,\n      indexError,\n      innerProduct,\n      lengthError,\n      lnΓ,\n      _match,\n      negInt,\n      nonceError,\n      numApprox,\n      numeric,\n      outerProduct,\n      parse,\n      pervasive,\n      prelude,\n      prod,\n      rankError,\n      reduce,\n      repeat,\n      _repr,\n      roll,\n      rotate,\n      scan,\n      simplify,\n      smallFactorials,\n      squish,\n      strideForShape,\n      syntaxError,\n      take,\n      tokenDefs,\n      tokenize,\n      valueError,\n      _vm,\n      vocabulary,\n      withIdentity,\n      _Γ,\n      λ,\n      _base,\n      _ref,\n      _ref1,\n      _ref2,\n      __slice = [].slice,\n      __indexOf = [].indexOf || function (item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item) return i;\n    }\n\n    return -1;\n  };\n\n  prod = function prod(xs) {\n    var r, x, _i, _len;\n\n    r = 1;\n\n    for (_i = 0, _len = xs.length; _i < _len; _i++) {\n      x = xs[_i];\n      r *= x;\n    }\n\n    return r;\n  };\n\n  all = function all(xs) {\n    var x, _i, _len;\n\n    for (_i = 0, _len = xs.length; _i < _len; _i++) {\n      x = xs[_i];\n\n      if (!x) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  repeat = function repeat(a, n) {\n    var m, tmp0;\n\n    if (!(typeof a === \'string\' || a instanceof Array)) {\n      throw Error("\\"assert typeof a is \'string\' or a instanceof Array\\" at src/helpers.coffee:20");\n    }\n\n    if (!((tmp0 = n) === ~~tmp0 && 0 <= tmp0)) {\n      throw Error("\\"assert isInt n, 0\\" at src/helpers.coffee:21");\n    }\n\n    if (!n) {\n      return a.slice(0, 0);\n    }\n\n    m = n * a.length;\n\n    while (a.length * 2 < m) {\n      a = a.concat(a);\n    }\n\n    return a.concat(a.slice(0, m - a.length));\n  };\n\n  extend = function extend(x, y) {\n    var k;\n\n    for (k in y) {\n      x[k] = y[k];\n    }\n\n    return x;\n  };\n\n  if (this.Uint8Array == null) {\n    this.Uint8Array = Array;\n  }\n\n  if (this.Uint16Array == null) {\n    this.Uint16Array = Array;\n  }\n\n  if (this.Uint32Array == null) {\n    this.Uint32Array = Array;\n  }\n\n  if (this.Int8Array == null) {\n    this.Int8Array = Array;\n  }\n\n  if (this.Int16Array == null) {\n    this.Int16Array = Array;\n  }\n\n  if (this.Int32Array == null) {\n    this.Int32Array = Array;\n  }\n\n  if ((_base = Array.prototype).set == null) {\n    _base.set = function (a, offset) {\n      var i, _i, _ref;\n\n      for (i = _i = 0, _ref = a.length; _i < _ref; i = _i += 1) {\n        this[offset + i] = a[i];\n      }\n    };\n  }\n\n  arrayEquals = function arrayEquals(a, b) {\n    var i, x, _i, _len;\n\n    if (!(a instanceof Array)) {\n      throw Error("\\"assert a instanceof Array\\" at src/helpers.coffee:72");\n    }\n\n    if (!(b instanceof Array)) {\n      throw Error("\\"assert b instanceof Array\\" at src/helpers.coffee:73");\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {\n      x = a[i];\n\n      if (x !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  aplError = function aplError(name, message, opts) {\n    var e, k, v, _ref;\n\n    if (message == null) {\n      message = \'\';\n    }\n\n    if (!(typeof name === \'string\')) {\n      throw Error("\\"assert typeof name is \'string\'\\" at src/errors.coffee:2");\n    }\n\n    if (!(typeof message === \'string\')) {\n      throw Error("\\"assert typeof message is \'string\'\\" at src/errors.coffee:3");\n    }\n\n    if (opts != null) {\n      if (!(_typeof(opts) === \'object\')) {\n        throw Error("\\"assert typeof opts is \'object\'\\" at src/errors.coffee:5");\n      }\n\n      if (opts.aplCode != null && opts.line != null && opts.col != null) {\n        if (!(typeof opts.aplCode === \'string\')) {\n          throw Error("\\"assert typeof opts.aplCode is \'string\'\\" at src/errors.coffee:7");\n        }\n\n        if (!(typeof opts.line === \'number\')) {\n          throw Error("\\"assert typeof opts.line is \'number\'\\" at src/errors.coffee:8");\n        }\n\n        if (!(typeof opts.col === \'number\')) {\n          throw Error("\\"assert typeof opts.col is \'number\'\\" at src/errors.coffee:9");\n        }\n\n        if (!((_ref = _typeof(opts.file)) === \'string\' || _ref === \'undefined\')) {\n          throw Error("\\"assert typeof opts.file in [\'string\', \'undefined\']\\" at src/errors.coffee:10");\n        }\n\n        message += "\\n" + (opts.file || \'-\') + ":#" + opts.line + ":" + opts.col + "\\n" + opts.aplCode.split(\'\\n\')[opts.line - 1] + "\\n" + repeat(\'_\', opts.col - 1) + "^";\n      }\n    }\n\n    e = Error(message);\n    e.name = name;\n\n    for (k in opts) {\n      v = opts[k];\n      e[k] = v;\n    }\n\n    throw e;\n  };\n\n  syntaxError = function syntaxError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'SYNTAX ERROR\'].concat(__slice.call(a)));\n  };\n\n  domainError = function domainError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'DOMAIN ERROR\'].concat(__slice.call(a)));\n  };\n\n  lengthError = function lengthError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'LENGTH ERROR\'].concat(__slice.call(a)));\n  };\n\n  rankError = function rankError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'RANK ERROR\'].concat(__slice.call(a)));\n  };\n\n  indexError = function indexError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'INDEX ERROR\'].concat(__slice.call(a)));\n  };\n\n  nonceError = function nonceError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'NONCE ERROR\'].concat(__slice.call(a)));\n  };\n\n  valueError = function valueError() {\n    var a;\n    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return aplError.apply(null, [\'VALUE ERROR\'].concat(__slice.call(a)));\n  };\n\n  APLArray = function () {\n    function APLArray(data, shape, stride, offset) {\n      var i, tmp1, tmp2, tmp3, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;\n\n      this.data = data;\n      this.shape = shape;\n      this.stride = stride;\n      this.offset = offset != null ? offset : 0;\n\n      if (this.shape == null) {\n        this.shape = [this.data.length];\n      }\n\n      if (this.stride == null) {\n        this.stride = strideForShape(this.shape);\n      }\n\n      if (!(this.data.length != null)) {\n        throw Error("\\"assert @data.length?\\" at src/array.coffee:97");\n      }\n\n      if (!(this.shape instanceof Array)) {\n        throw Error("\\"assert @shape instanceof Array\\" at src/array.coffee:98");\n      }\n\n      if (!(this.stride instanceof Array)) {\n        throw Error("\\"assert @stride instanceof Array\\" at src/array.coffee:99");\n      }\n\n      if (!(this.data.length === 0 || (tmp1 = this.offset) === ~~tmp1 && 0 <= (_ref = tmp1) && _ref < this.data.length)) {\n        throw Error("\\"assert @data.length is 0 or isInt @offset, 0, @data.length\\" at src/array.coffee:100");\n      }\n\n      if (!(this.stride.length === this.shape.length)) {\n        throw Error("\\"assert @stride.length is ⍴⍴ @\\" at src/array.coffee:101");\n      }\n\n      _ref1 = this.shape;\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        x = _ref1[_i];\n\n        if (!((tmp2 = x) === ~~tmp2 && 0 <= tmp2)) {\n          throw Error("\\"for x in @shape then assert isInt x, 0\\" at src/array.coffee:102");\n        }\n      }\n\n      if (this.data.length) {\n        _ref2 = this.stride;\n\n        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {\n          x = _ref2[i];\n\n          if (!((tmp3 = x) === ~~tmp3 && -this.data.length <= (_ref3 = tmp3) && _ref3 < this.data.length + 1)) {\n            throw Error("\\"for x, i in @stride then assert isInt x, -@data.length, @data.length + 1\\" at src/array.coffee:104");\n          }\n        }\n      }\n    }\n\n    APLArray.prototype.empty = function () {\n      var d, _i, _len, _ref;\n\n      _ref = this.shape;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        d = _ref[_i];\n\n        if (!d) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    APLArray.prototype.map = function (f) {\n      var data, indices, t10, t4, t5, t6, t7, t8, t9, x;\n\n      if (!(typeof f === \'function\')) {\n        throw Error("\\"assert typeof f is \'function\'\\" at src/array.coffee:111");\n      }\n\n      data = [];\n      t4 = this;\n\n      if (!t4.empty()) {\n        t6 = t4.data;\n        t7 = t4.shape;\n        t8 = t4.stride;\n        t9 = t7.length - 1;\n        t10 = t4.offset;\n        indices = [];\n        t5 = t7.length;\n\n        while (--t5 >= 0) {\n          indices.push(0);\n        }\n\n        while (true) {\n          x = t6[t10];\n          data.push(f(x, indices));\n          t5 = t9;\n\n          while (t5 >= 0 && indices[t5] + 1 === t7[t5]) {\n            t10 -= indices[t5] * t8[t5];\n            indices[t5--] = 0;\n          }\n\n          if (t5 < 0) {\n            break;\n          }\n\n          indices[t5]++;\n          t10 += t8[t5];\n        }\n      }\n\n      return new APLArray(data, this.shape);\n    };\n\n    APLArray.prototype.map2 = function (a, f) {\n      var data, indices, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, x, y;\n\n      if (!(a instanceof APLArray)) {\n        throw Error("\\"assert a instanceof APLArray\\" at src/array.coffee:117");\n      }\n\n      if (!(typeof f === \'function\')) {\n        throw Error("\\"assert typeof f is \'function\'\\" at src/array.coffee:118");\n      }\n\n      data = [];\n      t11 = this;\n      t16 = t11.data;\n      t18 = t11.shape;\n      t20 = t11.stride;\n      t12 = a;\n      t17 = t12.data;\n      t19 = t12.shape;\n      t21 = t12.stride;\n\n      if (t18.length !== t19.length) {\n        rankError();\n      }\n\n      t15 = t18.length;\n\n      while (--t15 >= 0) {\n        if (t18[t15] !== t19[t15]) {\n          lengthError();\n        }\n      }\n\n      if (!t11.empty()) {\n        t22 = t18.length - 1;\n        t13 = t11.offset;\n        t14 = t12.offset;\n        indices = Array(t15 = t18.length);\n\n        while (--t15 >= 0) {\n          indices[t15] = 0;\n        }\n\n        while (true) {\n          x = t16[t13];\n          y = t17[t14];\n          data.push(f(x, y, indices));\n          t15 = t22;\n\n          while (t15 >= 0 && indices[t15] + 1 === t18[t15]) {\n            t13 -= indices[t15] * t20[t15];\n            t14 -= indices[t15] * t21[t15];\n            indices[t15--] = 0;\n          }\n\n          if (t15 < 0) {\n            break;\n          }\n\n          indices[t15]++;\n          t13 += t20[t15];\n          t14 += t21[t15];\n        }\n      }\n\n      return new APLArray(data, this.shape);\n    };\n\n    APLArray.prototype.toArray = function () {\n      var r, t23, t24, t25, t26, t27, t28, t29, t30, x;\n      r = [];\n      t23 = this;\n\n      if (!t23.empty()) {\n        t25 = t23.data;\n        t26 = t23.shape;\n        t27 = t23.stride;\n        t28 = t26.length - 1;\n        t30 = t23.offset;\n        t29 = [];\n        t24 = t26.length;\n\n        while (--t24 >= 0) {\n          t29.push(0);\n        }\n\n        while (true) {\n          x = t25[t30];\n          r.push(x);\n          t24 = t28;\n\n          while (t24 >= 0 && t29[t24] + 1 === t26[t24]) {\n            t30 -= t29[t24] * t27[t24];\n            t29[t24--] = 0;\n          }\n\n          if (t24 < 0) {\n            break;\n          }\n\n          t29[t24]++;\n          t30 += t27[t24];\n        }\n      }\n\n      return r;\n    };\n\n    APLArray.prototype.toInt = function (start, end) {\n      var r;\n\n      if (start == null) {\n        start = -Infinity;\n      }\n\n      if (end == null) {\n        end = Infinity;\n      }\n\n      r = this.unwrap();\n\n      if (typeof r !== \'number\' || r !== ~~r || !(start <= r && r < end)) {\n        return domainError();\n      } else {\n        return r;\n      }\n    };\n\n    APLArray.prototype.toBool = function () {\n      return this.toInt(0, 2);\n    };\n\n    APLArray.prototype.toSimpleString = function () {\n      var a, x, _i, _len;\n\n      if (this.shape.length > 1) {\n        rankError();\n      }\n\n      if (typeof this.data === \'string\') {\n        if (!this.shape.length) {\n          return this.data[this.offset];\n        }\n\n        if (this.shape[0] === 0) {\n          return \'\';\n        }\n\n        if (this.stride[0] === 1) {\n          return this.data.slice(this.offset, this.offset + this.shape[0]);\n        }\n\n        return this.toArray().join(\'\');\n      } else {\n        a = this.toArray();\n\n        for (_i = 0, _len = a.length; _i < _len; _i++) {\n          x = a[_i];\n\n          if (typeof x !== \'string\') {\n            domainError();\n          }\n        }\n\n        return a.join(\'\');\n      }\n    };\n\n    APLArray.prototype.isSingleton = function () {\n      var n, _i, _len, _ref;\n\n      _ref = this.shape;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        n = _ref[_i];\n\n        if (n !== 1) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    APLArray.prototype.isSimple = function () {\n      return this.shape.length === 0 && !(this.data[this.offset] instanceof APLArray);\n    };\n\n    APLArray.prototype.unwrap = function () {\n      if (prod(this.shape) === 1) {\n        return this.data[this.offset];\n      } else {\n        return lengthError();\n      }\n    };\n\n    APLArray.prototype.getPrototype = function () {\n      if (this.empty() || typeof this.data[this.offset] !== \'string\') {\n        return 0;\n      } else {\n        return \' \';\n      }\n    };\n\n    APLArray.prototype.toString = function () {\n      return _format(this).join(\'\\n\');\n    };\n\n    APLArray.prototype.repr = function () {\n      return "new APLArray(" + _repr(this.data) + "," + _repr(this.shape) + "," + _repr(this.stride) + "," + _repr(this.offset) + ")";\n    };\n\n    return APLArray;\n  }();\n\n  strideForShape = function strideForShape(shape) {\n    var i, r, tmp31, _i, _ref;\n\n    if (!(shape instanceof Array)) {\n      throw Error("\\"assert shape instanceof Array\\" at src/array.coffee:157");\n    }\n\n    if (shape.length === 0) {\n      return [];\n    }\n\n    r = Array(shape.length);\n    r[r.length - 1] = 1;\n\n    for (i = _i = _ref = r.length - 2; _i >= 0; i = _i += -1) {\n      if (!((tmp31 = shape[i]) === ~~tmp31 && 0 <= tmp31)) {\n        throw Error("\\"assert isInt shape[i], 0\\" at src/array.coffee:162");\n      }\n\n      r[i] = r[i + 1] * shape[i + 1];\n    }\n\n    return r;\n  };\n\n  APLArray.zero = new APLArray([0], []);\n  APLArray.one = new APLArray([1], []);\n  APLArray.zilde = new APLArray([], [0]);\n\n  APLArray.scalar = function (x) {\n    return new APLArray([x], []);\n  };\n\n  APLArray.bool = [APLArray.zero, APLArray.one];\n\n  complexify = function complexify(x) {\n    if (typeof x === \'number\') {\n      return new Complex(x, 0);\n    } else if (x instanceof Complex) {\n      return x;\n    } else {\n      return domainError();\n    }\n  };\n\n  simplify = function simplify(re, im) {\n    if (im !== 0) {\n      return new Complex(re, im);\n    } else {\n      return re;\n    }\n  };\n\n  Complex = function () {\n    var acos, add, asin, atan, cosh, direction, divide, exp, firstquadrant, isZeroed, floor, gcd, itimes, log, multiply, negate, negitimes, pow, residue, sinh, sqrt, subtract, tanh;\n\n    function Complex(re, im) {\n      this.re = re;\n      this.im = im != null ? im : 0;\n\n      if (!(typeof this.re === \'number\')) {\n        throw Error("\\"assert typeof @re is \'number\'\\" at src/complex.coffee:20");\n      }\n\n      if (!(typeof this.im === \'number\')) {\n        throw Error("\\"assert typeof @im is \'number\'\\" at src/complex.coffee:21");\n      }\n\n      if (isNaN(this.re) || isNaN(this.im)) {\n        domainError(\'NaN\');\n      }\n    }\n\n    Complex.prototype.toString = function () {\n      return "" + (\'\' + this.re).replace(\'Infinity\', \'∞\').replace(/-/g, \'¯\') + "j" + (\'\' + this.im).replace(\'Infinity\', \'∞\').replace(/-/g, \'¯\');\n    };\n\n    Complex.prototype.repr = function () {\n      return "new Complex(" + _repr(this.re) + "," + _repr(this.im) + ")";\n    };\n\n    Complex.exp = exp = function exp(x) {\n      var r;\n      x = complexify(x);\n      r = Math.exp(x.re);\n      return simplify(r * Math.cos(x.im), r * Math.sin(x.im));\n    };\n\n    Complex.log = log = function log(x) {\n      if (typeof x === \'number\' && x > 0) {\n        return Math.log(x);\n      } else {\n        x = complexify(x);\n        return simplify(Math.log(Math.sqrt(x.re * x.re + x.im * x.im)), direction(x));\n      }\n    };\n\n    Complex.conjugate = function (x) {\n      return new Complex(x.re, -x.im);\n    };\n\n    Complex.negate = negate = function negate(x) {\n      return new Complex(-x.re, -x.im);\n    };\n\n    Complex.itimes = itimes = function itimes(x) {\n      x = complexify(x);\n      return simplify(-x.im, x.re);\n    };\n\n    Complex.negitimes = negitimes = function negitimes(x) {\n      x = complexify(x);\n      return simplify(x.im, -x.re);\n    };\n\n    Complex.add = add = function add(x, y) {\n      x = complexify(x);\n      y = complexify(y);\n      return simplify(x.re + y.re, x.im + y.im);\n    };\n\n    Complex.subtract = subtract = function subtract(x, y) {\n      x = complexify(x);\n      y = complexify(y);\n      return simplify(x.re - y.re, x.im - y.im);\n    };\n\n    Complex.multiply = multiply = function multiply(x, y) {\n      x = complexify(x);\n      y = complexify(y);\n      return simplify(x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re);\n    };\n\n    Complex.divide = divide = function divide(x, y) {\n      var d;\n      x = complexify(x);\n      y = complexify(y);\n      d = y.re * y.re + y.im * y.im;\n      return simplify((x.re * y.re + x.im * y.im) / d, (y.re * x.im - y.im * x.re) / d);\n    };\n\n    Complex.pow = pow = function pow(x, y) {\n      var _ref;\n\n      if (_typeof(x) === (_ref = _typeof(y)) && _ref === \'number\' && x >= 0) {\n        return Math.pow(x, y);\n      } else {\n        return exp(multiply(y, log(x)));\n      }\n    };\n\n    Complex.sqrt = sqrt = function sqrt(x) {\n      if (typeof x === \'number\' && x >= 0) {\n        return Math.sqrt(x);\n      } else {\n        return pow(x, 0.5);\n      }\n    };\n\n    Complex.magnitude = function (x) {\n      return Math.sqrt(x.re * x.re + x.im * x.im);\n    };\n\n    Complex.direction = direction = function direction(x) {\n      return Math.atan2(x.im, x.re);\n    };\n\n    Complex.sin = function (x) {\n      return negitimes(sinh(itimes(x)));\n    };\n\n    Complex.cos = function (x) {\n      return cosh(itimes(x));\n    };\n\n    Complex.tan = function (x) {\n      return negitimes(tanh(itimes(x)));\n    };\n\n    Complex.asin = asin = function asin(x) {\n      x = complexify(x);\n      return negitimes(log(add(itimes(x), sqrt(subtract(1, pow(x, 2))))));\n    };\n\n    Complex.acos = acos = function acos(x) {\n      var r;\n      x = complexify(x);\n      r = negitimes(log(add(x, sqrt(subtract(pow(x, 2), 1)))));\n\n      if (r instanceof Complex && (r.re < 0 || r.re === 0 && r.im < 0)) {\n        return negate(r);\n      } else {\n        return r;\n      }\n    };\n\n    Complex.atan = atan = function atan(x) {\n      var ix;\n      x = complexify(x);\n      ix = itimes(x);\n      return multiply(new Complex(0, .5), subtract(log(subtract(1, ix)), log(add(1, ix))));\n    };\n\n    Complex.sinh = sinh = function sinh(x) {\n      var a;\n      a = exp(x);\n      return multiply(0.5, subtract(a, divide(1, a)));\n    };\n\n    Complex.cosh = cosh = function cosh(x) {\n      var a;\n      a = exp(x);\n      return multiply(0.5, add(a, divide(1, a)));\n    };\n\n    Complex.tanh = tanh = function tanh(x) {\n      var a, b;\n      a = exp(x);\n      b = divide(1, a);\n      return divide(subtract(a, b), add(a, b));\n    };\n\n    Complex.asinh = function (x) {\n      return itimes(asin(negitimes(x)));\n    };\n\n    Complex.acosh = function (x) {\n      var sign;\n      x = complexify(x);\n      sign = x.im > 0 || x.im === 0 && x.re <= 1 ? 1 : -1;\n      return multiply(new Complex(0, sign), acos(x));\n    };\n\n    Complex.atanh = function (x) {\n      return itimes(atan(negitimes(x)));\n    };\n\n    Complex.floor = floor = function floor(x) {\n      var i, im, r, re, _ref, _ref1;\n\n      if (typeof x === \'number\') {\n        if (thisCT == 0) {\n          return Math.floor(x);\n        } else {\n          return TolerantFloor(x);\n        }\n      } else {\n        x = complexify(x);\n        _ref = [Math.floor(x.re), Math.floor(x.im)], re = _ref[0], im = _ref[1];\n        _ref1 = [x.re - re, x.im - im], r = _ref1[0], i = _ref1[1];\n\n        if (r + i >= 1) {\n          if (r >= i) {\n            re++;\n          } else {\n            im++;\n          }\n        }\n\n        return simplify(re, im);\n      }\n    };\n\n    Complex.ceil = function (x) {\n      var i, im, r, re, _ref, _ref1;\n\n      if (typeof x === \'number\') {\n        if (thisCT == 0) {\n          return Math.ceil(x);\n        } else {\n          return -TolerantFloor(-x);\n        }\n      } else {\n        x = complexify(x);\n        _ref = [Math.ceil(x.re), Math.ceil(x.im)], re = _ref[0], im = _ref[1];\n        _ref1 = [re - x.re, im - x.im], r = _ref1[0], i = _ref1[1];\n\n        if (r + i >= 1) {\n          if (r >= i) {\n            re--;\n          } else {\n            im--;\n          }\n        }\n\n        return simplify(re, im);\n      }\n    };\n\n    Complex.isZero = function (x) {\n      return isZeroed(x) || x instanceof Complex && isZeroed(x.re) && isZeroed(x.im);\n    };\n\n    isZeroed = function isZeroed(x) {\n      return Math.abs(x) <= thisCT;\n    };\n\n    Complex.residue = residue = function residue(x, y) {\n      var _ref;\n\n      if (_typeof(x) === (_ref = _typeof(y)) && _ref === \'number\') {\n        if (isZeroed(x)) {\n          return y;\n        } else {\n          return y - x * Math.floor(y / x);\n        }\n      } else {\n        if (Complex.isZero(x)) {\n          return y;\n        } else {\n          return subtract(y, multiply(x, floor(divide(y, x))));\n        }\n      }\n    };\n\n    Complex.isint = function (x) {\n      if (typeof x === \'number\') {\n        return x === Math.floor(x);\n      } else {\n        return x.re === Math.floor(x.re) && x.im === Math.floor(x.im);\n      }\n    };\n\n    firstquadrant = function firstquadrant(x) {\n      if (typeof x === \'number\') {\n        return Math.abs(x);\n      } else {\n        if (x.re < 0) {\n          x = negate(x);\n        }\n\n        if (x.im < 0) {\n          x = itimes(x);\n        }\n\n        if (x.re === 0) {\n          x = x.im;\n        }\n\n        return x;\n      }\n    };\n\n    Complex.gcd = gcd = function gcd(x, y) {\n      var _ref, _ref1, _ref2;\n\n      if (_typeof(x) === (_ref = _typeof(y)) && _ref === \'number\') {\n        while (y) {\n          _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];\n        }\n\n        return Math.abs(x);\n      } else {\n        while (!Complex.isZero(y)) {\n          _ref2 = [y, residue(y, x)], x = _ref2[0], y = _ref2[1];\n        }\n\n        return firstquadrant(x);\n      }\n    };\n\n    Complex.lcm = function (x, y) {\n      var p;\n      p = multiply(x, y);\n\n      if (Complex.isZero(p)) {\n        return p;\n      } else {\n        return divide(p, gcd(x, y));\n      }\n    };\n\n    return Complex;\n  }();\n\n  _ref = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], LDC = _ref[0], VEC = _ref[1], GET = _ref[2], SET = _ref[3], MON = _ref[4], DYA = _ref[5], LAM = _ref[6], RET = _ref[7], POP = _ref[8], SPL = _ref[9], JEQ = _ref[10], EMB = _ref[11];\n\n  λ = function () {\n    function λ(code, addr, env) {\n      this.code = code;\n      this.addr = addr;\n      this.env = env;\n    }\n\n    λ.prototype.toFunction = function () {\n      return function (_this) {\n        return function (x, y) {\n          return _vm({\n            code: _this.code,\n            env: _this.env.concat([[x, _this, y]]),\n            pc: _this.addr\n          });\n        };\n      }(this);\n    };\n\n    λ.prototype.toString = function () {\n      return \'λ\';\n    };\n\n    return λ;\n  }();\n\n  _vm = function vm(_arg) {\n    var a, code, env, f, frame, n, pc, size, stack, w, x, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;\n\n    code = _arg.code, env = _arg.env, stack = _arg.stack, pc = _arg.pc;\n\n    if (!(code instanceof Array)) {\n      throw Error("\\"assert code instanceof Array\\" at src/vm.coffee:9");\n    }\n\n    if (!(env instanceof Array)) {\n      throw Error("\\"assert env instanceof Array\\" at src/vm.coffee:10");\n    }\n\n    for (_i = 0, _len = env.length; _i < _len; _i++) {\n      frame = env[_i];\n\n      if (!(frame instanceof Array)) {\n        throw Error("\\"for frame in env then assert frame instanceof Array\\" at src/vm.coffee:11");\n      }\n    }\n\n    if (stack == null) {\n      stack = [];\n    }\n\n    if (pc == null) {\n      pc = 0;\n    }\n\n    while (true) {\n      switch (code[pc++]) {\n        case LDC:\n          stack.push(code[pc++]);\n          break;\n\n        case VEC:\n          a = [];\n          _ref1 = stack.splice(stack.length - code[pc++]);\n\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            x = _ref1[_j];\n            a.push(x.isSimple() ? x.unwrap() : x);\n          }\n\n          stack.push(new APLArray(a));\n          break;\n\n        case GET:\n          stack.push((_ref2 = env[code[pc++]][code[pc++]]) != null ? _ref2 : valueError());\n          break;\n\n        case SET:\n          env[code[pc++]][code[pc++]] = stack[stack.length - 1];\n          break;\n\n        case MON:\n          _ref3 = stack.splice(-2), w = _ref3[0], f = _ref3[1];\n\n          if (typeof f === \'function\') {\n            if (w instanceof λ) {\n              w = w.toFunction();\n            }\n\n            if (f.cps) {\n              f(w, void 0, void 0, function (r) {\n                stack.push(r);\n\n                _vm({\n                  code: code,\n                  env: env,\n                  stack: stack,\n                  pc: pc\n                });\n              });\n              return;\n            } else {\n              stack.push(f(w));\n            }\n          } else {\n            stack.push(code, pc, env);\n            code = f.code;\n            pc = f.addr;\n            env = f.env.concat([[w, f, null]]);\n          }\n\n          break;\n\n        case DYA:\n          _ref4 = stack.splice(-3), w = _ref4[0], f = _ref4[1], a = _ref4[2];\n\n          if (typeof f === \'function\') {\n            if (w instanceof λ) {\n              w = w.toFunction();\n            }\n\n            if (a instanceof λ) {\n              a = a.toFunction();\n            }\n\n            if (f.cps) {\n              f(w, a, void 0, function (r) {\n                stack.push(r);\n\n                _vm({\n                  code: code,\n                  env: env,\n                  stack: stack,\n                  pc: pc\n                });\n              });\n              return;\n            } else {\n              stack.push(f(w, a));\n            }\n          } else {\n            stack.push(code, pc, env);\n            code = f.code;\n            pc = f.addr;\n            env = f.env.concat([[w, f, a]]);\n          }\n\n          break;\n\n        case LAM:\n          size = code[pc++];\n          stack.push(new λ(code, pc, env));\n          pc += size;\n          break;\n\n        case RET:\n          if (stack.length === 1) {\n            return stack[0];\n          }\n\n          _ref5 = stack.splice(-4, 3), code = _ref5[0], pc = _ref5[1], env = _ref5[2];\n          break;\n\n        case POP:\n          stack.pop();\n          break;\n\n        case SPL:\n          n = code[pc++];\n          a = stack[stack.length - 1].toArray().reverse();\n\n          a = function () {\n            var _k, _len2, _results;\n\n            _results = [];\n\n            for (_k = 0, _len2 = a.length; _k < _len2; _k++) {\n              x = a[_k];\n\n              _results.push(x instanceof APLArray ? x : new APLArray([x], []));\n            }\n\n            return _results;\n          }();\n\n          if (a.length === 1) {\n            a = repeat(a, n);\n          } else if (a.length !== n) {\n            lengthError();\n          }\n\n          stack.push.apply(stack, a);\n          break;\n\n        case JEQ:\n          n = code[pc++];\n\n          if (!stack[stack.length - 1].toBool()) {\n            pc += n;\n          }\n\n          break;\n\n        case EMB:\n          frame = env[env.length - 1];\n          stack.push(code[pc++](frame[0], frame[2]));\n          break;\n\n        default:\n          aplError(\'Unrecognized instruction: \' + code[pc - 1] + \', pc:\' + pc);\n      }\n    }\n  };\n\n  tokenDefs = [[\'-\', /^(?:[ \\t]+|[⍝\\#].*)+/], [\'L\', /^[\\n\\r]+/], [\'⋄\', /^[◇⋄]/], [\'N\', /^¯?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+¯]?\\d+)?|¯|∞)(?:j¯?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+¯]?\\d+)?|¯|∞))?/i], [\'S\', /^(?:\'[^\']*\')+|^(?:"[^"]*")+/], [\'.\', /^[\\(\\)\\[\\]\\{\\}:;←]/], [\'J\', /^«[^»]*»/], [\'X\', /^(?:⎕?[a-z_]\\w*|⍺⍺|⍵⍵|∇∇|[^¯\'":«»])/i]];\n\n  tokenize = function tokenize(s, opts) {\n    var a, col, line, m, re, stack, startCol, startLine, t, tokens, type, _i, _len, _ref1;\n\n    if (opts == null) {\n      opts = {};\n    }\n\n    line = col = 1;\n    stack = [\'{\'];\n    tokens = [];\n\n    while (s) {\n      startLine = line;\n      startCol = col;\n      type = null;\n\n      for (_i = 0, _len = tokenDefs.length; _i < _len; _i++) {\n        _ref1 = tokenDefs[_i], t = _ref1[0], re = _ref1[1];\n\n        if (!(m = s.match(re))) {\n          continue;\n        }\n\n        type = t === \'.\' ? m[0] : t;\n        break;\n      }\n\n      type || syntaxError(\'Unrecognized token\', {\n        file: opts.file,\n        line: line,\n        col: col,\n        s: opts.s\n      });\n      a = m[0].split(\'\\n\');\n      line += a.length - 1;\n      col = (a.length === 1 ? col : 1) + a[a.length - 1].length;\n      s = s.slice(m[0].length);\n\n      if (type !== \'-\') {\n        if (__indexOf.call(\'([{\', type) >= 0) {\n          stack.push(type);\n        } else if (__indexOf.call(\')]}\', type) >= 0) {\n          stack.pop();\n        }\n\n        if (type !== \'L\' || stack[stack.length - 1] === \'{\') {\n          tokens.push({\n            type: type,\n            startLine: startLine,\n            startCol: startCol,\n            value: m[0],\n            endLine: line,\n            endCol: col\n          });\n        }\n      }\n    }\n\n    tokens.push({\n      type: \'$\',\n      value: \'\',\n      startLine: line,\n      startCol: col,\n      endLine: line,\n      endCol: col\n    });\n    return tokens;\n  };\n\n  parse = function parse(aplCode, opts) {\n    var i, parseBody, _parseExpr, parserError, result, token, tokens;\n\n    if (opts == null) {\n      opts = {};\n    }\n\n    tokens = tokenize(aplCode);\n    i = 0;\n    token = tokens[i++];\n\n    parserError = function parserError(message) {\n      return syntaxError(message, {\n        file: opts.file,\n        line: token.startLine,\n        col: token.startCol,\n        aplCode: aplCode\n      });\n    };\n\n    parseBody = function parseBody() {\n      var body, expr, _ref1, _ref2, _ref3, _ref4;\n\n      body = [\'B\'];\n\n      while (true) {\n        if (_ref1 = token.type, __indexOf.call(\'$};\', _ref1) >= 0) {\n          return body;\n        }\n\n        while ((_ref2 = token.type) === "⋄" || _ref2 === "L" ? token = tokens[i++] : void 0) {}\n\n        if (_ref3 = token.type, __indexOf.call(\'$};\', _ref3) >= 0) {\n          return body;\n        }\n\n        expr = _parseExpr();\n\n        if ((_ref4 = token.type) === ":" ? token = tokens[i++] : void 0) {\n          expr = [\':\', expr, _parseExpr()];\n        }\n\n        body.push(expr);\n      }\n    };\n\n    _parseExpr = function parseExpr() {\n      var expr, item, t, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n\n      expr = [\'.\'];\n\n      while (true) {\n        t = token;\n\n        if ((_ref1 = token.type) === "N" || _ref1 === "S" || _ref1 === "X" || _ref1 === "J" ? token = tokens[i++] : void 0) {\n          item = [t.type, t.value];\n        } else if ((_ref2 = token.type) === "(" ? token = tokens[i++] : void 0) {\n          if ((_ref3 = token.type) === ")" ? token = tokens[i++] : void 0) {\n            item = [\'⍬\'];\n          } else {\n            item = _parseExpr();\n\n            if (token.type === \')\') {\n              token = tokens[i++];\n            } else {\n              parserError("Expected token of type \'" + \')\' + "\' but got \'" + token.type + "\'");\n            }\n          }\n        } else if ((_ref4 = token.type) === "{" ? token = tokens[i++] : void 0) {\n          item = [\'{\', parseBody()];\n\n          while ((_ref5 = token.type) === ";" ? token = tokens[i++] : void 0) {\n            item.push(parseBody());\n          }\n\n          if (token.type === \'}\') {\n            token = tokens[i++];\n          } else {\n            parserError("Expected token of type \'" + \'}\' + "\' but got \'" + token.type + "\'");\n          }\n        } else {\n          parserError("Encountered unexpected token of type \'" + token.type + "\'");\n        }\n\n        if ((_ref6 = token.type) === "[" ? token = tokens[i++] : void 0) {\n          item = [\'[\', item];\n\n          while (true) {\n            if ((_ref7 = token.type) === ";" ? token = tokens[i++] : void 0) {\n              item.push(null);\n            } else if (token.type === \']\') {\n              item.push(null);\n              break;\n            } else {\n              item.push(_parseExpr());\n\n              if (token.type === \']\') {\n                break;\n              } else {\n                if (token.type === \';\') {\n                  token = tokens[i++];\n                } else {\n                  parserError("Expected token of type \'" + \';\' + "\' but got \'" + token.type + "\'");\n                }\n              }\n            }\n          }\n\n          if (token.type === \']\') {\n            token = tokens[i++];\n          } else {\n            parserError("Expected token of type \'" + \']\' + "\' but got \'" + token.type + "\'");\n          }\n        }\n\n        if ((_ref8 = token.type) === "←" ? token = tokens[i++] : void 0) {\n          return expr.concat([[\'←\', item, _parseExpr()]]);\n        }\n\n        expr.push(item);\n\n        if (_ref9 = token.type, __indexOf.call(\')]}:;⋄L$\', _ref9) >= 0) {\n          return expr;\n        }\n      }\n    };\n\n    result = parseBody();\n\n    if (token.type === \'$\') {\n      token = tokens[i++];\n    } else {\n      parserError("Expected token of type \'" + \'$\' + "\' but got \'" + token.type + "\'");\n    }\n\n    return result;\n  };\n\n  vocabulary = {};\n\n  addVocabulary = function addVocabulary(h) {\n    var k, v;\n\n    for (k in h) {\n      v = h[k];\n      vocabulary[k] = v;\n    }\n  };\n\n  pervasive = function pervasive(_arg) {\n    var dyad, monad, pervadeDyadic, pervadeMonadic;\n    monad = _arg.monad, dyad = _arg.dyad;\n    pervadeMonadic = monad ? function (x) {\n      var r;\n\n      if (x instanceof APLArray) {\n        return x.map(pervadeMonadic);\n      } else {\n        r = monad(x);\n\n        if (typeof r === \'number\' && isNaN(r)) {\n          domainError(\'NaN\');\n        }\n\n        return r;\n      }\n    } : nonceError;\n    pervadeDyadic = dyad ? function (x, y) {\n      var axis, r, tx, ty, xi, yi, _i, _ref1;\n\n      tx = x instanceof APLArray ? x.isSingleton() ? 1 : 2 : 0;\n      ty = y instanceof APLArray ? y.isSingleton() ? 1 : 2 : 0;\n\n      switch (16 * tx + ty) {\n        case 0x00:\n          r = dyad(x, y);\n\n          if (typeof r === \'number\' && isNaN(r)) {\n            domainError(\'NaN\');\n          }\n\n          return r;\n\n        case 0x01:\n        case 0x02:\n          return y.map(function (yi) {\n            return pervadeDyadic(x, yi);\n          });\n\n        case 0x10:\n        case 0x20:\n          return x.map(function (xi) {\n            return pervadeDyadic(xi, y);\n          });\n\n        case 0x12:\n          xi = x.data[x.offset];\n          return y.map(function (yi) {\n            return pervadeDyadic(xi, yi);\n          });\n\n        case 0x21:\n        case 0x11:\n          yi = y.data[y.offset];\n          return x.map(function (xi) {\n            return pervadeDyadic(xi, yi);\n          });\n\n        case 0x22:\n          if (x.shape.length !== y.shape.length) {\n            rankError();\n          }\n\n          for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {\n            if (x.shape[axis] !== y.shape[axis]) {\n              lengthError();\n            }\n          }\n\n          return x.map2(y, pervadeDyadic);\n\n        default:\n          if (!0) {\n            throw Error("\\"else assert 0\\" at src/vocabulary/vhelpers.coffee:40");\n          }\n\n      }\n    } : nonceError;\n    return function (omega, alpha) {\n      if (!(omega instanceof APLArray)) {\n        throw Error("\\"assert ⍵ instanceof APLArray\\" at src/vocabulary/vhelpers.coffee:44");\n      }\n\n      if (!(alpha instanceof APLArray || alpha == null)) {\n        throw Error("\\"assert ⍺ instanceof APLArray or not ⍺?\\" at src/vocabulary/vhelpers.coffee:45");\n      }\n\n      return (alpha != null ? pervadeDyadic : pervadeMonadic)(omega, alpha);\n    };\n  };\n\n  numeric = function numeric(f, g) {\n    return function (x, y, axis) {\n      if (typeof x === \'number\' && (y == null || typeof y === \'number\')) {\n        return f(x, y, axis);\n      } else {\n        x = complexify(x);\n\n        if (y != null) {\n          y = complexify(y);\n        }\n\n        return g(x, y, axis);\n      }\n    };\n  };\n\n  _match = function match(x, y) {\n    var axis, r, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, xi, yi, _i, _ref1;\n\n    if (x instanceof APLArray) {\n      if (!(y instanceof APLArray)) {\n        return false;\n      } else {\n        if (x.shape.length !== y.shape.length) {\n          return false;\n        }\n\n        for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {\n          if (x.shape[axis] !== y.shape[axis]) {\n            return false;\n          }\n        }\n\n        r = true;\n        t32 = x;\n        t37 = t32.data;\n        t39 = t32.shape;\n        t41 = t32.stride;\n        t33 = y;\n        t38 = t33.data;\n        t40 = t33.shape;\n        t42 = t33.stride;\n\n        if (t39.length !== t40.length) {\n          rankError();\n        }\n\n        t36 = t39.length;\n\n        while (--t36 >= 0) {\n          if (t39[t36] !== t40[t36]) {\n            lengthError();\n          }\n        }\n\n        if (!t32.empty()) {\n          t43 = t39.length - 1;\n          t34 = t32.offset;\n          t35 = t33.offset;\n          t44 = Array(t36 = t39.length);\n\n          while (--t36 >= 0) {\n            t44[t36] = 0;\n          }\n\n          while (true) {\n            xi = t37[t34];\n            yi = t38[t35];\n\n            if (!_match(xi, yi)) {\n              r = false;\n            }\n\n            t36 = t43;\n\n            while (t36 >= 0 && t44[t36] + 1 === t39[t36]) {\n              t34 -= t44[t36] * t41[t36];\n              t35 -= t44[t36] * t42[t36];\n              t44[t36--] = 0;\n            }\n\n            if (t36 < 0) {\n              break;\n            }\n\n            t44[t36]++;\n            t34 += t41[t36];\n            t35 += t42[t36];\n          }\n        }\n\n        return r;\n      }\n    } else {\n      if (y instanceof APLArray) {\n        return false;\n      } else {\n        if (x instanceof Complex && y instanceof Complex) {\n          return x.re === y.re && x.im === y.im;\n        } else {\n          return x === y;\n        }\n      }\n    }\n  };\n\n  numApprox = function numApprox(x, y) {\n    return x === y || Math.abs(x - y) < 1e-11;\n  };\n\n  _approx = function approx(x, y) {\n    var axis, r, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, xi, yi, _i, _ref1;\n\n    if (x instanceof APLArray) {\n      if (!(y instanceof APLArray)) {\n        return false;\n      } else {\n        if (x.shape.length !== y.shape.length) {\n          return false;\n        }\n\n        for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {\n          if (x.shape[axis] !== y.shape[axis]) {\n            return false;\n          }\n        }\n\n        r = true;\n        t45 = x;\n        t50 = t45.data;\n        t52 = t45.shape;\n        t54 = t45.stride;\n        t46 = y;\n        t51 = t46.data;\n        t53 = t46.shape;\n        t55 = t46.stride;\n\n        if (t52.length !== t53.length) {\n          rankError();\n        }\n\n        t49 = t52.length;\n\n        while (--t49 >= 0) {\n          if (t52[t49] !== t53[t49]) {\n            lengthError();\n          }\n        }\n\n        if (!t45.empty()) {\n          t56 = t52.length - 1;\n          t47 = t45.offset;\n          t48 = t46.offset;\n          t57 = Array(t49 = t52.length);\n\n          while (--t49 >= 0) {\n            t57[t49] = 0;\n          }\n\n          while (true) {\n            xi = t50[t47];\n            yi = t51[t48];\n\n            if (!_approx(xi, yi)) {\n              r = false;\n            }\n\n            t49 = t56;\n\n            while (t49 >= 0 && t57[t49] + 1 === t52[t49]) {\n              t47 -= t57[t49] * t54[t49];\n              t48 -= t57[t49] * t55[t49];\n              t57[t49--] = 0;\n            }\n\n            if (t49 < 0) {\n              break;\n            }\n\n            t57[t49]++;\n            t47 += t54[t49];\n            t48 += t55[t49];\n          }\n        }\n\n        return r;\n      }\n    } else {\n      if (y instanceof APLArray) {\n        return false;\n      } else if (!(x != null && y != null)) {\n        return false;\n      } else {\n        if (typeof x === \'number\') {\n          x = new Complex(x);\n        }\n\n        if (typeof y === \'number\') {\n          y = new Complex(y);\n        }\n\n        if (x instanceof Complex) {\n          return y instanceof Complex && numApprox(x.re, y.re) && numApprox(x.im, y.im);\n        } else {\n          return x === y;\n        }\n      }\n    }\n  };\n\n  bool = function bool(x) {\n    if (x !== 0 && x !== 1) {\n      return domainError();\n    } else {\n      return x;\n    }\n  };\n\n  getAxisList = function getAxisList(axes, rank) {\n    var a, i, tmp58, tmp59, tmp60, x, _i, _len, _ref1, _ref2;\n\n    if (!((tmp58 = rank) === ~~tmp58 && 0 <= tmp58)) {\n      throw Error("\\"assert isInt rank, 0\\" at src/vocabulary/vhelpers.coffee:118");\n    }\n\n    if (axes == null) {\n      return [];\n    }\n\n    if (!(axes instanceof APLArray)) {\n      throw Error("\\"assert axes instanceof APLArray\\" at src/vocabulary/vhelpers.coffee:120");\n    }\n\n    if (axes.shape.length !== 1 || axes.shape[0] !== 1) {\n      syntaxError();\n    }\n\n    a = axes.unwrap();\n\n    if (a instanceof APLArray) {\n      a = a.toArray();\n\n      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {\n        x = a[i];\n\n        if (!((tmp59 = x) === ~~tmp59 && 0 <= (_ref1 = tmp59) && _ref1 < rank)) {\n          domainError();\n        }\n\n        if (__indexOf.call(a.slice(0, i), x) >= 0) {\n          domainError(\'Non-unique axes\');\n        }\n      }\n\n      return a;\n    } else if ((tmp60 = a) === ~~tmp60 && 0 <= (_ref2 = tmp60) && _ref2 < rank) {\n      return [a];\n    } else {\n      return domainError();\n    }\n  };\n\n  withIdentity = function withIdentity(x, f) {\n    f.identity = x instanceof APLArray ? x : APLArray.scalar(x);\n    return f;\n  };\n\n  adverb = function adverb(f) {\n    f.isAdverb = true;\n    return f;\n  };\n\n  conjunction = function conjunction(f) {\n    f.isConjunction = true;\n    return f;\n  };\n\n  cps = function cps(f) {\n    f.cps = true;\n    return f;\n  };\n\n  addVocabulary({\n    \'+\': withIdentity(0, pervasive({\n      monad: numeric(function (x) {\n        return x;\n      }, Complex.conjugate),\n      dyad: numeric(function (y, x) {\n        return x + y;\n      }, function (y, x) {\n        return Complex.add(x, y);\n      })\n    })),\n    \'-\': withIdentity(0, pervasive({\n      monad: numeric(function (x) {\n        return -x;\n      }, Complex.negate),\n      dyad: numeric(function (y, x) {\n        return x - y;\n      }, function (y, x) {\n        return Complex.subtract(x, y);\n      })\n    })),\n    \'×\': withIdentity(1, pervasive({\n      monad: numeric(function (x) {\n        return (x > 0) - (x < 0);\n      }, function (x) {\n        var d;\n        d = Math.sqrt(x.re * x.re + x.im * x.im);\n        return simplify(x.re / d, x.im / d);\n      }),\n      dyad: numeric(function (y, x) {\n        return x * y;\n      }, function (y, x) {\n        return Complex.multiply(x, y);\n      })\n    })),\n    \'÷\': withIdentity(1, pervasive({\n      monad: numeric(function (x) {\n        return 1 / x;\n      }, function (x) {\n        var d;\n        d = x.re * x.re + x.im * x.im;\n        return simplify(x.re / d, -x.im / d);\n      }),\n      dyad: numeric(function (y, x) {\n        if (x == y) {\n          return 1;\n        } else {\n          return x / y;\n        }\n      }, function (y, x) {\n        return Complex.divide(x, y);\n      })\n    })),\n    \'*\': withIdentity(1, pervasive({\n      monad: exp = numeric(Math.exp, Complex.exp),\n      dyad: function dyad(y, x) {\n        return Complex.pow(x, y);\n      }\n    })),\n    \'⍟\': pervasive({\n      monad: Complex.log,\n      dyad: function dyad(y, x) {\n        var _ref1;\n\n        if (_typeof(x) === (_ref1 = _typeof(y)) && _ref1 === \'number\' && x > 0 && y > 0) {\n          return Math.log(y) / Math.log(x);\n        } else {\n          return Complex.divide(Complex.log(y), Complex.log(x));\n        }\n      }\n    }),\n    \'|\': withIdentity(0, pervasive({\n      monad: numeric(function (x) {\n        return Math.abs(x);\n      }, Complex.magnitude),\n      dyad: function dyad(y, x) {\n        return Complex.residue(x, y);\n      }\n    }))\n  });\n  addVocabulary({\n    \'\\\\\': adverb(function (omega, alpha, axis) {\n      if (typeof omega === \'function\') {\n        return scan(omega, void 0, axis);\n      } else {\n        return expand(omega, alpha, axis);\n      }\n    }),\n    \'⍀\': adverb(function (omega, alpha, axis) {\n      if (axis == null) {\n        axis = APLArray.zero;\n      }\n\n      if (typeof omega === \'function\') {\n        return scan(omega, void 0, axis);\n      } else {\n        return expand(omega, alpha, axis);\n      }\n    })\n  });\n\n  scan = function scan(f, g, axis) {\n    if (!(typeof g === \'undefined\')) {\n      throw Error("\\"assert typeof g is \'undefined\'\\" at src/vocabulary/backslash.coffee:44");\n    }\n\n    return function (omega, alpha) {\n      if (!(alpha == null)) {\n        throw Error("\\"assert not ⍺?\\" at src/vocabulary/backslash.coffee:46");\n      }\n\n      if (!omega.shape.length) {\n        return omega;\n      }\n\n      axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;\n      return omega.map(function (x, indices) {\n        var a, index, j, p, y, _i, _j, _len, _ref1;\n\n        p = omega.offset;\n\n        for (a = _i = 0, _len = indices.length; _i < _len; a = ++_i) {\n          index = indices[a];\n          p += index * omega.stride[a];\n        }\n\n        if (!(x instanceof APLArray)) {\n          x = APLArray.scalar(x);\n        }\n\n        for (j = _j = 0, _ref1 = indices[axis]; _j < _ref1; j = _j += 1) {\n          p -= omega.stride[axis];\n          y = omega.data[p];\n\n          if (!(y instanceof APLArray)) {\n            y = APLArray.scalar(y);\n          }\n\n          x = f(x, y);\n        }\n\n        if (!x.shape.length) {\n          x = x.unwrap();\n        }\n\n        return x;\n      });\n    };\n  };\n\n  expand = function expand(omega, alpha, axis) {\n    var a, b, data, filler, i, indices, p, shape, tmp61, x, _i, _len, _ref1;\n\n    if (!omega.shape.length) {\n      nonceError(\'Expand of scalar not implemented\');\n    }\n\n    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;\n\n    if (alpha.shape.length > 1) {\n      rankError();\n    }\n\n    a = alpha.toArray();\n    shape = omega.shape.slice(0);\n    shape[axis] = a.length;\n    b = [];\n    i = 0;\n\n    for (_i = 0, _len = a.length; _i < _len; _i++) {\n      x = a[_i];\n\n      if (!((tmp61 = x) === ~~tmp61 && 0 <= (_ref1 = tmp61) && _ref1 < 2)) {\n        domainError();\n      }\n\n      b.push(x > 0 ? i++ : null);\n    }\n\n    if (i !== omega.shape[axis]) {\n      lengthError();\n    }\n\n    data = [];\n\n    if (shape[axis] !== 0 && !omega.empty()) {\n      filler = omega.getPrototype();\n      p = omega.offset;\n      indices = repeat([0], shape.length);\n\n      while (true) {\n        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;\n        data.push(x);\n        i = shape.length - 1;\n\n        while (i >= 0 && indices[i] + 1 === shape[i]) {\n          if (i !== axis) {\n            p -= omega.stride[i] * indices[i];\n          }\n\n          indices[i--] = 0;\n        }\n\n        if (i < 0) {\n          break;\n        }\n\n        if (i !== axis) {\n          p += omega.stride[i];\n        }\n\n        indices[i]++;\n      }\n    }\n\n    return new APLArray(data, shape);\n  };\n\n  addVocabulary({\n    \'○\': pervasive({\n      monad: numeric(function (x) {\n        return Math.PI * x;\n      }, function (x) {\n        return new Complex(Math.PI * x.re, Math.PI * x.im);\n      }),\n      dyad: function dyad(x, i) {\n        var a, b, t;\n\n        if (typeof x === \'number\') {\n          switch (i) {\n            case -12:\n              return Complex.exp(simplify(0, x));\n\n            case -11:\n              return simplify(0, x);\n\n            case -10:\n              return x;\n\n            case -9:\n              return x;\n\n            case -8:\n              return simplify(0, -Math.sqrt(1 + x * x));\n\n            case -7:\n              return Complex.atanh(x);\n\n            case -6:\n              return Complex.acosh(x);\n\n            case -5:\n              return Complex.asinh(x);\n\n            case -4:\n              t = Complex.sqrt(x * x - 1);\n\n              if (x < -1) {\n                return -t;\n              } else {\n                return t;\n              }\n\n              break;\n\n            case -3:\n              return Complex.atan(x);\n\n            case -2:\n              return Complex.acos(x);\n\n            case -1:\n              return Complex.asin(x);\n\n            case 0:\n              return Complex.sqrt(1 - x * x);\n\n            case 1:\n              return Math.sin(x);\n\n            case 2:\n              return Math.cos(x);\n\n            case 3:\n              return Math.tan(x);\n\n            case 4:\n              return Math.sqrt(1 + x * x);\n\n            case 5:\n              a = Math.exp(x);\n              b = 1 / a;\n              return 0.5 * (a - b);\n\n            case 6:\n              a = Math.exp(x);\n              b = 1 / a;\n              return 0.5 * (a + b);\n\n            case 7:\n              a = Math.exp(x);\n              b = 1 / a;\n              return (a - b) / (a + b);\n\n            case 8:\n              return Complex.sqrt(-1 - x * x);\n\n            case 9:\n              return x;\n\n            case 10:\n              return Math.abs(x);\n\n            case 11:\n              return 0;\n\n            case 12:\n              return 0;\n\n            default:\n              return domainError(\'Unknown circular or hyperbolic function \' + i);\n          }\n        } else if (x instanceof Complex) {\n          switch (i) {\n            case -12:\n              return Complex.exp(simplify(-x.im, x.re));\n\n            case -11:\n              return Complex.itimes(x);\n\n            case -10:\n              return Complex.conjugate(x);\n\n            case -9:\n              return x;\n\n            case -8:\n              t = Complex.subtract(-1, Complex.multiply(x, x));\n              return Complex.negate(Complex.sqrt(t));\n\n            case -7:\n              return Complex.atanh(x);\n\n            case -6:\n              return Complex.acosh(x);\n\n            case -5:\n              return Complex.asinh(x);\n\n            case -4:\n              if (x.re === -1 && x.im === 0) {\n                return 0;\n              } else {\n                a = Complex.add(x, 1);\n                b = Complex.subtract(x, 1);\n                return Complex.multiply(a, Complex.sqrt(Complex.divide(b, a)));\n              }\n\n              break;\n\n            case -3:\n              return Complex.atan(x);\n\n            case -2:\n              return Complex.acos(x);\n\n            case -1:\n              return Complex.asin(x);\n\n            case 0:\n              return Complex.sqrt(Complex.subtract(1, Complex.multiply(x, x)));\n\n            case 1:\n              return Complex.sin(x);\n\n            case 2:\n              return Complex.cos(x);\n\n            case 3:\n              return Complex.tan(x);\n\n            case 4:\n              return Complex.sqrt(Complex.add(1, Complex.multiply(x, x)));\n\n            case 5:\n              return Complex.sinh(x);\n\n            case 6:\n              return Complex.cosh(x);\n\n            case 7:\n              return Complex.tanh(x);\n\n            case 8:\n              return Complex.sqrt(Complex.subtract(-1, Complex.multiply(x, x)));\n\n            case 9:\n              return x.re;\n\n            case 10:\n              return Complex.magnitude(x);\n\n            case 11:\n              return x.im;\n\n            case 12:\n              return Complex.direction(x);\n\n            default:\n              return domainError(\'Unknown circular or hyperbolic function \' + i);\n          }\n        } else {\n          return domainError();\n        }\n      }\n    })\n  });\n  addVocabulary({\n    \',\': function _(omega, alpha, axis) {\n      var a, data, i, nAxes, p, pIndices, q, r, rStride, s, shape, stride, tmp62, tmp63, tmp64, tmp65, tmp66, tmp67, tmp68, _i, _j, _ref1, _ref2, _ref3;\n\n      if (alpha) {\n        nAxes = Math.max(alpha.shape.length, omega.shape.length);\n\n        if (axis) {\n          axis = axis.unwrap();\n\n          if (typeof axis !== \'number\') {\n            domainError();\n          }\n\n          if (nAxes && !(-1 <= axis && axis < nAxes)) {\n            rankError();\n          }\n        } else {\n          axis = nAxes - 1;\n        }\n\n        if (alpha.shape.length === (_ref1 = omega.shape.length) && _ref1 === 0) {\n          return new APLArray([alpha.unwrap(), omega.unwrap()]);\n        } else if (!alpha.shape.length) {\n          s = omega.shape.slice(0);\n\n          if ((tmp62 = axis) === ~~tmp62) {\n            s[axis] = 1;\n          }\n\n          alpha = new APLArray([alpha.unwrap()], s, repeat([0], omega.shape.length));\n        } else if (!omega.shape.length) {\n          s = alpha.shape.slice(0);\n\n          if ((tmp63 = axis) === ~~tmp63) {\n            s[axis] = 1;\n          }\n\n          omega = new APLArray([omega.unwrap()], s, repeat([0], alpha.shape.length));\n        } else if (alpha.shape.length + 1 === omega.shape.length) {\n          if (!((tmp64 = axis) === ~~tmp64)) {\n            rankError();\n          }\n\n          shape = alpha.shape.slice(0);\n          shape.splice(axis, 0, 1);\n          stride = alpha.stride.slice(0);\n          stride.splice(axis, 0, 0);\n          alpha = new APLArray(alpha.data, shape, stride, alpha.offset);\n        } else if (alpha.shape.length === omega.shape.length + 1) {\n          if (!((tmp65 = axis) === ~~tmp65)) {\n            rankError();\n          }\n\n          shape = omega.shape.slice(0);\n          shape.splice(axis, 0, 1);\n          stride = omega.stride.slice(0);\n          stride.splice(axis, 0, 0);\n          omega = new APLArray(omega.data, shape, stride, omega.offset);\n        } else if (alpha.shape.length !== omega.shape.length) {\n          rankError();\n        }\n\n        if (!(alpha.shape.length === omega.shape.length)) {\n          throw Error("\\"assert ⍴⍴(⍺) is ⍴⍴(⍵)\\" at src/vocabulary/comma.coffee:59");\n        }\n\n        for (i = _i = 0, _ref2 = alpha.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {\n          if (i !== axis && alpha.shape[i] !== omega.shape[i]) {\n            lengthError();\n          }\n        }\n\n        shape = alpha.shape.slice(0);\n\n        if ((tmp66 = axis) === ~~tmp66) {\n          shape[axis] += omega.shape[axis];\n        } else {\n          shape.splice(Math.ceil(axis), 0, 2);\n        }\n\n        data = Array(prod(shape));\n        stride = Array(shape.length);\n        stride[shape.length - 1] = 1;\n\n        for (i = _j = _ref3 = shape.length - 2; _j >= 0; i = _j += -1) {\n          stride[i] = stride[i + 1] * shape[i + 1];\n        }\n\n        if ((tmp67 = axis) === ~~tmp67) {\n          rStride = stride;\n        } else {\n          rStride = stride.slice(0);\n          rStride.splice(Math.ceil(axis), 1);\n        }\n\n        if (!alpha.empty()) {\n          r = 0;\n          p = alpha.offset;\n          pIndices = repeat([0], alpha.shape.length);\n\n          while (true) {\n            data[r] = alpha.data[p];\n            a = pIndices.length - 1;\n\n            while (a >= 0 && pIndices[a] + 1 === alpha.shape[a]) {\n              p -= pIndices[a] * alpha.stride[a];\n              r -= pIndices[a] * rStride[a];\n              pIndices[a--] = 0;\n            }\n\n            if (a < 0) {\n              break;\n            }\n\n            p += alpha.stride[a];\n            r += rStride[a];\n            pIndices[a]++;\n          }\n        }\n\n        if (!omega.empty()) {\n          r = (tmp68 = axis) === ~~tmp68 ? stride[axis] * alpha.shape[axis] : stride[Math.ceil(axis)];\n          q = omega.offset;\n          pIndices = repeat([0], omega.shape.length);\n\n          while (true) {\n            data[r] = omega.data[q];\n            a = pIndices.length - 1;\n\n            while (a >= 0 && pIndices[a] + 1 === omega.shape[a]) {\n              q -= pIndices[a] * omega.stride[a];\n              r -= pIndices[a] * rStride[a];\n              pIndices[a--] = 0;\n            }\n\n            if (a < 0) {\n              break;\n            }\n\n            q += omega.stride[a];\n            r += rStride[a];\n            pIndices[a]++;\n          }\n        }\n\n        return new APLArray(data, shape, stride);\n      } else {\n        return new APLArray(omega.toArray());\n      }\n    }\n  });\n  addVocabulary({\n    \'=\': withIdentity(1, pervasive({\n      dyad: eq = function eq(y, x) {\n        if (x instanceof Complex && y instanceof Complex) {\n          return +(x.re === y.re && x.im === y.im);\n        } else {\n          if (thisCT == 0 || typeof x == "string" || typeof y == "string") {\n            return +(x === y);\n          } else {\n            return +TolerantEqual(x, y);\n          }\n        }\n      }\n    })),\n    \'≠\': withIdentity(0, pervasive({\n      dyad: function dyad(y, x) {\n        return 1 - eq(y, x);\n      }\n    })),\n    \'<\': withIdentity(0, pervasive({\n      dyad: function dyad(y, x, t69) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          if (thisCT == 0) {\n            return +(x < y);\n          } else {\n            return +(x < y && !TolerantEqual(x, y));\n          }\n\n          return;\n        } else {\n          return domainError();\n        }\n      }\n    })),\n    \'>\': withIdentity(0, pervasive({\n      dyad: function dyad(y, x, t70) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          if (thisCT == 0) {\n            return +(x > y);\n          } else {\n            return +(x > y && !TolerantEqual(x, y));\n          }\n        } else {\n          return domainError();\n        }\n      }\n    })),\n    \'≤\': withIdentity(1, pervasive({\n      dyad: function dyad(y, x, t71) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          if (thisCT == 0) {\n            return +(x <= y);\n          } else {\n            return +(x <= y || TolerantEqual(x, y));\n          }\n        } else {\n          return domainError();\n        }\n      }\n    })),\n    \'≥\': withIdentity(1, pervasive({\n      dyad: function dyad(y, x, t72) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          if (thisCT == 0) {\n            return +(x >= y);\n          } else {\n            return +(x >= y || TolerantEqual(x, y));\n          }\n        } else {\n          return domainError();\n        }\n      }\n    })),\n    \'≡\': function _(omega, alpha) {\n      if (alpha) {\n        return APLArray.bool[+_match(omega, alpha)];\n      } else {\n        return new APLArray([_depthOf(omega)], []);\n      }\n    },\n    \'≢\': function _(omega, alpha) {\n      if (alpha) {\n        return APLArray.bool[+!_match(omega, alpha)];\n      } else {\n        if (omega.shape.length) {\n          return new APLArray([omega.shape[0]], []);\n        } else {\n          return APLArray.one;\n        }\n      }\n    }\n  });\n\n  _depthOf = function depthOf(x) {\n    var r, t73, t74, t75, t76, t77, t78, t79, t80, y;\n\n    if (x instanceof APLArray) {\n      if (!x.shape.length && !(x.data[0] instanceof APLArray)) {\n        return 0;\n      }\n\n      r = 0;\n      t73 = x;\n\n      if (!t73.empty()) {\n        t75 = t73.data;\n        t76 = t73.shape;\n        t77 = t73.stride;\n        t78 = t76.length - 1;\n        t80 = t73.offset;\n        t79 = [];\n        t74 = t76.length;\n\n        while (--t74 >= 0) {\n          t79.push(0);\n        }\n\n        while (true) {\n          y = t75[t80];\n          r = Math.max(r, _depthOf(y));\n          t74 = t78;\n\n          while (t74 >= 0 && t79[t74] + 1 === t76[t74]) {\n            t80 -= t79[t74] * t77[t74];\n            t79[t74--] = 0;\n          }\n\n          if (t74 < 0) {\n            break;\n          }\n\n          t79[t74]++;\n          t80 += t77[t74];\n        }\n      }\n\n      return r + 1;\n    } else {\n      return 0;\n    }\n  };\n\n  addVocabulary({\n    \'∘\': conjunction(function (g, f) {\n      if (typeof f === \'function\') {\n        if (typeof g === \'function\') {\n          return function (omega, alpha) {\n            return f(g(omega), alpha);\n          };\n        } else {\n          return function (omega, alpha) {\n            if (!(alpha == null)) {\n              throw Error("\\"assert not ⍺?\\" at src/vocabulary/compose.coffee:20");\n            }\n\n            return f(g, omega);\n          };\n        }\n      } else {\n        if (!(typeof g === \'function\')) {\n          throw Error("\\"assert typeof g is \'function\'\\" at src/vocabulary/compose.coffee:23");\n        }\n\n        return function (omega, alpha) {\n          if (!(alpha == null)) {\n            throw Error("\\"assert not ⍺?\\" at src/vocabulary/compose.coffee:25");\n          }\n\n          return g(omega, f);\n        };\n      }\n    })\n  });\n  addVocabulary({\n    \'∪\': function _(omega, alpha) {\n      var a, data, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90, t91, t92, t93, t94, t95, t96, x, _i, _len, _ref1;\n\n      if (alpha) {\n        data = [];\n        _ref1 = [alpha, omega];\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          a = _ref1[_i];\n\n          if (a.shape.length > 1) {\n            rankError();\n          }\n\n          t81 = a;\n\n          if (!t81.empty()) {\n            t83 = t81.data;\n            t84 = t81.shape;\n            t85 = t81.stride;\n            t86 = t84.length - 1;\n            t88 = t81.offset;\n            t87 = [];\n            t82 = t84.length;\n\n            while (--t82 >= 0) {\n              t87.push(0);\n            }\n\n            while (true) {\n              x = t83[t88];\n\n              if (!contains(data, x)) {\n                data.push(x);\n              }\n\n              t82 = t86;\n\n              while (t82 >= 0 && t87[t82] + 1 === t84[t82]) {\n                t88 -= t87[t82] * t85[t82];\n                t87[t82--] = 0;\n              }\n\n              if (t82 < 0) {\n                break;\n              }\n\n              t87[t82]++;\n              t88 += t85[t82];\n            }\n          }\n        }\n\n        return new APLArray(data);\n      } else {\n        data = [];\n        t89 = omega;\n\n        if (!t89.empty()) {\n          t91 = t89.data;\n          t92 = t89.shape;\n          t93 = t89.stride;\n          t94 = t92.length - 1;\n          t96 = t89.offset;\n          t95 = [];\n          t90 = t92.length;\n\n          while (--t90 >= 0) {\n            t95.push(0);\n          }\n\n          while (true) {\n            x = t91[t96];\n\n            if (!contains(data, x)) {\n              data.push(x);\n            }\n\n            t90 = t94;\n\n            while (t90 >= 0 && t95[t90] + 1 === t92[t90]) {\n              t96 -= t95[t90] * t93[t90];\n              t95[t90--] = 0;\n            }\n\n            if (t90 < 0) {\n              break;\n            }\n\n            t95[t90]++;\n            t96 += t93[t90];\n          }\n        }\n\n        return new APLArray(data);\n      }\n    },\n    \'∩\': function _(omega, alpha) {\n      var b, data, x, _i, _len, _ref1;\n\n      if (alpha) {\n        data = [];\n        b = omega.toArray();\n        _ref1 = alpha.toArray();\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          x = _ref1[_i];\n\n          if (contains(b, x)) {\n            data.push(x);\n          }\n        }\n\n        return new APLArray(data);\n      } else {\n        return nonceError();\n      }\n    }\n  });\n\n  contains = function contains(a, x) {\n    var y, _i, _len;\n\n    if (!(a instanceof Array)) {\n      throw Error("\\"assert a instanceof Array\\" at src/vocabulary/cupcap.coffee:56");\n    }\n\n    for (_i = 0, _len = a.length; _i < _len; _i++) {\n      y = a[_i];\n\n      if (_match(x, y)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  addVocabulary({\n    \'⊥\': function _(omega, alpha) {\n      var a, b, data, firstDimB, i, j, k, lastDimA, x, y, z, _i, _j, _k, _ref1, _ref2, _ref3;\n\n      if (!alpha) {\n        throw Error("\\"assert ⍺\\" at src/vocabulary/decode.coffee:53");\n      }\n\n      if (!alpha.shape.length) {\n        alpha = new APLArray([alpha.unwrap()]);\n      }\n\n      if (!omega.shape.length) {\n        omega = new APLArray([omega.unwrap()]);\n      }\n\n      lastDimA = alpha.shape[alpha.shape.length - 1];\n      firstDimB = omega.shape[0];\n\n      if (lastDimA !== 1 && firstDimB !== 1 && lastDimA !== firstDimB) {\n        lengthError();\n      }\n\n      a = alpha.toArray();\n      b = omega.toArray();\n      data = [];\n\n      for (i = _i = 0, _ref1 = a.length / lastDimA; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {\n        for (j = _j = 0, _ref2 = b.length / firstDimB; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {\n          x = a.slice(i * lastDimA, (i + 1) * lastDimA);\n\n          y = function () {\n            var _k, _results;\n\n            _results = [];\n\n            for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {\n              _results.push(b[j + k * (b.length / firstDimB)]);\n            }\n\n            return _results;\n          }();\n\n          if (x.length === 1) {\n            x = function () {\n              var _k, _ref3, _results;\n\n              _results = [];\n\n              for (_k = 0, _ref3 = y.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; 0 <= _ref3 ? _k++ : _k--) {\n                _results.push(x[0]);\n              }\n\n              return _results;\n            }();\n          }\n\n          if (y.length === 1) {\n            y = function () {\n              var _k, _ref3, _results;\n\n              _results = [];\n\n              for (_k = 0, _ref3 = x.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; 0 <= _ref3 ? _k++ : _k--) {\n                _results.push(y[0]);\n              }\n\n              return _results;\n            }();\n          }\n\n          z = y[0];\n\n          for (k = _k = 1, _ref3 = y.length; 1 <= _ref3 ? _k < _ref3 : _k > _ref3; k = 1 <= _ref3 ? ++_k : --_k) {\n            z = z * x[k] + y[k];\n          }\n\n          data.push(z);\n        }\n      }\n\n      return new APLArray(data, alpha.shape.slice(0, -1).concat(omega.shape.slice(1)));\n    }\n  });\n  addVocabulary({\n    \'.\': conjunction(function (g, f) {\n      if (f === vocabulary[\'∘\']) {\n        return outerProduct(g);\n      } else {\n        return innerProduct(g, f);\n      }\n    })\n  });\n\n  outerProduct = function outerProduct(f) {\n    if (!(typeof f === \'function\')) {\n      throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/dot.coffee:39");\n    }\n\n    return function (omega, alpha) {\n      var a, b, data, x, y, z, _i, _j, _len, _len1;\n\n      if (!alpha) {\n        syntaxError(\'Adverb ∘. (Outer product) can be applied to dyadic verbs only\');\n      }\n\n      a = alpha.toArray();\n      b = omega.toArray();\n      data = [];\n\n      for (_i = 0, _len = a.length; _i < _len; _i++) {\n        x = a[_i];\n\n        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {\n          y = b[_j];\n\n          if (!(x instanceof APLArray)) {\n            x = APLArray.scalar(x);\n          }\n\n          if (!(y instanceof APLArray)) {\n            y = APLArray.scalar(y);\n          }\n\n          z = f(y, x);\n\n          if (!z.shape.length) {\n            z = z.unwrap();\n          }\n\n          data.push(z);\n        }\n      }\n\n      return new APLArray(data, alpha.shape.concat(omega.shape));\n    };\n  };\n\n  innerProduct = function innerProduct(g, f) {\n    var F, G;\n    F = vocabulary[\'¨\'](reduce(f));\n    G = outerProduct(g);\n    return function (omega, alpha) {\n      if (!alpha.shape.length) {\n        alpha = new APLArray([alpha.unwrap()]);\n      }\n\n      if (!omega.shape.length) {\n        omega = new APLArray([omega.unwrap()]);\n      }\n\n      return F(G(vocabulary[\'⊂\'](omega, void 0, new APLArray([0])), vocabulary[\'⊂\'](alpha, void 0, new APLArray([alpha.shape.length - 1]))));\n    };\n  };\n\n  addVocabulary({\n    \'↓\': function _(omega, alpha, axis) {\n      var a, array, data, i, ishape, obound, offset, oshape, shape, tmp97, x, _i, _j, _k, _len, _len1;\n\n      if (alpha) {\n        if (alpha.shape.length > 1) {\n          rankError();\n        }\n\n        a = alpha.toArray();\n\n        for (_i = 0, _len = a.length; _i < _len; _i++) {\n          x = a[_i];\n\n          if (!((tmp97 = x) === ~~tmp97)) {\n            domainError();\n          }\n        }\n\n        if (!omega.shape.length) {\n          omega = new APLArray(omega.data, repeat([1], a.length), repeat([0], a.length), omega.offset);\n        } else {\n          if (a.length > omega.shape.length) {\n            rankError();\n          }\n        }\n\n        shape = omega.shape.slice(0);\n        offset = omega.offset;\n\n        for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {\n          x = a[i];\n          shape[i] = Math.max(0, omega.shape[i] - Math.abs(x));\n\n          if (x > 0) {\n            offset += x * omega.stride[i];\n          }\n        }\n\n        if (prod(shape) === 0) {\n          return new APLArray([], shape);\n        } else {\n          return new APLArray(omega.data, shape, omega.stride, offset);\n        }\n      } else {\n        if (!omega.shape.length) {\n          nonceError(\'Split of scalar not implemented\');\n        }\n\n        oshape = omega.shape.slice(0, omega.shape.length - 1);\n        obound = oshape.reduce(function (a, b) {\n          return a * b;\n        }, 1);\n        ishape = omega.shape[omega.shape.length - 1];\n        array = omega.toArray();\n        data = [];\n\n        for (i = _k = 0; 0 <= obound ? _k < obound : _k > obound; i = 0 <= obound ? ++_k : --_k) {\n          offset = i * ishape;\n          data.push(new APLArray(array.slice(offset, offset + ishape)));\n        }\n\n        return new APLArray(data, oshape);\n      }\n    }\n  });\n  addVocabulary({\n    \'¨\': adverb(function (f, g) {\n      if (!(typeof f === \'function\')) {\n        throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/each.coffee:18");\n      }\n\n      if (!(typeof g === \'undefined\')) {\n        throw Error("\\"assert typeof g is \'undefined\'\\" at src/vocabulary/each.coffee:19");\n      }\n\n      return function (omega, alpha) {\n        var x, y;\n\n        if (!alpha) {\n          return omega.map(function (x) {\n            var r;\n\n            if (!(x instanceof APLArray)) {\n              x = new APLArray([x], []);\n            }\n\n            r = f(x);\n\n            if (!(r instanceof APLArray)) {\n              throw Error("\\"assert r instanceof APLArray\\" at src/vocabulary/each.coffee:25");\n            }\n\n            if (r.shape.length) {\n              return r;\n            } else {\n              return r.unwrap();\n            }\n          });\n        } else if (arrayEquals(alpha.shape, omega.shape)) {\n          return omega.map2(alpha, function (x, y) {\n            var r;\n\n            if (!(x instanceof APLArray)) {\n              x = new APLArray([x], []);\n            }\n\n            if (!(y instanceof APLArray)) {\n              y = new APLArray([y], []);\n            }\n\n            r = f(x, y);\n\n            if (!(r instanceof APLArray)) {\n              throw Error("\\"assert r instanceof APLArray\\" at src/vocabulary/each.coffee:32");\n            }\n\n            if (r.shape.length) {\n              return r;\n            } else {\n              return r.unwrap();\n            }\n          });\n        } else if (alpha.isSingleton()) {\n          y = alpha.data[0] instanceof APLArray ? alpha.unwrap() : alpha;\n          return omega.map(function (x) {\n            var r;\n\n            if (!(x instanceof APLArray)) {\n              x = new APLArray([x], []);\n            }\n\n            r = f(x, y);\n\n            if (!(r instanceof APLArray)) {\n              throw Error("\\"assert r instanceof APLArray\\" at src/vocabulary/each.coffee:39");\n            }\n\n            if (r.shape.length) {\n              return r;\n            } else {\n              return r.unwrap();\n            }\n          });\n        } else if (omega.isSingleton()) {\n          x = omega.data[0] instanceof APLArray ? omega.unwrap() : omega;\n          return alpha.map(function (y) {\n            var r;\n\n            if (!(y instanceof APLArray)) {\n              y = new APLArray([y], []);\n            }\n\n            r = f(x, y);\n\n            if (!(r instanceof APLArray)) {\n              throw Error("\\"assert r instanceof APLArray\\" at src/vocabulary/each.coffee:46");\n            }\n\n            if (r.shape.length) {\n              return r;\n            } else {\n              return r.unwrap();\n            }\n          });\n        } else {\n          return lengthError();\n        }\n      };\n    })\n  });\n  addVocabulary({\n    \'⊤\': function _(omega, alpha) {\n      var a, b, data, i, isNeg, j, k, m, n, shape, x, y, z, _i, _j, _k, _len, _ref;\n\n      if (!alpha) {\n        throw Error("\\"assert ⍺\\" at src/vocabulary/encode.coffee:40");\n      }\n\n      a = alpha.toArray();\n      b = omega.toArray();\n      shape = alpha.shape.concat(omega.shape);\n      data = Array(prod(shape));\n      n = alpha.shape.length ? alpha.shape[0] : 1;\n      m = a.length / n;\n\n      for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {\n        for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {\n          y = b[j];\n\n          for (k = _k = n - 1; _k >= 0; k = _k += -1) {\n            x = a[k * m + i];\n\n            if (Complex.isZero(x)) {\n              data[(k * m + i) * b.length + j] = y;\n              y = 0;\n            } else {\n              z = Complex.residue(x, y);\n              data[(k * m + i) * b.length + j] = z;\n\n              if (_typeof(y) === (_ref = _typeof(z)) && _ref === \'number\') {\n                y = (y - z) / x;\n              } else {\n                y = Complex.divide(Complex.subtract(y, z), x);\n              }\n            }\n          }\n        }\n      }\n\n      return new APLArray(data, shape);\n    }\n  });\n  addVocabulary({\n    \'∊\': function _(omega, alpha) {\n      var a, data;\n\n      if (alpha) {\n        a = omega.toArray();\n        return alpha.map(function (x) {\n          var y, _i, _len;\n\n          for (_i = 0, _len = a.length; _i < _len; _i++) {\n            y = a[_i];\n\n            if (_match(x, y)) {\n              return 1;\n            }\n          }\n\n          return 0;\n        });\n      } else {\n        data = [];\n\n        _enlist(omega, data);\n\n        return new APLArray(data);\n      }\n    }\n  });\n\n  _enlist = function enlist(x, r) {\n    var t100, t101, t102, t103, t104, t105, t98, t99, y, _results;\n\n    if (x instanceof APLArray) {\n      t98 = x;\n\n      if (!t98.empty()) {\n        t100 = t98.data;\n        t101 = t98.shape;\n        t102 = t98.stride;\n        t103 = t101.length - 1;\n        t105 = t98.offset;\n        t104 = [];\n        t99 = t101.length;\n\n        while (--t99 >= 0) {\n          t104.push(0);\n        }\n\n        _results = [];\n\n        while (true) {\n          y = t100[t105];\n\n          _enlist(y, r);\n\n          t99 = t103;\n\n          while (t99 >= 0 && t104[t99] + 1 === t101[t99]) {\n            t105 -= t104[t99] * t102[t99];\n            t104[t99--] = 0;\n          }\n\n          if (t99 < 0) {\n            break;\n          }\n\n          t104[t99]++;\n\n          _results.push(t105 += t102[t99]);\n        }\n\n        return _results;\n      }\n    } else {\n      return r.push(x);\n    }\n  };\n\n  addVocabulary({\n    \'!\': withIdentity(1, pervasive({\n      monad: function monad(x, t107, t108) {\n        var tmp106;\n\n        if (typeof x === \'number\' && (t107 == null || typeof t107 === \'number\')) {\n          if (!((tmp106 = x) === ~~tmp106)) {\n            return _Γ(x + 1);\n          } else if (x < 0) {\n            return domainError();\n          } else if (x < smallFactorials.length) {\n            return smallFactorials[x];\n          } else {\n            return Math.round(_Γ(x + 1));\n          }\n        } else {\n          return domainError();\n        }\n      },\n      dyad: _Beta = function Beta(n, k, t111) {\n        var r, tmp109, tmp110;\n\n        if (typeof n === \'number\' && (k == null || typeof k === \'number\')) {\n          r = function () {\n            switch (4 * negInt(k) + 2 * negInt(n) + negInt(n - k)) {\n              case 0x0:\n                return Math.exp(lnΓ(n + 1) - lnΓ(k + 1) - lnΓ(n - k + 1));\n\n              case 0x1:\n                return 0;\n\n              case 0x2:\n                return domainError();\n\n              case 0x3:\n                return Math.pow(-1, k) * _Beta(k - n - 1, k);\n\n              case 0x4:\n                return 0;\n\n              case 0x5:\n                break;\n\n              case 0x6:\n                return Math.pow(-1, n - k) * _Beta(Math.abs(k + 1), Math.abs(n + 1));\n\n              case 0x7:\n                return 0;\n            }\n          }();\n\n          if ((tmp109 = n) === ~~tmp109 && (tmp110 = k) === ~~tmp110) {\n            return Math.round(r);\n          } else {\n            return r;\n          }\n        } else {\n          return domainError();\n        }\n      }\n    }))\n  });\n\n  negInt = function negInt(x) {\n    var tmp112;\n    return (tmp112 = x) === ~~tmp112 && x < 0;\n  };\n\n  smallFactorials = function () {\n    var i, x;\n    return [x = 1].concat(function () {\n      var _i, _results;\n\n      _results = [];\n\n      for (i = _i = 1; _i <= 25; i = ++_i) {\n        _results.push(x *= i);\n      }\n\n      return _results;\n    }());\n  }();\n\n  _ref1 = function () {\n    var g, g_ln, p, p_ln;\n    g = 7;\n    p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];\n    g_ln = 607 / 128;\n    p_ln = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];\n    return {\n      lnΓ: function lnΓ(z) {\n        var i, t, x, _i, _ref1;\n\n        if (z < 0) {\n          return NaN;\n        }\n\n        x = p_ln[0];\n\n        for (i = _i = _ref1 = p_ln.length - 1; _i > 0; i = _i += -1) {\n          x += p_ln[i] / (z + i);\n        }\n\n        t = z + g_ln + .5;\n        return .5 * Math.log(2 * Math.PI) + (z + .5) * Math.log(t) - t + Math.log(x) - Math.log(z);\n      },\n      Γ: function Γ(z) {\n        var i, t, x, _i, _ref1;\n\n        if (z < 0.5) {\n          return Math.PI / (Math.sin(Math.PI * z) * _Γ(1 - z));\n        } else if (z > 100) {\n          return Math.exp(lnΓ(z));\n        } else {\n          z--;\n          x = p[0];\n\n          for (i = _i = 1, _ref1 = g + 2; _i < _ref1; i = _i += 1) {\n            x += p[i] / (z + i);\n          }\n\n          t = z + g + .5;\n          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;\n        }\n      }\n    };\n  }(), _Γ = _ref1.Γ, lnΓ = _ref1.lnΓ;\n  addVocabulary({\n    \'⍎\': function _(omega, alpha) {\n      var c, s, t113, t114, t115, t116, t117, t118, t119, t120;\n\n      if (alpha) {\n        return EXECUTE(omega, alpha);\n      } else {\n        s = \'\';\n        t113 = omega;\n\n        if (!t113.empty()) {\n          t115 = t113.data;\n          t116 = t113.shape;\n          t117 = t113.stride;\n          t118 = t116.length - 1;\n          t120 = t113.offset;\n          t119 = [];\n          t114 = t116.length;\n\n          while (--t114 >= 0) {\n            t119.push(0);\n          }\n\n          while (true) {\n            c = t115[t120];\n\n            if (typeof c !== \'string\') {\n              domainError();\n            }\n\n            s += c;\n            t114 = t118;\n\n            while (t114 >= 0 && t119[t114] + 1 === t116[t114]) {\n              t120 -= t119[t114] * t117[t114];\n              t119[t114--] = 0;\n            }\n\n            if (t114 < 0) {\n              break;\n            }\n\n            t119[t114]++;\n            t120 += t117[t114];\n          }\n        }\n\n        return exec(s);\n      }\n    }\n  });\n  addVocabulary({\n    \'⍷\': function _(omega, alpha) {\n      var a, d, data, findShape, i, indices, p, q, stride, _i, _ref2;\n\n      if (alpha) {\n        if (alpha.shape.length > omega.shape.length) {\n          return new APLArray([0], omega.shape, repeat([0], omega.shape.length));\n        }\n\n        if (alpha.shape.length < omega.shape.length) {\n          alpha = new APLArray(alpha.data, repeat([1], omega.shape.length - alpha.shape.length).concat(alpha.shape), repeat([0], omega.shape.length - alpha.shape.length).concat(alpha.stride), alpha.offset);\n        }\n\n        if (prod(alpha.shape) === 0) {\n          return new APLArray([1], omega.shape, repeat([0], omega.shape.length));\n        }\n\n        findShape = [];\n\n        for (i = _i = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {\n          d = omega.shape[i] - alpha.shape[i] + 1;\n\n          if (d <= 0) {\n            return new APLArray([0], omega.shape, repeat([0], omega.shape.length));\n          }\n\n          findShape.push(d);\n        }\n\n        stride = strideForShape(omega.shape);\n        data = repeat([0], prod(omega.shape));\n        p = omega.offset;\n        q = 0;\n        indices = repeat([0], findShape.length);\n\n        while (true) {\n          data[q] = +_match(alpha, new APLArray(omega.data, alpha.shape, omega.stride, p));\n          a = findShape.length - 1;\n\n          while (a >= 0 && indices[a] + 1 === findShape[a]) {\n            p -= indices[a] * omega.stride[a];\n            q -= indices[a] * stride[a];\n            indices[a--] = 0;\n          }\n\n          if (a < 0) {\n            break;\n          }\n\n          p += omega.stride[a];\n          q += stride[a];\n          indices[a]++;\n        }\n\n        return new APLArray(data, omega.shape);\n      } else {\n        return nonceError();\n      }\n    }\n  });\n  addVocabulary({\n    \'⌊\': withIdentity(Infinity, pervasive({\n      monad: Complex.floor,\n      dyad: function dyad(y, x, t121) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          return Math.min(y, x);\n        } else {\n          return domainError();\n        }\n      }\n    })),\n    \'⌈\': withIdentity(-Infinity, pervasive({\n      monad: Complex.ceil,\n      dyad: function dyad(y, x, t122) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          return Math.max(y, x);\n        } else {\n          return domainError();\n        }\n      }\n    }))\n  });\n  addVocabulary({\n    _fork1: function _fork1(h, g) {\n      if (!(typeof h === \'function\')) {\n        throw Error("\\"assert typeof h is \'function\'\\" at src/vocabulary/fork.coffee:20");\n      }\n\n      if (!(typeof g === \'function\')) {\n        throw Error("\\"assert typeof g is \'function\'\\" at src/vocabulary/fork.coffee:21");\n      }\n\n      return [h, g];\n    },\n    _fork2: function _fork2(_arg, f) {\n      var g, h;\n      h = _arg[0], g = _arg[1];\n\n      if (!(typeof h === \'function\')) {\n        throw Error("\\"assert typeof h is \'function\'\\" at src/vocabulary/fork.coffee:25");\n      }\n\n      return function (b, a) {\n        return g(h(b, a), f(b, a));\n      };\n    }\n  });\n  addVocabulary({\n    \'⍕\': function _(omega, alpha) {\n      var t;\n\n      if (alpha) {\n        return nonceError();\n      } else {\n        t = _format(omega);\n        return new APLArray(t.join(\'\'), [t.length, t[0].length]);\n      }\n    }\n  });\n\n  _format = function format(a) {\n    var bottom, box, c, cols, d, grid, i, j, k, left, nCols, nRows, r, result, right, rows, sa, step, t, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n\n    if (typeof a === \'undefined\') {\n      return [\'undefined\'];\n    } else if (a === null) {\n      return [\'∅\'];\n    } else if (typeof a === \'string\') {\n      return [a];\n    } else if (typeof a === \'number\') {\n      r = [(\'\' + a).replace(\'Infinity\', \'∞\').replace(/-/g, \'¯\')];\n      r.align = \'right\';\n      return r;\n    } else if (typeof a === \'function\') {\n      return [\'λ\'];\n    } else if (!(a instanceof APLArray)) {\n      return [\'\' + a];\n    } else if (prod(a.shape) === 0) {\n      return [\'\'];\n    } else {\n      sa = a.shape;\n      a = a.toArray();\n\n      if (!sa.length) {\n        return _format(a[0]);\n      }\n\n      nRows = prod(sa.slice(0, sa.length - 1));\n      nCols = sa[sa.length - 1];\n\n      rows = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (_i = 0; 0 <= nRows ? _i < nRows : _i > nRows; 0 <= nRows ? _i++ : _i--) {\n          _results.push({\n            height: 0,\n            bottomMargin: 0\n          });\n        }\n\n        return _results;\n      }();\n\n      cols = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (_i = 0; 0 <= nCols ? _i < nCols : _i > nCols; 0 <= nCols ? _i++ : _i--) {\n          _results.push({\n            type: 0,\n            width: 0,\n            leftMargin: 0,\n            rightMargin: 0\n          });\n        }\n\n        return _results;\n      }();\n\n      grid = function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (i = _i = 0, _len = rows.length; _i < _len; i = ++_i) {\n          r = rows[i];\n\n          _results.push(function () {\n            var _j, _len1, _results1;\n\n            _results1 = [];\n\n            for (j = _j = 0, _len1 = cols.length; _j < _len1; j = ++_j) {\n              c = cols[j];\n              x = a[nCols * i + j];\n              box = _format(x);\n              r.height = Math.max(r.height, box.length);\n              c.width = Math.max(c.width, box[0].length);\n              c.type = Math.max(c.type, typeof x === \'string\' && x.length === 1 ? 0 : !(x instanceof APLArray) ? 1 : 2);\n\n              _results1.push(box);\n            }\n\n            return _results1;\n          }());\n        }\n\n        return _results;\n      }();\n\n      step = 1;\n\n      for (d = _i = _ref2 = sa.length - 2; _i >= 1; d = _i += -1) {\n        step *= sa[d];\n\n        for (i = _j = _ref3 = step - 1, _ref4 = nRows - 1; step > 0 ? _j < _ref4 : _j > _ref4; i = _j += step) {\n          rows[i].bottomMargin++;\n        }\n      }\n\n      for (j = _k = 0, _len = cols.length; _k < _len; j = ++_k) {\n        c = cols[j];\n\n        if (j !== nCols - 1 && !(c.type === (_ref5 = cols[j + 1].type) && _ref5 === 0)) {\n          c.rightMargin++;\n        }\n\n        if (c.type === 2) {\n          c.leftMargin++;\n          c.rightMargin++;\n        }\n      }\n\n      result = [];\n\n      for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {\n        r = rows[i];\n\n        for (j = _m = 0, _len2 = cols.length; _m < _len2; j = ++_m) {\n          c = cols[j];\n          t = grid[i][j];\n\n          if (t.align === \'right\') {\n            left = repeat(\' \', c.leftMargin + c.width - t[0].length);\n            right = repeat(\' \', c.rightMargin);\n          } else {\n            left = repeat(\' \', c.leftMargin);\n            right = repeat(\' \', c.rightMargin + c.width - t[0].length);\n          }\n\n          for (k = _n = 0, _ref6 = t.length; 0 <= _ref6 ? _n < _ref6 : _n > _ref6; k = 0 <= _ref6 ? ++_n : --_n) {\n            t[k] = left + t[k] + right;\n          }\n\n          bottom = repeat(\' \', t[0].length);\n\n          for (_o = _ref7 = t.length, _ref8 = r.height + r.bottomMargin; _ref7 <= _ref8 ? _o < _ref8 : _o > _ref8; _ref7 <= _ref8 ? _o++ : _o--) {\n            t.push(bottom);\n          }\n        }\n\n        for (k = _p = 0, _ref9 = r.height + r.bottomMargin; 0 <= _ref9 ? _p < _ref9 : _p > _ref9; k = 0 <= _ref9 ? ++_p : --_p) {\n          result.push(function () {\n            var _q, _results;\n\n            _results = [];\n\n            for (j = _q = 0; 0 <= nCols ? _q < nCols : _q > nCols; j = 0 <= nCols ? ++_q : --_q) {\n              _results.push(grid[i][j][k]);\n            }\n\n            return _results;\n          }().join(\'\'));\n        }\n      }\n\n      return result;\n    }\n  };\n\n  addVocabulary({\n    \'⍋\': function _(omega, alpha) {\n      return grade(omega, alpha, 1);\n    },\n    \'⍒\': function _(omega, alpha) {\n      return grade(omega, alpha, -1);\n    }\n  });\n\n  grade = function grade(omega, alpha, direction) {\n    var h, indices, t123, t124, t125, t126, t127, t128, t129, x, _i, _ref2, _results;\n\n    h = {};\n\n    if (alpha) {\n      if (!alpha.shape.length) {\n        rankError();\n      }\n\n      h = {};\n      t123 = alpha;\n\n      if (!t123.empty()) {\n        t125 = t123.data;\n        t126 = t123.shape;\n        t127 = t123.stride;\n        t128 = t126.length - 1;\n        t129 = t123.offset;\n        indices = [];\n        t124 = t126.length;\n\n        while (--t124 >= 0) {\n          indices.push(0);\n        }\n\n        while (true) {\n          x = t125[t129];\n\n          if (typeof x !== \'string\') {\n            domainError();\n          }\n\n          h[x] = indices[indices.length - 1];\n          t124 = t128;\n\n          while (t124 >= 0 && indices[t124] + 1 === t126[t124]) {\n            t129 -= indices[t124] * t127[t124];\n            indices[t124--] = 0;\n          }\n\n          if (t124 < 0) {\n            break;\n          }\n\n          indices[t124]++;\n          t129 += t127[t124];\n        }\n      }\n    }\n\n    if (!omega.shape.length) {\n      rankError();\n    }\n\n    return new APLArray(function () {\n      _results = [];\n\n      for (var _i = 0, _ref2 = omega.shape[0]; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--) {\n        _results.push(_i);\n      }\n\n      return _results;\n    }.apply(this).sort(function (i, j) {\n      var a, p, tx, ty, y;\n      p = omega.offset;\n      indices = repeat([0], omega.shape.length);\n\n      while (true) {\n        x = omega.data[p + i * omega.stride[0]];\n        y = omega.data[p + j * omega.stride[0]];\n        tx = _typeof(x);\n        ty = _typeof(y);\n\n        if (tx < ty) {\n          return -direction;\n        }\n\n        if (tx > ty) {\n          return direction;\n        }\n\n        if (h[x] != null) {\n          x = h[x];\n        }\n\n        if (h[y] != null) {\n          y = h[y];\n        }\n\n        if (x < y) {\n          return -direction;\n        }\n\n        if (x > y) {\n          return direction;\n        }\n\n        a = indices.length - 1;\n\n        while (a > 0 && indices[a] + 1 === omega.shape[a]) {\n          p -= omega.stride[a] * indices[a];\n          indices[a--] = 0;\n        }\n\n        if (a <= 0) {\n          break;\n        }\n\n        p += omega.stride[a];\n        indices[a]++;\n      }\n\n      return (i > j) - (i < j);\n    }));\n  };\n\n  addVocabulary({\n    \'⍁\': conjunction(function (f, x) {\n      var _ref2;\n\n      if (f instanceof APLArray) {\n        _ref2 = [x, f], f = _ref2[0], x = _ref2[1];\n      }\n\n      if (!(typeof f === \'function\')) {\n        throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/identity.coffee:13");\n      }\n\n      if (!(x instanceof APLArray)) {\n        throw Error("\\"assert x instanceof APLArray\\" at src/vocabulary/identity.coffee:14");\n      }\n\n      if (!x.isSingleton()) {\n        rankError();\n      }\n\n      if (x.shape.length) {\n        x = APLArray.scalar(x.unwrap());\n      }\n\n      return withIdentity(x, function (omega, alpha, axis) {\n        return f(omega, alpha, axis);\n      });\n    })\n  });\n  addVocabulary({\n    \'⍳\': function _(omega, alpha) {\n      var A, a, d, data, i, itemData, itemShape, itemStride, j, m, n, p, t138, t139, t140, t141, t142, t143, t144, t145, tmp137, u, _i, _j, _k, _l, _len, _m, _n, _o, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n\n      if (alpha) {\n        if (alpha.shape.length !== 1) {\n          rankError();\n        }\n\n        return omega.map(function (x) {\n          var e, indices, rank, t130, t131, t132, t133, t134, t135, t136, y;\n\n          try {\n            rank = alpha.shape;\n            t130 = alpha;\n\n            if (!t130.empty()) {\n              t132 = t130.data;\n              t133 = t130.shape;\n              t134 = t130.stride;\n              t135 = t133.length - 1;\n              t136 = t130.offset;\n              indices = [];\n              t131 = t133.length;\n\n              while (--t131 >= 0) {\n                indices.push(0);\n              }\n\n              while (true) {\n                y = t132[t136];\n\n                if (_match(x, y)) {\n                  rank = indices;\n                  throw \'break\';\n                }\n\n                t131 = t135;\n\n                while (t131 >= 0 && indices[t131] + 1 === t133[t131]) {\n                  t136 -= indices[t131] * t134[t131];\n                  indices[t131--] = 0;\n                }\n\n                if (t131 < 0) {\n                  break;\n                }\n\n                indices[t131]++;\n                t136 += t134[t131];\n              }\n            }\n          } catch (_error) {\n            e = _error;\n\n            if (e !== \'break\') {\n              throw e;\n            }\n          }\n\n          if (rank.length === 1) {\n            return rank[0];\n          } else {\n            return new APLArray(rank);\n          }\n        });\n      } else {\n        if (omega.shape.length > 1) {\n          rankError();\n        }\n\n        a = omega.toArray();\n\n        for (_i = 0, _len = a.length; _i < _len; _i++) {\n          d = a[_i];\n\n          if (!((tmp137 = d) === ~~tmp137 && 0 <= tmp137)) {\n            domainError();\n          }\n        }\n\n        n = prod(a);\n\n        if (!n) {\n          data = [];\n        } else if (a.length === 1) {\n          data = n <= 0x100 ? new Uint8Array(n) : n <= 0x10000 ? new Uint16Array(n) : n <= 0x100000000 ? new Uint32Array(n) : domainError();\n\n          for (i = _j = 0; _j < n; i = _j += 1) {\n            data[i] = i;\n          }\n        } else {\n          m = Math.max.apply(Math, a);\n          A = m <= 0x100 ? Uint8Array : m <= 0x10000 ? Uint16Array : m <= 0x100000000 ? Uint32Array : domainError();\n          itemData = new A(n * a.length);\n          u = n;\n\n          for (i = _k = 0, _ref2 = a.length; _k < _ref2; i = _k += 1) {\n            u /= a[i];\n            p = n * i;\n\n            for (j = _l = 0, _ref3 = a[i]; _l < _ref3; j = _l += 1) {\n              itemData[p] = j;\n              t138 = itemData;\n              t139 = p;\n              t140 = 1;\n              t141 = u;\n\n              if (t138 instanceof Array) {\n                for (j = _m = _ref4 = t140, _ref5 = t141; _m < _ref5; j = _m += 1) {\n                  t138[t139 + j] = t138[t139 + j % t140];\n                }\n              } else {\n                t138 = t138.subarray(t139, t139 + t141);\n\n                while (2 * t140 < t141) {\n                  t138.set(t138.subarray(0, t140), t140);\n                  t140 *= 2;\n                }\n\n                t138.set(t138.subarray(0, t141 - t140), t140);\n              }\n\n              p += u;\n            }\n\n            t142 = itemData;\n            t143 = n * i;\n            t144 = a[i] * u;\n            t145 = n;\n\n            if (t142 instanceof Array) {\n              for (j = _n = _ref6 = t144, _ref7 = t145; _n < _ref7; j = _n += 1) {\n                t142[t143 + j] = t142[t143 + j % t144];\n              }\n            } else {\n              t142 = t142.subarray(t143, t143 + t145);\n\n              while (2 * t144 < t145) {\n                t142.set(t142.subarray(0, t144), t144);\n                t144 *= 2;\n              }\n\n              t142.set(t142.subarray(0, t145 - t144), t144);\n            }\n          }\n\n          data = [];\n          itemShape = [a.length];\n          itemStride = [n];\n\n          for (i = _o = 0; _o < n; i = _o += 1) {\n            data.push(new APLArray(itemData, itemShape, itemStride, i));\n          }\n        }\n\n        return new APLArray(data, a);\n      }\n    }\n  });\n  addVocabulary({\n    \'⊂\': function _(omega, alpha, axes) {\n      var data, i, indices, p, resultAxes, shape, stride, t146, t147, t148, t149, t150, t151, unitShape, unitStride, x, _i, _ref2, _results;\n\n      if (!!alpha) {\n        throw Error("\\"assert not ⍺\\" at src/vocabulary/leftshoe.coffee:13");\n      }\n\n      axes = axes != null ? getAxisList(axes, omega.shape.length) : function () {\n        _results = [];\n\n        for (var _i = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--) {\n          _results.push(_i);\n        }\n\n        return _results;\n      }.apply(this);\n\n      if (omega.isSimple()) {\n        return omega;\n      }\n\n      unitShape = function () {\n        var _j, _len, _results1;\n\n        _results1 = [];\n\n        for (_j = 0, _len = axes.length; _j < _len; _j++) {\n          i = axes[_j];\n\n          _results1.push(omega.shape[i]);\n        }\n\n        return _results1;\n      }();\n\n      unitStride = function () {\n        var _j, _len, _results1;\n\n        _results1 = [];\n\n        for (_j = 0, _len = axes.length; _j < _len; _j++) {\n          i = axes[_j];\n\n          _results1.push(omega.stride[i]);\n        }\n\n        return _results1;\n      }();\n\n      resultAxes = function () {\n        var _j, _ref3, _results1;\n\n        _results1 = [];\n\n        for (i = _j = 0, _ref3 = omega.shape.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {\n          if (__indexOf.call(axes, i) < 0) {\n            _results1.push(i);\n          }\n        }\n\n        return _results1;\n      }();\n\n      shape = function () {\n        var _j, _len, _results1;\n\n        _results1 = [];\n\n        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {\n          i = resultAxes[_j];\n\n          _results1.push(omega.shape[i]);\n        }\n\n        return _results1;\n      }();\n\n      stride = function () {\n        var _j, _len, _results1;\n\n        _results1 = [];\n\n        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {\n          i = resultAxes[_j];\n\n          _results1.push(omega.stride[i]);\n        }\n\n        return _results1;\n      }();\n\n      data = [];\n      t146 = new APLArray(omega.data, shape, stride, omega.offset);\n\n      if (!t146.empty()) {\n        t148 = t146.data;\n        t149 = t146.shape;\n        t150 = t146.stride;\n        t151 = t149.length - 1;\n        p = t146.offset;\n        indices = [];\n        t147 = t149.length;\n\n        while (--t147 >= 0) {\n          indices.push(0);\n        }\n\n        while (true) {\n          x = t148[p];\n          data.push(new APLArray(omega.data, unitShape, unitStride, p));\n          t147 = t151;\n\n          while (t147 >= 0 && indices[t147] + 1 === t149[t147]) {\n            p -= indices[t147] * t150[t147];\n            indices[t147--] = 0;\n          }\n\n          if (t147 < 0) {\n            break;\n          }\n\n          indices[t147]++;\n          p += t150[t147];\n        }\n      }\n\n      return new APLArray(data, shape);\n    }\n  });\n  addVocabulary({\n    \'~\': pervasive({\n      monad: function monad(x) {\n        return +!bool(x);\n      }\n    }),\n    \'∨\': withIdentity(0, pervasive({\n      dyad: function dyad(y, x) {\n        if (!Complex.isint(x) || !Complex.isint(y)) {\n          domainError(\'∨ is implemented only for Gaussian integers\');\n        }\n\n        return Complex.gcd(x, y);\n      }\n    })),\n    \'∧\': withIdentity(1, pervasive({\n      dyad: function dyad(y, x) {\n        if (!Complex.isint(x) || !Complex.isint(y)) {\n          domainError(\'∧ is implemented only for Gaussian integers\');\n        }\n\n        return Complex.lcm(x, y);\n      }\n    })),\n    \'⍱\': pervasive({\n      dyad: function dyad(y, x, t152) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          return +!(bool(x) | bool(y));\n        } else {\n          return domainError();\n        }\n      }\n    }),\n    \'⍲\': pervasive({\n      dyad: function dyad(y, x, t153) {\n        if (typeof y === \'number\' && (x == null || typeof x === \'number\')) {\n          return +!(bool(x) & bool(y));\n        } else {\n          return domainError();\n        }\n      }\n    })\n  });\n  addVocabulary({\n    \'⍣\': conjunction(function (g, f) {\n      var h, n;\n\n      if (f instanceof APLArray && typeof g === \'function\') {\n        h = f;\n        f = g;\n        g = h;\n      } else {\n        if (!(typeof f === \'function\')) {\n          throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/poweroperator.coffee:15");\n        }\n      }\n\n      if (typeof g === \'function\') {\n        return function (omega, alpha) {\n          var omega1;\n\n          while (true) {\n            omega1 = f(omega, alpha);\n\n            if (g(omega, omega1).toBool()) {\n              return omega;\n            }\n\n            omega = omega1;\n          }\n        };\n      } else {\n        n = g.toInt(0);\n        return function (omega, alpha) {\n          var _i;\n\n          for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {\n            omega = f(omega, alpha);\n          }\n\n          return omega;\n        };\n      }\n    })\n  });\n  addVocabulary({\n    \'get_⎕\': function get_() {\n      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === \'function\') {\n        return new APLArray(prompt(\'⎕:\') || \'\');\n      } else {\n        return nonceError(\'Reading from ⎕ is not implemented.\');\n      }\n    },\n    \'set_⎕\': function set_(x) {\n      var s;\n      s = _format(x).join(\'\\n\') + \'\\n\';\n\n      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === \'function\') {\n        window.alert(s);\n      } else {\n        process.stdout.write(s);\n      }\n\n      return x;\n    },\n    \'get_⍞\': function get_() {\n      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === \'function\') {\n        return prompt(\'\') || \'\';\n      } else {\n        return nonceError(\'Reading from ⍞ is not implemented.\');\n      }\n    },\n    \'set_⍞\': function set_(x) {\n      var s;\n      s = _format(x).join(\'\\n\');\n\n      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === \'function\') {\n        window.alert(s);\n      } else {\n        process.stdout.write(s);\n      }\n\n      return x;\n    },\n    \'get_⎕CT\': function get_CT() {\n      return _aplify(thisCT);\n    },\n    \'set_⎕CT\': function set_CT(x) {\n      if (x.data.length != 1) {\n        return rankError("⎕CT");\n      }\n\n      if (typeof x.data[0] != "number") {\n        return domainError("⎕CT");\n      }\n\n      if (x.data[0] < 0 || x.data[0] > 1E-10) {\n        return domainError("⎕CT");\n      }\n\n      thisCT = x.data[0];\n      return x;\n    },\n    \'get_⎕Error\': function get_Error() {\n      return _aplify(thisError);\n    },\n    \'set_⎕Error\': function set_Error(x) {\n      return domainError(\'Cannot set ⎕Error\');\n    },\n    \'get_⎕files\': function get_Files() {\n      return _aplify(storeLib("File "));\n    },\n    \'set_⎕files\': function set_Files(x) {\n      return domainError(\'Cannot set ⎕files\');\n    },\n    \'get_∅\': function get_() {\n      return new APLArray([null], []);\n    },\n    \'⎕DL\': cps(function (omega, alpha, _, callback) {\n      var t0;\n      t0 = +new Date();\n      setTimeout(function () {\n        return callback(new APLArray([new Date() - t0]));\n      }, omega.unwrap());\n    }),\n    \'⎕RE\': function RE(omega, alpha) {\n      var e, m, r, re, u, x, y, _i, _len;\n\n      x = alpha.toSimpleString();\n      y = omega.toSimpleString();\n\n      try {\n        re = new RegExp(x);\n      } catch (_error) {\n        e = _error;\n        domainError(e.toString());\n      }\n\n      if (m = re.exec(y)) {\n        r = [m.index];\n\n        for (_i = 0, _len = m.length; _i < _len; _i++) {\n          u = m[_i];\n          r.push(new APLArray(u || \'\'));\n        }\n\n        return new APLArray(r);\n      } else {\n        return APLArray.zilde;\n      }\n    },\n    \'⎕UCS\': function UCS(omega, alpha) {\n      if (alpha != null) {\n        nonceError();\n      }\n\n      return omega.map(function (x) {\n        var tmp154, y, _ref2;\n\n        if ((tmp154 = x) === ~~tmp154 && 0 <= (_ref2 = tmp154) && _ref2 < 0x10000) {\n          return y = String.fromCharCode(x);\n        } else if (typeof x === \'string\') {\n          return y = x.charCodeAt(0);\n        } else {\n          return domainError();\n        }\n      });\n    }\n  });\n  addVocabulary({\n    \'?\': function _(omega, alpha) {\n      if (alpha) {\n        return deal(omega, alpha);\n      } else {\n        return roll(omega);\n      }\n    }\n  });\n  roll = pervasive({\n    monad: function monad(omega) {\n      var tmp155;\n\n      if (!((tmp155 = omega) === ~~tmp155 && 1 <= tmp155)) {\n        domainError();\n      }\n\n      return Math.floor(Math.random() * omega);\n    }\n  });\n\n  deal = function deal(omega, alpha) {\n    var h, i, j, r, tmp156, tmp157, _i, _j, _ref2, _results;\n\n    alpha = alpha.unwrap();\n    omega = omega.unwrap();\n\n    if (!((tmp156 = omega) === ~~tmp156 && 0 <= tmp156 && (tmp157 = alpha) === ~~tmp157 && 0 <= (_ref2 = tmp157) && _ref2 < omega + 1)) {\n      domainError();\n    }\n\n    r = function () {\n      _results = [];\n\n      for (var _i = 0; 0 <= omega ? _i < omega : _i > omega; 0 <= omega ? _i++ : _i--) {\n        _results.push(_i);\n      }\n\n      return _results;\n    }.apply(this);\n\n    for (i = _j = 0; _j < alpha; i = _j += 1) {\n      j = i + Math.floor(Math.random() * (omega - i));\n      h = r[i];\n      r[i] = r[j];\n      r[j] = h;\n    }\n\n    return new APLArray(r.slice(0, alpha));\n  };\n\n  addVocabulary({\n    \'↗\': function _(omega) {\n      return aplError(omega.toString());\n    }\n  });\n  addVocabulary({\n    \'⍴\': function _(omega, alpha) {\n      var a, data, e, n, t159, t160, t161, t162, t163, t164, t165, t166, tmp158, x, _i, _len;\n\n      if (alpha) {\n        if (alpha.shape.length > 1) {\n          rankError();\n        }\n\n        a = alpha.toArray();\n\n        for (_i = 0, _len = a.length; _i < _len; _i++) {\n          x = a[_i];\n\n          if (!((tmp158 = x) === ~~tmp158 && 0 <= tmp158)) {\n            domainError();\n          }\n        }\n\n        n = prod(a);\n\n        if (!n) {\n          return new APLArray([], a);\n        } else if (a.length >= omega.shape.length && arrayEquals(omega.shape, a.slice(a.length - omega.shape.length))) {\n          return new APLArray(omega.data, a, repeat([0], a.length - omega.shape.length).concat(omega.stride), omega.offset);\n        } else {\n          data = [];\n\n          try {\n            t159 = omega;\n\n            if (!t159.empty()) {\n              t161 = t159.data;\n              t162 = t159.shape;\n              t163 = t159.stride;\n              t164 = t162.length - 1;\n              t166 = t159.offset;\n              t165 = [];\n              t160 = t162.length;\n\n              while (--t160 >= 0) {\n                t165.push(0);\n              }\n\n              while (true) {\n                x = t161[t166];\n\n                if (data.length >= n) {\n                  throw \'break\';\n                }\n\n                data.push(x);\n                t160 = t164;\n\n                while (t160 >= 0 && t165[t160] + 1 === t162[t160]) {\n                  t166 -= t165[t160] * t163[t160];\n                  t165[t160--] = 0;\n                }\n\n                if (t160 < 0) {\n                  break;\n                }\n\n                t165[t160]++;\n                t166 += t163[t160];\n              }\n            }\n          } catch (_error) {\n            e = _error;\n\n            if (e !== \'break\') {\n              throw e;\n            }\n          }\n\n          if (data.length) {\n            while (2 * data.length < n) {\n              data = data.concat(data);\n            }\n\n            if (data.length !== n) {\n              data = data.concat(data.slice(0, n - data.length));\n            }\n          } else {\n            data = repeat([omega.getPrototype()], n);\n          }\n\n          return new APLArray(data, a);\n        }\n      } else {\n        return new APLArray(omega.shape);\n      }\n    }\n  });\n  addVocabulary({\n    \'⌽\': rotate = function rotate(omega, alpha, axis) {\n      var a, data, indices, n, offset, p, shape, step, stride, tmp167, tmp168, tmp169;\n\n      if (!(typeof axis === \'undefined\' || axis instanceof APLArray)) {\n        throw Error("\\"assert typeof axis is \'undefined\' or axis instanceof APLArray\\" at src/vocabulary/rotate.coffee:4");\n      }\n\n      if (alpha) {\n        axis = !axis ? omega.shape.length - 1 : axis.unwrap();\n\n        if (!((tmp167 = axis) === ~~tmp167)) {\n          domainError();\n        }\n\n        if (omega.shape.length && !(0 <= axis && axis < omega.shape.length)) {\n          indexError();\n        }\n\n        step = alpha.unwrap();\n\n        if (!((tmp168 = step) === ~~tmp168)) {\n          domainError();\n        }\n\n        if (!step) {\n          return omega;\n        }\n\n        n = omega.shape[axis];\n        step = (n + step % n) % n;\n\n        if (omega.empty() || step === 0) {\n          return omega;\n        }\n\n        data = [];\n        shape = omega.shape, stride = omega.stride;\n        p = omega.offset;\n        indices = repeat([0], shape.length);\n\n        while (true) {\n          data.push(omega.data[p + ((indices[axis] + step) % shape[axis] - indices[axis]) * stride[axis]]);\n          a = shape.length - 1;\n\n          while (a >= 0 && indices[a] + 1 === shape[a]) {\n            p -= indices[a] * stride[a];\n            indices[a--] = 0;\n          }\n\n          if (a < 0) {\n            break;\n          }\n\n          indices[a]++;\n          p += stride[a];\n        }\n\n        return new APLArray(data, shape);\n      } else {\n        if (axis) {\n          if (!axis.isSingleton()) {\n            lengthError();\n          }\n\n          axis = axis.unwrap();\n\n          if (!((tmp169 = axis) === ~~tmp169)) {\n            domainError();\n          }\n\n          if (!(0 <= axis && axis < omega.shape.length)) {\n            indexError();\n          }\n        } else {\n          axis = [omega.shape.length - 1];\n        }\n\n        if (omega.shape.length === 0) {\n          return omega;\n        }\n\n        stride = omega.stride.slice(0);\n        stride[axis] = -stride[axis];\n        offset = omega.offset + (omega.shape[axis] - 1) * omega.stride[axis];\n        return new APLArray(omega.data, omega.shape, stride, offset);\n      }\n    },\n    \'⊖\': function _(omega, alpha, axis) {\n      if (axis == null) {\n        axis = APLArray.zero;\n      }\n\n      return rotate(omega, alpha, axis);\n    }\n  });\n  addVocabulary({\n    \'/\': adverb(function (omega, alpha, axis) {\n      if (typeof omega === \'function\') {\n        return reduce(omega, alpha, axis);\n      } else {\n        return compressOrReplicate(omega, alpha, axis);\n      }\n    }),\n    \'⌿\': adverb(function (omega, alpha, axis) {\n      if (axis == null) {\n        axis = APLArray.zero;\n      }\n\n      if (typeof omega === \'function\') {\n        return reduce(omega, alpha, axis);\n      } else {\n        return compressOrReplicate(omega, alpha, axis);\n      }\n    })\n  });\n\n  reduce = this.reduce = function (f, g, axis0) {\n    if (!(typeof f === \'function\')) {\n      throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/slash.coffee:36");\n    }\n\n    if (!(typeof g === \'undefined\')) {\n      throw Error("\\"assert typeof g is \'undefined\'\\" at src/vocabulary/slash.coffee:37");\n    }\n\n    if (!(typeof axis0 === \'undefined\' || axis0 instanceof APLArray)) {\n      throw Error("\\"assert((typeof axis0 is \'undefined\') or (axis0 instanceof APLArray))\\" at src/vocabulary/slash.coffee:38");\n    }\n\n    return function (omega, alpha) {\n      var a, axis, data, i, indices, isBackwards, isMonadic, isNWise, n, p, rShape, shape, x, y, z, _i, _j, _ref2;\n\n      if (!omega.shape.length) {\n        omega = new APLArray([omega.unwrap()]);\n      }\n\n      axis = axis0 != null ? axis0.toInt() : omega.shape.length - 1;\n\n      if (!(0 <= axis && axis < omega.shape.length)) {\n        rankError();\n      }\n\n      if (alpha) {\n        isNWise = true;\n        n = alpha.toInt();\n\n        if (n < 0) {\n          isBackwards = true;\n          n = -n;\n        }\n      } else {\n        n = omega.shape[axis];\n        isMonadic = true;\n      }\n\n      shape = omega.shape.slice(0);\n      shape[axis] = omega.shape[axis] - n + 1;\n      rShape = shape;\n\n      if (isNWise) {\n        if (shape[axis] === 0) {\n          return new APLArray([], rShape);\n        }\n\n        if (shape[axis] < 0) {\n          lengthError();\n        }\n      } else {\n        rShape = rShape.slice(0);\n        rShape.splice(axis, 1);\n      }\n\n      if (omega.empty()) {\n        if ((z = f.identity) != null) {\n          if (!!z.shape.length) {\n            throw Error("\\"assert !⍴⍴ z\\" at src/vocabulary/slash.coffee:66");\n          }\n\n          return new APLArray(z.data, rShape, repeat([0], rShape.length), z.offset);\n        } else {\n          domainError();\n        }\n      }\n\n      data = [];\n      indices = repeat([0], shape.length);\n      p = omega.offset;\n\n      while (true) {\n        if (isBackwards) {\n          x = omega.data[p];\n          x = x instanceof APLArray ? x : APLArray.scalar(x);\n\n          for (i = _i = 1; _i < n; i = _i += 1) {\n            y = omega.data[p + i * omega.stride[axis]];\n            y = y instanceof APLArray ? y : APLArray.scalar(y);\n            x = f(x, y);\n          }\n        } else {\n          x = omega.data[p + (n - 1) * omega.stride[axis]];\n          x = x instanceof APLArray ? x : APLArray.scalar(x);\n\n          for (i = _j = _ref2 = n - 2; _j >= 0; i = _j += -1) {\n            y = omega.data[p + i * omega.stride[axis]];\n            y = y instanceof APLArray ? y : APLArray.scalar(y);\n            x = f(x, y);\n          }\n        }\n\n        if (!x.shape.length) {\n          x = x.unwrap();\n        }\n\n        data.push(x);\n        a = indices.length - 1;\n\n        while (a >= 0 && indices[a] + 1 === shape[a]) {\n          p -= indices[a] * omega.stride[a];\n          indices[a--] = 0;\n        }\n\n        if (a < 0) {\n          break;\n        }\n\n        p += omega.stride[a];\n        indices[a]++;\n      }\n\n      return new APLArray(data, rShape);\n    };\n  };\n\n  compressOrReplicate = function compressOrReplicate(omega, alpha, axis) {\n    var a, b, data, filler, i, indices, n, p, shape, tmp170, x, _i, _j, _len, _ref2;\n\n    if (!omega.shape.length) {\n      omega = new APLArray([omega.unwrap()]);\n    }\n\n    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;\n\n    if (alpha.shape.length > 1) {\n      rankError();\n    }\n\n    a = alpha.toArray();\n    n = omega.shape[axis];\n\n    if (a.length === 1) {\n      a = repeat(a, n);\n    }\n\n    if (n !== 1 && n !== a.length) {\n      lengthError();\n    }\n\n    shape = omega.shape.slice(0);\n    shape[axis] = 0;\n    b = [];\n\n    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {\n      x = a[i];\n\n      if (!((tmp170 = x) === ~~tmp170)) {\n        domainError();\n      }\n\n      shape[axis] += Math.abs(x);\n\n      for (_j = 0, _ref2 = Math.abs(x); 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--) {\n        b.push(x > 0 ? i : null);\n      }\n    }\n\n    if (n === 1) {\n      b = function () {\n        var _k, _len1, _results;\n\n        _results = [];\n\n        for (_k = 0, _len1 = b.length; _k < _len1; _k++) {\n          x = b[_k];\n\n          _results.push(x != null ? 0 : x);\n        }\n\n        return _results;\n      }();\n    }\n\n    data = [];\n\n    if (shape[axis] !== 0 && !omega.empty()) {\n      filler = omega.getPrototype();\n      p = omega.offset;\n      indices = repeat([0], shape.length);\n\n      while (true) {\n        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;\n        data.push(x);\n        i = shape.length - 1;\n\n        while (i >= 0 && indices[i] + 1 === shape[i]) {\n          if (i !== axis) {\n            p -= omega.stride[i] * indices[i];\n          }\n\n          indices[i--] = 0;\n        }\n\n        if (i < 0) {\n          break;\n        }\n\n        if (i !== axis) {\n          p += omega.stride[i];\n        }\n\n        indices[i]++;\n      }\n    }\n\n    return new APLArray(data, shape);\n  };\n\n  addVocabulary({\n    \'⌷\': squish = function squish(omega, alpha, axes) {\n      var a, axis, h, i, r, tmp171, u, _i, _j, _k, _len, _ref2, _ref3, _results;\n\n      if (typeof omega === \'function\') {\n        return function (x, y) {\n          return omega(x, y, alpha);\n        };\n      }\n\n      if (!alpha) {\n        nonceError();\n      }\n\n      if (1 < alpha.shape.length) {\n        rankError();\n      }\n\n      a = alpha.toArray();\n\n      if (a.length > omega.shape.length) {\n        lengthError();\n      }\n\n      if (axes) {\n        axes = axes.toArray();\n\n        if (a.length !== axes.length) {\n          lengthError();\n        }\n\n        h = Array(omega.shape.length);\n\n        for (_i = 0, _len = axes.length; _i < _len; _i++) {\n          axis = axes[_i];\n\n          if (!((tmp171 = axis) === ~~tmp171)) {\n            domainError();\n          }\n\n          if (!(0 <= axis && axis < omega.shape.length)) {\n            rankError();\n          }\n\n          if (h[axis]) {\n            rankError(\'Duplicate axis\');\n          }\n\n          h[axis] = 1;\n        }\n      } else {\n        axes = function () {\n          _results = [];\n\n          for (var _j = 0, _ref2 = a.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--) {\n            _results.push(_j);\n          }\n\n          return _results;\n        }.apply(this);\n      }\n\n      r = omega;\n\n      for (i = _k = _ref3 = a.length - 1; _k >= 0; i = _k += -1) {\n        u = a[i] instanceof APLArray ? a[i] : new APLArray([a[i]], []);\n        r = indexAtSingleAxis(r, u, axes[i]);\n      }\n\n      return r;\n    },\n    _index: function _index(alphaAndAxes, omega) {\n      var alpha, axes, _ref2;\n\n      _ref2 = alphaAndAxes.toArray(), alpha = _ref2[0], axes = _ref2[1];\n      return squish(omega, alpha, axes);\n    },\n    _substitute: function _substitute(args) {\n      var a, alpha, axes, data, i, omega, p, stride, subs, t172, t173, t174, t175, t176, t177, t178, t179, t180, t181, t182, t183, t184, u, v, value, x, _i, _j, _len, _ref2, _ref3, _ref4, _results;\n\n      _ref2 = function () {\n        var _i, _len, _ref2, _results;\n\n        _ref2 = args.toArray();\n        _results = [];\n\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          x = _ref2[_i];\n\n          if (x instanceof APLArray) {\n            _results.push(x);\n          } else {\n            _results.push(new APLArray([x], []));\n          }\n        }\n\n        return _results;\n      }(), value = _ref2[0], alpha = _ref2[1], omega = _ref2[2], axes = _ref2[3];\n\n      if (1 < alpha.shape.length) {\n        rankError();\n      }\n\n      a = alpha.toArray();\n\n      if (a.length > omega.shape.length) {\n        lengthError();\n      }\n\n      if (axes) {\n        if (1 < axes.shape.length) {\n          rankError();\n        }\n\n        axes = axes.toArray();\n\n        if (a.length !== axes.length) {\n          lengthError();\n        }\n      } else {\n        axes = function () {\n          _results = [];\n\n          for (var _i = 0, _ref3 = a.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; 0 <= _ref3 ? _i++ : _i--) {\n            _results.push(_i);\n          }\n\n          return _results;\n        }.apply(this);\n      }\n\n      subs = squish(vocabulary[\'⍳\'](new APLArray(omega.shape)), alpha, new APLArray(axes));\n\n      if (value.isSingleton()) {\n        value = new APLArray([value], subs.shape, repeat([0], subs.shape.length));\n      }\n\n      data = omega.toArray();\n      stride = strideForShape(omega.shape);\n      t172 = subs;\n      t177 = t172.data;\n      t179 = t172.shape;\n      t181 = t172.stride;\n      t173 = value;\n      t178 = t173.data;\n      t180 = t173.shape;\n      t182 = t173.stride;\n\n      if (t179.length !== t180.length) {\n        rankError();\n      }\n\n      t176 = t179.length;\n\n      while (--t176 >= 0) {\n        if (t179[t176] !== t180[t176]) {\n          lengthError();\n        }\n      }\n\n      if (!t172.empty()) {\n        t183 = t179.length - 1;\n        t174 = t172.offset;\n        t175 = t173.offset;\n        t184 = Array(t176 = t179.length);\n\n        while (--t176 >= 0) {\n          t184[t176] = 0;\n        }\n\n        while (true) {\n          u = t177[t174];\n          v = t178[t175];\n\n          if (v instanceof APLArray && !v.shape.length) {\n            v = v.unwrap();\n          }\n\n          if (u instanceof APLArray) {\n            p = 0;\n            _ref4 = u.toArray();\n\n            for (i = _j = 0, _len = _ref4.length; _j < _len; i = ++_j) {\n              x = _ref4[i];\n              p += x * stride[i];\n            }\n\n            data[p] = v;\n          } else {\n            data[u] = v;\n          }\n\n          t176 = t183;\n\n          while (t176 >= 0 && t184[t176] + 1 === t179[t176]) {\n            t174 -= t184[t176] * t181[t176];\n            t175 -= t184[t176] * t182[t176];\n            t184[t176--] = 0;\n          }\n\n          if (t176 < 0) {\n            break;\n          }\n\n          t184[t176]++;\n          t174 += t181[t176];\n          t175 += t182[t176];\n        }\n      }\n\n      return new APLArray(data, omega.shape);\n    }\n  });\n\n  indexAtSingleAxis = function indexAtSingleAxis(omega, sub, ax) {\n    var chunk, d, data, i, isUniform, k, n, offset, shape, shape1, stride, stride1, subStride, t187, t188, t189, t190, t191, t192, t193, t194, tmp185, tmp186, u, x, _i, _j, _k, _l, _len, _len1, _ref2, _ref3;\n\n    if (!(omega instanceof APLArray)) {\n      throw Error("\\"assert ⍵ instanceof APLArray\\" at src/vocabulary/squish.coffee:122");\n    }\n\n    if (!(sub instanceof APLArray)) {\n      throw Error("\\"assert sub instanceof APLArray\\" at src/vocabulary/squish.coffee:123");\n    }\n\n    if (!((tmp185 = ax) === ~~tmp185)) {\n      throw Error("\\"assert isInt ax\\" at src/vocabulary/squish.coffee:124");\n    }\n\n    if (!(0 <= ax && ax < omega.shape.length)) {\n      throw Error("\\"assert 0 <= ax < ⍴⍴ ⍵\\" at src/vocabulary/squish.coffee:125");\n    }\n\n    u = sub.toArray();\n    n = omega.shape[ax];\n\n    for (_i = 0, _len = u.length; _i < _len; _i++) {\n      x = u[_i];\n\n      if (!((tmp186 = x) === ~~tmp186)) {\n        domainError();\n      }\n\n      if (!(0 <= x && x < n)) {\n        indexError();\n      }\n    }\n\n    isUniform = false;\n\n    if (u.length >= 2) {\n      isUniform = true;\n      d = u[1] - u[0];\n\n      for (i = _j = 2, _ref2 = u.length; _j < _ref2; i = _j += 1) {\n        if (u[i] - u[i - 1] !== d) {\n          isUniform = false;\n          break;\n        }\n      }\n    }\n\n    if (isUniform) {\n      shape = omega.shape.slice(0);\n      shape.splice.apply(shape, [ax, 1].concat(__slice.call(sub.shape)));\n      stride = omega.stride.slice(0);\n      subStride = strideForShape(sub.shape);\n\n      for (i = _k = 0, _len1 = subStride.length; _k < _len1; i = ++_k) {\n        x = subStride[i];\n        subStride[i] = x * d * omega.stride[ax];\n      }\n\n      stride.splice.apply(stride, [ax, 1].concat(__slice.call(subStride)));\n      offset = omega.offset + u[0] * omega.stride[ax];\n      return new APLArray(omega.data, shape, stride, offset);\n    } else {\n      shape1 = omega.shape.slice(0);\n      shape1.splice(ax, 1);\n      stride1 = omega.stride.slice(0);\n      stride1.splice(ax, 1);\n      data = [];\n      t187 = sub;\n\n      if (!t187.empty()) {\n        t189 = t187.data;\n        t190 = t187.shape;\n        t191 = t187.stride;\n        t192 = t190.length - 1;\n        t194 = t187.offset;\n        t193 = [];\n        t188 = t190.length;\n\n        while (--t188 >= 0) {\n          t193.push(0);\n        }\n\n        while (true) {\n          x = t189[t194];\n          chunk = new APLArray(omega.data, shape1, stride1, omega.offset + x * omega.stride[ax]);\n          data.push.apply(data, chunk.toArray());\n          t188 = t192;\n\n          while (t188 >= 0 && t193[t188] + 1 === t190[t188]) {\n            t194 -= t193[t188] * t191[t188];\n            t193[t188--] = 0;\n          }\n\n          if (t188 < 0) {\n            break;\n          }\n\n          t193[t188]++;\n          t194 += t191[t188];\n        }\n      }\n\n      shape = shape1.slice(0);\n      stride = strideForShape(shape);\n      shape.splice.apply(shape, [ax, 0].concat(__slice.call(sub.shape)));\n      subStride = strideForShape(sub.shape);\n      k = prod(shape1);\n\n      for (i = _l = 0, _ref3 = subStride.length; _l < _ref3; i = _l += 1) {\n        subStride[i] *= k;\n      }\n\n      stride.splice.apply(stride, [ax, 0].concat(__slice.call(subStride)));\n      return new APLArray(data, shape, stride);\n    }\n  };\n\n  addVocabulary({\n    \'↑\': function _(omega, alpha) {\n      if (alpha) {\n        return take(omega, alpha);\n      } else {\n        return first(omega);\n      }\n    }\n  });\n\n  take = function take(omega, alpha) {\n    var a, axis, copyIndices, copyShape, data, i, mustCopy, offset, p, q, shape, stride, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref2;\n\n    if (alpha.shape.length > 1) {\n      rankError();\n    }\n\n    if (!omega.shape.length) {\n      omega = new APLArray([omega.unwrap()], !alpha.shape.length ? [1] : repeat([1], alpha.shape[0]));\n    }\n\n    a = alpha.toArray();\n\n    if (a.length > omega.shape.length) {\n      rankError();\n    }\n\n    for (_i = 0, _len = a.length; _i < _len; _i++) {\n      x = a[_i];\n\n      if (typeof x !== \'number\' || x !== Math.floor(x)) {\n        domainError();\n      }\n    }\n\n    mustCopy = false;\n    shape = omega.shape.slice(0);\n\n    for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {\n      x = a[i];\n      shape[i] = Math.abs(x);\n\n      if (shape[i] > omega.shape[i]) {\n        mustCopy = true;\n      }\n    }\n\n    if (mustCopy) {\n      stride = Array(shape.length);\n      stride[stride.length - 1] = 1;\n\n      for (i = _k = _ref2 = stride.length - 2; _k >= 0; i = _k += -1) {\n        stride[i] = stride[i + 1] * shape[i + 1];\n      }\n\n      data = repeat([omega.getPrototype()], prod(shape));\n      copyShape = shape.slice(0);\n      p = omega.offset;\n      q = 0;\n\n      for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {\n        x = a[i];\n        copyShape[i] = Math.min(omega.shape[i], Math.abs(x));\n\n        if (x < 0) {\n          if (x < -omega.shape[i]) {\n            q -= (x + omega.shape[i]) * stride[i];\n          } else {\n            p += (x + omega.shape[i]) * omega.stride[i];\n          }\n        }\n      }\n\n      if (prod(copyShape)) {\n        copyIndices = repeat([0], copyShape.length);\n\n        while (true) {\n          data[q] = omega.data[p];\n          axis = copyShape.length - 1;\n\n          while (axis >= 0 && copyIndices[axis] + 1 === copyShape[axis]) {\n            p -= copyIndices[axis] * omega.stride[axis];\n            q -= copyIndices[axis] * stride[axis];\n            copyIndices[axis--] = 0;\n          }\n\n          if (axis < 0) {\n            break;\n          }\n\n          p += omega.stride[axis];\n          q += stride[axis];\n          copyIndices[axis]++;\n        }\n      }\n\n      return new APLArray(data, shape, stride);\n    } else {\n      offset = omega.offset;\n\n      for (i = _m = 0, _len3 = a.length; _m < _len3; i = ++_m) {\n        x = a[i];\n\n        if (x < 0) {\n          offset += (omega.shape[i] + x) * omega.stride[i];\n        }\n      }\n\n      return new APLArray(omega.data, shape, omega.stride, offset);\n    }\n  };\n\n  first = function first(omega) {\n    var x;\n    x = omega.empty() ? omega.getPrototype() : omega.data[omega.offset];\n\n    if (x instanceof APLArray) {\n      return x;\n    } else {\n      return new APLArray([x], []);\n    }\n  };\n\n  addVocabulary({\n    \'⍉\': function _(omega, alpha) {\n      var i, n, shape, stride, tmp195, u, x, _i, _j, _len, _len1, _ref2;\n\n      if (alpha) {\n        if (alpha.shape.length > 1) {\n          rankError();\n        }\n\n        if (!alpha.shape.length) {\n          alpha = new APLArray([alpha.unwrap()]);\n        }\n\n        n = omega.shape.length;\n\n        if (alpha.shape[0] !== n) {\n          lengthError();\n        }\n\n        shape = [];\n        stride = [];\n        _ref2 = alpha.toArray();\n\n        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {\n          x = _ref2[i];\n\n          if (!((tmp195 = x) === ~~tmp195 && 0 <= tmp195)) {\n            domainError();\n          }\n\n          if (x >= n) {\n            rankError();\n          }\n\n          if (shape[x] != null) {\n            shape[x] = Math.min(shape[x], omega.shape[i]);\n            stride[x] += omega.stride[i];\n          } else {\n            shape[x] = omega.shape[i];\n            stride[x] = omega.stride[i];\n          }\n        }\n\n        for (_j = 0, _len1 = shape.length; _j < _len1; _j++) {\n          u = shape[_j];\n\n          if (u == null) {\n            rankError();\n          }\n        }\n\n        return new APLArray(omega.data, shape, stride, omega.offset);\n      } else {\n        return new APLArray(omega.data, omega.shape.slice(0).reverse(), omega.stride.slice(0).reverse(), omega.offset);\n      }\n    }\n  });\n  addVocabulary({\n    \'⍠\': conjunction(function (f, g) {\n      if (!(typeof f === \'function\')) {\n        throw Error("\\"assert typeof f is \'function\'\\" at src/vocabulary/variant.coffee:8");\n      }\n\n      if (!(typeof g === \'function\')) {\n        throw Error("\\"assert typeof g is \'function\'\\" at src/vocabulary/variant.coffee:9");\n      }\n\n      return function (omega, alpha, axis) {\n        return (alpha != null ? f : g)(omega, alpha, axis);\n      };\n    })\n  });\n  _ref2 = [1, 2, 3, 4], NOUN = _ref2[0], VERB = _ref2[1], ADVERB = _ref2[2], CONJUNCTION = _ref2[3];\n\n  exec = function exec(aplCode, opts) {\n    var ast, code, env, k, result, v, x, _ref3, _ref4;\n\n    if (opts == null) {\n      opts = {};\n    }\n\n    ast = parse(aplCode, opts);\n    code = compileAST(ast, opts);\n    env = [prelude.env[0].slice(0)];\n    _ref3 = ast.vars;\n\n    for (k in _ref3) {\n      v = _ref3[k];\n      env[0][v.slot] = opts.ctx[k];\n    }\n\n    result = _vm({\n      code: code,\n      env: env\n    });\n    _ref4 = ast.vars;\n\n    for (k in _ref4) {\n      v = _ref4[k];\n      x = opts.ctx[k] = env[0][v.slot];\n\n      if (v.category === ADVERB) {\n        x.isAdverb = true;\n      }\n\n      if (v.category === CONJUNCTION) {\n        x.isConjunction = true;\n      }\n    }\n\n    return result;\n  };\n\n  _repr = function repr(x) {\n    var k, v, y, _ref3;\n\n    if (x === null || (_ref3 = _typeof(x)) === \'string\' || _ref3 === \'number\' || _ref3 === \'boolean\') {\n      return JSON.stringify(x);\n    } else if (x instanceof Array) {\n      return "[" + function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = x.length; _i < _len; _i++) {\n          y = x[_i];\n\n          _results.push(_repr(y));\n        }\n\n        return _results;\n      }().join(\',\') + "]";\n    } else if (x.repr) {\n      return x.repr();\n    } else {\n      return "{" + function () {\n        var _results;\n\n        _results = [];\n\n        for (k in x) {\n          v = x[k];\n\n          _results.push("" + _repr(k) + ":" + _repr(v));\n        }\n\n        return _results;\n      }().join(\',\') + "}";\n    }\n  };\n\n  compileAST = function compileAST(ast, opts) {\n    var _categorizeLambdas, err, i, queue, _render, _renderLHS, scopeNode, vars, _visit, _visitLHS, _i, _ref3;\n\n    if (opts == null) {\n      opts = {};\n    }\n\n    ast.scopeDepth = 0;\n    ast.nSlots = prelude.nSlots;\n    ast.vars = Object.create(prelude.vars);\n\n    (function () {\n      var k, v, varInfo, _ref3, _results;\n\n      if (opts.ctx == null) {\n        opts.ctx = Object.create(vocabulary);\n      }\n\n      _ref3 = opts.ctx;\n      _results = [];\n\n      for (k in _ref3) {\n        v = _ref3[k];\n\n        if (!!ast.vars[k]) {\n          continue;\n        }\n\n        ast.vars[k] = varInfo = {\n          category: NOUN,\n          slot: ast.nSlots++,\n          scopeDepth: ast.scopeDepth\n        };\n\n        if (typeof v === \'function\' || v instanceof λ) {\n          varInfo.category = v.isAdverb ? ADVERB : v.isConjunction ? CONJUNCTION : VERB;\n\n          if (/^[gs]et_.*/.test(k)) {\n            _results.push(ast.vars[k.slice(4)] = {\n              category: NOUN\n            });\n          } else {\n            _results.push(void 0);\n          }\n        } else {\n          _results.push(void 0);\n        }\n      }\n\n      return _results;\n    })();\n\n    err = function err(node, message) {\n      return syntaxError(message, {\n        file: opts.file,\n        line: node.startLine,\n        col: node.startCol,\n        aplCode: opts.aplCode\n      });\n    };\n\n    if (!(VERB < ADVERB && ADVERB < CONJUNCTION)) {\n      throw Error("\\"assert VERB < ADVERB < CONJUNCTION # we are relying on this ordering below\\" at src/compiler.coffee:36");\n    }\n\n    (_categorizeLambdas = function categorizeLambdas(node) {\n      var i, r, _i, _ref3;\n\n      switch (node[0]) {\n        case \'B\':\n        case \':\':\n        case \'←\':\n        case \'[\':\n        case \'{\':\n        case \'.\':\n        case \'⍬\':\n          r = VERB;\n\n          for (i = _i = 1, _ref3 = node.length; _i < _ref3; i = _i += 1) {\n            if (node[i]) {\n              r = Math.max(r, _categorizeLambdas(node[i]));\n            }\n          }\n\n          if (node[0] === \'{\') {\n            node.category = r;\n            return VERB;\n          } else {\n            return r;\n          }\n\n          break;\n\n        case \'S\':\n        case \'N\':\n        case \'J\':\n          return 0;\n\n        case \'X\':\n          switch (node[1]) {\n            case \'⍺⍺\':\n            case \'⍶\':\n            case \'∇∇\':\n              return ADVERB;\n\n            case \'⍵⍵\':\n            case \'⍹\':\n              return CONJUNCTION;\n\n            default:\n              return VERB;\n          }\n\n          break;\n\n        default:\n          if (!0) {\n            throw Error("\\"else assert 0\\" at src/compiler.coffee:49");\n          }\n\n      }\n    })(ast);\n\n    queue = [ast];\n\n    while (queue.length) {\n      vars = (scopeNode = queue.shift()).vars;\n\n      _visit = function visit(node) {\n        var a, body, d, h, i, j, name, r, v, x, _i, _j, _k, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n\n        node.scopeNode = scopeNode;\n\n        switch (node[0]) {\n          case \':\':\n            r = _visit(node[1]);\n\n            _visit(node[2]);\n\n            return r;\n\n          case \'←\':\n            return _visitLHS(node[1], _visit(node[2]));\n\n          case \'X\':\n            name = node[1];\n\n            if (((_ref3 = v = vars["get_" + name]) != null ? _ref3.category : void 0) === VERB) {\n              return NOUN;\n            } else {\n              return ((_ref4 = vars[name]) != null ? _ref4.category : void 0) || valueError("Symbol \'" + name + "\' is referenced before assignment.", {\n                file: opts.file,\n                line: node.startLine,\n                col: node.startCol,\n                aplCode: opts.aplCode\n              });\n            }\n\n            break;\n\n          case \'{\':\n            for (i = _i = 1, _ref5 = node.length; 1 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 1 <= _ref5 ? ++_i : --_i) {\n              queue.push(extend(body = node[i], {\n                scopeNode: scopeNode,\n                scopeDepth: d = scopeNode.scopeDepth + 1 + (node.category !== VERB),\n                nSlots: 3,\n                vars: v = extend(Object.create(vars), {\n                  \'⍵\': {\n                    slot: 0,\n                    scopeDepth: d,\n                    category: NOUN\n                  },\n                  \'∇\': {\n                    slot: 1,\n                    scopeDepth: d,\n                    category: VERB\n                  },\n                  \'⍺\': {\n                    slot: 2,\n                    scopeDepth: d,\n                    category: NOUN\n                  }\n                })\n              }));\n\n              if (node.category === CONJUNCTION) {\n                v[\'⍵⍵\'] = v[\'⍹\'] = {\n                  slot: 0,\n                  scopeDepth: d - 1,\n                  category: VERB\n                };\n                v[\'∇∇\'] = {\n                  slot: 1,\n                  scopeDepth: d - 1,\n                  category: CONJUNCTION\n                };\n                v[\'⍺⍺\'] = v[\'⍶\'] = {\n                  slot: 2,\n                  scopeDepth: d - 1,\n                  category: VERB\n                };\n              } else if (node.category === ADVERB) {\n                v[\'⍺⍺\'] = v[\'⍶\'] = {\n                  slot: 0,\n                  scopeDepth: d - 1,\n                  category: VERB\n                };\n                v[\'∇∇\'] = {\n                  slot: 1,\n                  scopeDepth: d - 1,\n                  category: ADVERB\n                };\n              }\n            }\n\n            return (_ref6 = node.category) != null ? _ref6 : VERB;\n\n          case \'S\':\n          case \'N\':\n          case \'J\':\n          case \'⍬\':\n            return NOUN;\n\n          case \'[\':\n            for (i = _j = 2, _ref7 = node.length; _j < _ref7; i = _j += 1) {\n              if (node[i] && _visit(node[i]) !== NOUN) {\n                err(node, \'Indices must be nouns.\');\n              }\n            }\n\n            return _visit(node[1]);\n\n          case \'.\':\n            a = node.slice(1);\n            h = Array(a.length);\n\n            for (i = _k = _ref8 = a.length - 1; _k >= 0; i = _k += -1) {\n              h[i] = _visit(a[i]);\n            }\n\n            i = 0;\n\n            while (i < a.length - 1) {\n              if (h[i] === (_ref9 = h[i + 1]) && _ref9 === NOUN) {\n                j = i + 2;\n\n                while (j < a.length && h[j] === NOUN) {\n                  j++;\n                }\n\n                [].splice.apply(a, [i, j - i].concat(_ref10 = [[\'V\'].concat(a.slice(i, j))])), _ref10;\n                [].splice.apply(h, [i, j - i].concat(NOUN)), NOUN;\n              } else {\n                i++;\n              }\n            }\n\n            i = a.length - 2;\n\n            while (--i >= 0) {\n              if (h[i + 1] === CONJUNCTION && (h[i] !== NOUN || h[i + 2] !== NOUN)) {\n                [].splice.apply(a, [i, i + 3 - i].concat(_ref11 = [[\'C\'].concat(a.slice(i, i + 3))])), _ref11;\n                [].splice.apply(h, [i, i + 3 - i].concat(VERB)), VERB;\n                i--;\n              }\n            }\n\n            i = 0;\n\n            while (i < a.length - 1) {\n              if (h[i] !== NOUN && h[i + 1] === ADVERB) {\n                [].splice.apply(a, [i, i + 2 - i].concat(_ref12 = [[\'A\'].concat(a.slice(i, i + 2))])), _ref12;\n                [].splice.apply(h, [i, i + 2 - i].concat(VERB)), VERB;\n              } else {\n                i++;\n              }\n            }\n\n            if (h.length === 2 && h[0] !== NOUN && h[1] !== NOUN) {\n              a = [[\'H\'].concat(a)];\n              h = [VERB];\n            }\n\n            if (h.length >= 3 && h.length % 2 === 1 && all(function () {\n              var _l, _len, _results;\n\n              _results = [];\n\n              for (_l = 0, _len = h.length; _l < _len; _l++) {\n                x = h[_l];\n\n                _results.push(x !== NOUN);\n              }\n\n              return _results;\n            }())) {\n              a = [[\'F\'].concat(a)];\n              h = [VERB];\n            }\n\n            if (h[h.length - 1] !== NOUN) {\n              if (h.length > 1) {\n                err(a[h.length - 1], \'Trailing function in expression\');\n              }\n            } else {\n              while (h.length > 1) {\n                if (h.length === 2 || h[h.length - 3] !== NOUN) {\n                  [].splice.apply(a, [-2, 9e9].concat(_ref13 = [[\'M\'].concat(a.slice(-2))])), _ref13;\n                  [].splice.apply(h, [-2, 9e9].concat(NOUN)), NOUN;\n                } else {\n                  [].splice.apply(a, [-3, 9e9].concat(_ref14 = [[\'D\'].concat(a.slice(-3))])), _ref14;\n                  [].splice.apply(h, [-3, 9e9].concat(NOUN)), NOUN;\n                }\n              }\n            }\n\n            [].splice.apply(node, [0, 9e9].concat(_ref15 = a[0])), _ref15;\n            extend(node, a[0]);\n            return h[0];\n\n          default:\n            if (!0) {\n              throw Error("\\"assert 0\\" at src/compiler.coffee:144");\n            }\n\n        }\n      };\n\n      _visitLHS = function visitLHS(node, rhsCategory) {\n        var c, i, name, _i, _j, _ref3, _ref4;\n\n        node.scopeNode = scopeNode;\n\n        switch (node[0]) {\n          case \'X\':\n            name = node[1];\n\n            if (name === \'∇\') {\n              err(node, \'Assignment to ∇ is not allowed.\');\n            }\n\n            if (vars[name]) {\n              if (vars[name].category !== rhsCategory) {\n                err(node, "Inconsistent usage of symbol \'" + name + "\', it is assigned both nouns and verbs.");\n              }\n            } else {\n              vars[name] = {\n                scopeDepth: scopeNode.scopeDepth,\n                slot: scopeNode.nSlots++,\n                category: rhsCategory\n              };\n            }\n\n            break;\n\n          case \'.\':\n            rhsCategory === NOUN || err(node, \'Strand assignment can be used only for nouns.\');\n\n            for (i = _i = 1, _ref3 = node.length; _i < _ref3; i = _i += 1) {\n              _visitLHS(node[i], rhsCategory);\n            }\n\n            break;\n\n          case \'[\':\n            rhsCategory === NOUN || err(node, \'Index assignment can be used only for nouns.\');\n\n            _visitLHS(node[1], rhsCategory);\n\n            for (i = _j = 2, _ref4 = node.length; _j < _ref4; i = _j += 1) {\n              if (c = node[i]) {\n                _visit(c);\n              }\n            }\n\n            break;\n\n          default:\n            err(node, "Invalid LHS node type: " + JSON.stringify(node[0]));\n        }\n\n        return rhsCategory;\n      };\n\n      for (i = _i = 1, _ref3 = scopeNode.length; _i < _ref3; i = _i += 1) {\n        _visit(scopeNode[i]);\n      }\n    }\n\n    _render = function render(node) {\n      var a, axes, c, d, f, fragments, lx, ly, name, r, s, u, v, w, x, y, _j, _k, _ref4, _ref5, _ref6, _ref7;\n\n      switch (node[0]) {\n        case \'B\':\n          if (node.length === 1) {\n            return [LDC, APLArray.zilde, RET];\n          } else {\n            a = [];\n\n            for (i = _j = 1, _ref4 = node.length; _j < _ref4; i = _j += 1) {\n              a.push.apply(a, _render(node[i]));\n              a.push(POP);\n            }\n\n            a[a.length - 1] = RET;\n            return a;\n          }\n\n          break;\n\n        case \':\':\n          x = _render(node[1]);\n          y = _render(node[2]);\n          return x.concat(JEQ, y.length + 2, POP, y, RET);\n\n        case \'←\':\n          return _render(node[2]).concat(_renderLHS(node[1]));\n\n        case \'X\':\n          name = node[1];\n          vars = node.scopeNode.vars;\n\n          if (((_ref5 = v = vars["get_" + name]) != null ? _ref5.category : void 0) === VERB) {\n            return [LDC, APLArray.zero, GET, v.scopeDepth, v.slot, MON];\n          } else {\n            v = vars[name];\n            return [GET, v.scopeDepth, v.slot];\n          }\n\n          break;\n\n        case \'{\':\n          x = _render(node[1]);\n          lx = [LAM, x.length].concat(x);\n\n          f = function () {\n            switch (node.length) {\n              case 2:\n                return lx;\n\n              case 3:\n                y = _render(node[2]);\n                ly = [LAM, y.length].concat(y);\n                v = node.scopeNode.vars[\'⍠\'];\n                return ly.concat(GET, v.scopeDepth, v.slot, lx, DYA);\n\n              default:\n                return err(node);\n            }\n          }();\n\n          if (node.category !== VERB) {\n            return [LAM, f.length + 1].concat(f, RET);\n          } else {\n            return f;\n          }\n\n          break;\n\n        case \'S\':\n          d = node[1][0];\n          s = node[1].slice(1, -1).replace(RegExp("" + (d + d), "g"), d);\n          return [LDC, new APLArray(s, s.length === 1 ? [] : void 0)];\n\n        case \'N\':\n          a = function () {\n            var _k, _len, _ref6, _results;\n\n            _ref6 = node[1].replace(/[¯∞]/g, \'-\').split(/j/i);\n            _results = [];\n\n            for (_k = 0, _len = _ref6.length; _k < _len; _k++) {\n              x = _ref6[_k];\n\n              if (x === \'-\') {\n                _results.push(Infinity);\n              } else if (x === \'--\') {\n                _results.push(-Infinity);\n              } else if (x.match(/^-?0x/i)) {\n                _results.push(parseInt(x, 16));\n              } else {\n                _results.push(parseFloat(x));\n              }\n            }\n\n            return _results;\n          }();\n\n          v = a[1] ? new Complex(a[0], a[1]) : a[0];\n          return [LDC, new APLArray([v], [])];\n\n        case \'J\':\n          f = Function("return function(_w,_a){return(" + node[1].replace(/^«|»$/g, \'\') + ")};")();\n          return [EMB, function (_w, _a) {\n            return _aplify(f(_w, _a));\n          }];\n\n        case \'[\':\n          v = node.scopeNode.vars._index;\n          axes = [];\n          a = [];\n\n          for (i = _k = 2, _ref6 = node.length; _k < _ref6; i = _k += 1) {\n            if (!(c = node[i])) {\n              continue;\n            }\n\n            axes.push(i - 2);\n            a.push.apply(a, _render(c));\n          }\n\n          a.push(VEC, axes.length, LDC, new APLArray(axes), VEC, 2, GET, v.scopeDepth, v.slot);\n          a.push.apply(a, _render(node[1]));\n          a.push(DYA);\n          return a;\n\n        case \'V\':\n          fragments = function () {\n            var _l, _ref7, _results;\n\n            _results = [];\n\n            for (i = _l = 1, _ref7 = node.length; _l < _ref7; i = _l += 1) {\n              _results.push(_render(node[i]));\n            }\n\n            return _results;\n          }();\n\n          if (all(function () {\n            var _l, _len, _results;\n\n            _results = [];\n\n            for (_l = 0, _len = fragments.length; _l < _len; _l++) {\n              f = fragments[_l];\n\n              _results.push(f.length === 2 && f[0] === LDC);\n            }\n\n            return _results;\n          }())) {\n            return [LDC, new APLArray(function () {\n              var _l, _len, _results;\n\n              _results = [];\n\n              for (_l = 0, _len = fragments.length; _l < _len; _l++) {\n                f = fragments[_l];\n\n                _results.push((x = f[1]).isSimple() ? x.unwrap() : x);\n              }\n\n              return _results;\n            }())];\n          } else {\n            return (_ref7 = []).concat.apply(_ref7, __slice.call(fragments).concat([VEC], [node.length - 1]));\n          }\n\n          break;\n\n        case \'⍬\':\n          return [LDC, APLArray.zilde];\n\n        case \'M\':\n          return _render(node[2]).concat(_render(node[1]), MON);\n\n        case \'A\':\n          return _render(node[1]).concat(_render(node[2]), MON);\n\n        case \'D\':\n        case \'C\':\n          return _render(node[3]).concat(_render(node[2]), _render(node[1]), DYA);\n\n        case \'H\':\n          v = node.scopeNode.vars._hook;\n          return _render(node[2]).concat(GET, v.scopeDepth, v.slot, _render(node[1]), DYA);\n\n        case \'F\':\n          u = node.scopeNode.vars._hook;\n          v = node.scopeNode.vars._fork1;\n          w = node.scopeNode.vars._fork2;\n          i = node.length - 1;\n          r = _render(node[i--]);\n\n          while (i >= 2) {\n            r = r.concat(GET, v.scopeDepth, v.slot, _render(node[i--]), DYA, GET, w.scopeDepth, w.slot, _render(node[i--]), DYA);\n          }\n\n          if (i) {\n            return r.concat(_render(node[1]), GET, u.scopeDepth, u.slot, DYA);\n          } else {\n            return r;\n          }\n\n          break;\n\n        default:\n          if (!0) {\n            throw Error("\\"else assert 0\\" at src/compiler.coffee:300");\n          }\n\n      }\n    };\n\n    _renderLHS = function renderLHS(node) {\n      var a, axes, c, n, name, v, _j, _k, _ref4, _ref5, _ref6;\n\n      switch (node[0]) {\n        case \'X\':\n          name = node[1];\n          vars = node.scopeNode.vars;\n\n          if (((_ref4 = v = vars["set_" + name]) != null ? _ref4.category : void 0) === VERB) {\n            return [GET, v.scopeDepth, v.slot, MON];\n          } else {\n            v = vars[name];\n            return [SET, v.scopeDepth, v.slot];\n          }\n\n          break;\n\n        case \'.\':\n          n = node.length - 1;\n          a = [SPL, n];\n\n          for (i = _j = 1, _ref5 = node.length; _j < _ref5; i = _j += 1) {\n            a.push.apply(a, _renderLHS(node[i]));\n            a.push(POP);\n          }\n\n          return a;\n\n        case \'[\':\n          v = node.scopeNode.vars._substitute;\n          axes = [];\n          a = [];\n\n          for (i = _k = 2, _ref6 = node.length; _k < _ref6; i = _k += 1) {\n            if (!(c = node[i])) {\n              continue;\n            }\n\n            axes.push(i - 2);\n            a.push.apply(a, _render(c));\n          }\n\n          a.push(VEC, axes.length);\n          a.push.apply(a, _render(node[1]));\n          a.push(LDC, new APLArray(axes), VEC, 4, GET, v.scopeDepth, v.slot, MON);\n          a.push.apply(a, _renderLHS(node[1]));\n          return a;\n\n        default:\n          if (!0) {\n            throw Error("\\"assert 0\\" at src/compiler.coffee:335");\n          }\n\n      }\n    };\n\n    return _render(ast);\n  };\n\n  prelude = function () {\n    var code, env, k, nSlots, v, vars, _ref3;\n\n    _ref3 = {\n      "code": [1, new APLArray([], [0], [1], 0), 4, 0, 73, 9, 7, 22, 3, 1, 2, 3, 0, 65, 3, 1, 0, 3, 0, 29, 3, 1, 2, 6, 3, 0, 44, 5, 6, 8, 3, 0, 72, 3, 0, 44, 6, 4, 0, 44, 9, 7, 39, 7, 15, 3, 2, 0, 3, 1, 0, 5, 3, 1, 2, 3, 2, 2, 6, 8, 3, 0, 72, 7, 15, 3, 2, 0, 3, 1, 0, 5, 3, 1, 2, 3, 2, 0, 6, 8, 6, 8, 4, 0, 74, 9, 7, 173, 3, 1, 2, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 16, 1, new APLArray([1], [], [], 0), 6, 11, 8, 9, 1, new APLArray("RANK ERROR", [10], [1], 0), 3, 0, 61, 5, 8, 9, 3, 1, 0, 4, 1, 3, 9, 3, 1, 2, 7, 123, 3, 2, 0, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 16, 1, new APLArray([1], [], [], 0), 6, 11, 8, 9, 1, new APLArray("RANK ERROR", [10], [1], 0), 3, 0, 61, 5, 8, 9, 3, 2, 0, 3, 0, 13, 5, 4, 2, 0, 9, 3, 1, 3, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 15, 3, 2, 0, 3, 0, 62, 5, 6, 11, 8, 9, 1, new APLArray("RANK ERROR", [10], [1], 0), 3, 0, 61, 5, 8, 9, 3, 1, 3, 3, 0, 62, 5, 3, 0, 19, 3, 2, 0, 6, 3, 0, 45, 3, 0, 65, 5, 5, 11, 8, 9, 1, new APLArray("INDEX ERROR", [11], [1], 0), 3, 0, 61, 5, 8, 9, 3, 1, 3, 3, 0, 67, 3, 2, 0, 6, 3, 0, 75, 5, 4, 1, 3, 8, 3, 0, 27, 5, 5, 9, 3, 1, 3, 8, 3, 0, 72, 7, 229, 3, 1, 0, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 14, 1, new APLArray([0], [], [], 0), 6, 11, 9, 9, 3, 1, 0, 3, 0, 70, 5, 8, 9, 3, 1, 0, 3, 0, 62, 5, 3, 0, 3, 3, 0, 65, 5, 5, 3, 0, 14, 1, new APLArray([0], [], [], 0), 6, 11, 5, 9, 3, 1, 0, 8, 9, 3, 1, 0, 3, 0, 62, 5, 4, 1, 3, 9, 3, 1, 0, 3, 0, 13, 5, 4, 1, 0, 9, 3, 1, 0, 3, 0, 62, 3, 0, 27, 5, 5, 4, 1, 4, 3, 0, 79, 3, 0, 27, 5, 5, 3, 0, 35, 3, 0, 65, 5, 5, 4, 1, 5, 9, 3, 1, 4, 3, 0, 13, 3, 0, 21, 1, new APLArray([1], [], [], 0), 3, 0, 62, 3, 1, 5, 6, 6, 3, 0, 36, 3, 0, 26, 6, 3, 0, 37, 3, 0, 62, 6, 3, 0, 27, 5, 5, 4, 1, 4, 3, 0, 35, 3, 0, 65, 5, 5, 3, 0, 70, 5, 4, 1, 6, 9, 3, 1, 0, 7, 18, 3, 2, 0, 3, 0, 62, 3, 2, 2, 6, 3, 0, 70, 3, 1, 6, 6, 8, 3, 0, 27, 5, 3, 1, 4, 6, 3, 0, 76, 3, 0, 65, 5, 5, 3, 0, 70, 5, 3, 0, 62, 3, 1, 6, 3, 0, 13, 3, 1, 3, 6, 6, 8, 6, 4, 0, 75, 9, 7, 23, 3, 1, 0, 1, new APLArray([0], [], [], 0), 2, 1, 1, new APLArray([0], [1], [1], 0), 2, 2, 3, 0, 68, 3, 0, 13, 6, 3, 1, 2, 6, 8, 3, 0, 72, 7, 38, 3, 1, 0, 3, 0, 62, 3, 1, 0, 3, 0, 79, 5, 3, 1, 0, 3, 0, 62, 5, 3, 0, 26, 1, new APLArray([1], [], [], 0), 6, 3, 0, 3, 3, 0, 65, 5, 5, 2, 2, 6, 8, 6, 4, 0, 76, 9, 7, 4, 3, 1, 0, 8, 4, 0, 77, 9, 7, 4, 3, 1, 2, 8, 3, 0, 72, 7, 3, 1, new APLArray([], [0], [1], 0), 8, 6, 4, 0, 78, 9, 7, 15, 3, 1, 0, 3, 0, 20, 3, 1, 2, 6, 3, 0, 44, 5, 8, 3, 0, 72, 7, 21, 1, new APLArray([1], [], [], 0), 3, 0, 13, 3, 1, 0, 3, 0, 62, 5, 6, 3, 0, 62, 3, 0, 73, 6, 8, 6, 4, 0, 79, 9, 7, 22, 3, 1, 2, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 1, 0, 3, 0, 80, 5, 6, 8, 3, 0, 72, 7, 724, 7, 28, 1, new APLArray([0.5], [], [], 0), 3, 0, 5, 3, 2, 0, 3, 0, 0, 5, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 2, 0, 6, 6, 8, 4, 1, 3, 9, 7, 290, 1, new APLArray([1], [], [], 0), 2, 1, 1, new APLArray([0], [1], [1], 0), 2, 2, 3, 0, 68, 3, 2, 0, 3, 0, 62, 5, 6, 4, 2, 3, 9, 3, 2, 3, 3, 0, 19, 1, new APLArray([1], [], [], 0), 6, 11, 43, 9, 3, 2, 0, 7, 35, 3, 3, 0, 3, 0, 13, 5, 3, 1, 3, 5, 4, 3, 3, 9, 3, 3, 3, 3, 0, 4, 3, 3, 0, 6, 3, 3, 3, 3, 0, 76, 5, 2, 2, 8, 5, 8, 9, 1, new APLArray([2], [], [], 0), 3, 0, 4, 3, 2, 3, 6, 3, 0, 35, 5, 4, 2, 4, 9, 3, 2, 0, 3, 0, 70, 3, 2, 4, 3, 0, 13, 3, 2, 0, 3, 0, 62, 5, 3, 0, 70, 1, new APLArray([1], [], [], 0), 6, 6, 6, 4, 2, 5, 9, 3, 2, 0, 3, 0, 26, 3, 2, 4, 3, 0, 13, 1, new APLArray([0], [], [], 0), 6, 6, 4, 2, 6, 9, 3, 2, 5, 3, 2, 1, 5, 10, 2, 4, 2, 7, 9, 4, 2, 8, 9, 9, 3, 2, 6, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 2, 7, 3, 0, 71, 5, 3, 0, 0, 5, 6, 4, 2, 9, 9, 3, 2, 9, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 2, 7, 6, 3, 0, 1, 3, 2, 6, 6, 3, 2, 1, 5, 10, 2, 4, 2, 10, 9, 4, 2, 11, 9, 9, 3, 2, 10, 3, 0, 13, 3, 2, 7, 6, 3, 2, 11, 3, 0, 70, 3, 2, 3, 3, 0, 1, 5, 3, 0, 13, 1, new APLArray([2], [], [], 0), 3, 0, 4, 3, 2, 3, 6, 3, 0, 34, 5, 6, 6, 3, 0, 76, 3, 2, 9, 3, 0, 13, 3, 2, 8, 6, 6, 2, 2, 8, 4, 1, 4, 9, 7, 214, 3, 2, 0, 3, 0, 62, 5, 3, 0, 70, 1, new APLArray([1], [], [], 0), 6, 4, 2, 3, 3, 0, 14, 1, new APLArray([1], [], [], 0), 6, 11, 9, 9, 3, 2, 0, 3, 0, 4, 5, 8, 9, 1, new APLArray([2], [], [], 0), 3, 0, 4, 3, 2, 3, 6, 3, 0, 35, 5, 4, 2, 4, 9, 3, 2, 0, 3, 0, 70, 3, 2, 4, 3, 0, 13, 3, 2, 4, 6, 6, 3, 2, 1, 5, 4, 2, 5, 9, 3, 2, 0, 3, 0, 26, 3, 2, 4, 3, 0, 13, 3, 2, 4, 6, 6, 3, 2, 1, 5, 4, 2, 6, 9, 3, 2, 0, 3, 0, 70, 3, 2, 3, 3, 0, 1, 3, 2, 4, 6, 3, 0, 13, 3, 2, 4, 6, 6, 4, 2, 7, 9, 3, 2, 6, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 2, 7, 6, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 2, 5, 6, 3, 0, 1, 5, 4, 2, 8, 9, 3, 2, 6, 3, 0, 70, 3, 2, 3, 3, 0, 1, 5, 3, 0, 13, 1, new APLArray([2], [], [], 0), 3, 0, 4, 3, 2, 3, 6, 3, 0, 34, 5, 6, 6, 3, 0, 76, 3, 2, 8, 3, 0, 13, 3, 2, 5, 6, 6, 8, 4, 1, 5, 9, 3, 1, 0, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 14, 1, new APLArray([0], [], [], 0), 6, 11, 9, 9, 3, 1, 0, 3, 0, 4, 5, 8, 9, 3, 1, 0, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 14, 1, new APLArray([1], [], [], 0), 6, 11, 17, 9, 3, 1, 0, 3, 0, 76, 5, 3, 1, 1, 5, 3, 0, 13, 5, 8, 9, 3, 1, 0, 3, 0, 62, 5, 3, 0, 62, 5, 3, 0, 15, 1, new APLArray([2], [], [], 0), 6, 11, 8, 9, 1, new APLArray("RANK ERROR", [10], [1], 0), 3, 0, 61, 5, 8, 9, 3, 1, 0, 3, 0, 62, 5, 3, 0, 19, 3, 0, 65, 5, 5, 3, 0, 29, 1, new APLArray([0], [], [], 0), 6, 11, 8, 9, 1, new APLArray("LENGTH ERROR", [12], [1], 0), 3, 0, 61, 5, 8, 9, 3, 1, 0, 3, 1, 4, 5, 10, 2, 4, 1, 6, 9, 4, 1, 7, 9, 9, 3, 1, 6, 3, 0, 71, 5, 3, 0, 0, 5, 3, 0, 3, 3, 0, 25, 3, 0, 0, 6, 3, 1, 7, 3, 1, 5, 5, 6, 8, 6, 4, 0, 80, 9, 7, 31, 7, 11, 3, 2, 2, 3, 1, 0, 3, 2, 0, 6, 8, 3, 0, 72, 7, 11, 3, 2, 0, 3, 1, 0, 3, 2, 0, 6, 8, 6, 8, 4, 0, 81, 9, 3, 0, 1, 4, 0, 2, 9, 3, 0, 5, 4, 0, 6, 9, 3, 0, 8, 4, 0, 9, 9, 3, 0, 46, 4, 0, 47, 9, 3, 0, 29, 4, 0, 30, 8],\n      "nSlots": 82,\n      "vars": {\n        "+": {\n          "category": 2,\n          "slot": 0,\n          "scopeDepth": 0\n        },\n        "-": {\n          "category": 2,\n          "slot": 1,\n          "scopeDepth": 0\n        },\n        "−": {\n          "category": 2,\n          "slot": 2,\n          "scopeDepth": 0\n        },\n        "×": {\n          "category": 2,\n          "slot": 3,\n          "scopeDepth": 0\n        },\n        "÷": {\n          "category": 2,\n          "slot": 4,\n          "scopeDepth": 0\n        },\n        "*": {\n          "category": 2,\n          "slot": 5,\n          "scopeDepth": 0\n        },\n        "⋆": {\n          "category": 2,\n          "slot": 6,\n          "scopeDepth": 0\n        },\n        "⍟": {\n          "category": 2,\n          "slot": 7,\n          "scopeDepth": 0\n        },\n        "|": {\n          "category": 2,\n          "slot": 8,\n          "scopeDepth": 0\n        },\n        "∣": {\n          "category": 2,\n          "slot": 9,\n          "scopeDepth": 0\n        },\n        "\\\\": {\n          "category": 3,\n          "slot": 10,\n          "scopeDepth": 0\n        },\n        "⍀": {\n          "category": 3,\n          "slot": 11,\n          "scopeDepth": 0\n        },\n        "○": {\n          "category": 2,\n          "slot": 12,\n          "scopeDepth": 0\n        },\n        ",": {\n          "category": 2,\n          "slot": 13,\n          "scopeDepth": 0\n        },\n        "=": {\n          "category": 2,\n          "slot": 14,\n          "scopeDepth": 0\n        },\n        "≠": {\n          "category": 2,\n          "slot": 15,\n          "scopeDepth": 0\n        },\n        "<": {\n          "category": 2,\n          "slot": 16,\n          "scopeDepth": 0\n        },\n        ">": {\n          "category": 2,\n          "slot": 17,\n          "scopeDepth": 0\n        },\n        "≤": {\n          "category": 2,\n          "slot": 18,\n          "scopeDepth": 0\n        },\n        "≥": {\n          "category": 2,\n          "slot": 19,\n          "scopeDepth": 0\n        },\n        "≡": {\n          "category": 2,\n          "slot": 20,\n          "scopeDepth": 0\n        },\n        "∘": {\n          "category": 4,\n          "slot": 21,\n          "scopeDepth": 0\n        },\n        "∪": {\n          "category": 2,\n          "slot": 22,\n          "scopeDepth": 0\n        },\n        "∩": {\n          "category": 2,\n          "slot": 23,\n          "scopeDepth": 0\n        },\n        "⊥": {\n          "category": 2,\n          "slot": 24,\n          "scopeDepth": 0\n        },\n        ".": {\n          "category": 4,\n          "slot": 25,\n          "scopeDepth": 0\n        },\n        "↓": {\n          "category": 2,\n          "slot": 26,\n          "scopeDepth": 0\n        },\n        "¨": {\n          "category": 3,\n          "slot": 27,\n          "scopeDepth": 0\n        },\n        "⊤": {\n          "category": 2,\n          "slot": 28,\n          "scopeDepth": 0\n        },\n        "∊": {\n          "category": 2,\n          "slot": 29,\n          "scopeDepth": 0\n        },\n        "∈": {\n          "category": 2,\n          "slot": 30,\n          "scopeDepth": 0\n        },\n        "!": {\n          "category": 2,\n          "slot": 31,\n          "scopeDepth": 0\n        },\n        "⍎": {\n          "category": 2,\n          "slot": 32,\n          "scopeDepth": 0\n        },\n        "⍷": {\n          "category": 2,\n          "slot": 33,\n          "scopeDepth": 0\n        },\n        "⌊": {\n          "category": 2,\n          "slot": 34,\n          "scopeDepth": 0\n        },\n        "⌈": {\n          "category": 2,\n          "slot": 35,\n          "scopeDepth": 0\n        },\n        "_fork1": {\n          "category": 2,\n          "slot": 36,\n          "scopeDepth": 0\n        },\n        "_fork2": {\n          "category": 2,\n          "slot": 37,\n          "scopeDepth": 0\n        },\n        "⍕": {\n          "category": 2,\n          "slot": 38,\n          "scopeDepth": 0\n        },\n        "⍋": {\n          "category": 2,\n          "slot": 39,\n          "scopeDepth": 0\n        },\n        "⍒": {\n          "category": 2,\n          "slot": 40,\n          "scopeDepth": 0\n        },\n        "⍁": {\n          "category": 4,\n          "slot": 41,\n          "scopeDepth": 0\n        },\n        "⍳": {\n          "category": 2,\n          "slot": 42,\n          "scopeDepth": 0\n        },\n        "⊂": {\n          "category": 2,\n          "slot": 43,\n          "scopeDepth": 0\n        },\n        "~": {\n          "category": 2,\n          "slot": 44,\n          "scopeDepth": 0\n        },\n        "∨": {\n          "category": 2,\n          "slot": 45,\n          "scopeDepth": 0\n        },\n        "∧": {\n          "category": 2,\n          "slot": 46,\n          "scopeDepth": 0\n        },\n        "^": {\n          "category": 2,\n          "slot": 47,\n          "scopeDepth": 0\n        },\n        "⍱": {\n          "category": 2,\n          "slot": 48,\n          "scopeDepth": 0\n        },\n        "⍲": {\n          "category": 2,\n          "slot": 49,\n          "scopeDepth": 0\n        },\n        "⍣": {\n          "category": 4,\n          "slot": 50,\n          "scopeDepth": 0\n        },\n        "get_⎕": {\n          "category": 2,\n          "slot": 51,\n          "scopeDepth": 0\n        },\n        "⎕": {\n          "category": 1\n        },\n        "set_⎕": {\n          "category": 2,\n          "slot": 52,\n          "scopeDepth": 0\n        },\n        "get_⍞": {\n          "category": 2,\n          "slot": 53,\n          "scopeDepth": 0\n        },\n        "⍞": {\n          "category": 1\n        },\n        "set_⍞": {\n          "category": 2,\n          "slot": 54,\n          "scopeDepth": 0\n        },\n        "get_⎕IO": {\n          "category": 2,\n          "slot": 55,\n          "scopeDepth": 0\n        },\n        "⎕IO": {\n          "category": 1\n        },\n        "set_⎕IO": {\n          "category": 2,\n          "slot": 56,\n          "scopeDepth": 0\n        },\n        "⎕DL": {\n          "category": 2,\n          "slot": 57,\n          "scopeDepth": 0\n        },\n        "⎕RE": {\n          "category": 2,\n          "slot": 58,\n          "scopeDepth": 0\n        },\n        "⎕UCS": {\n          "category": 2,\n          "slot": 59,\n          "scopeDepth": 0\n        },\n        "?": {\n          "category": 2,\n          "slot": 60,\n          "scopeDepth": 0\n        },\n        "↗": {\n          "category": 2,\n          "slot": 61,\n          "scopeDepth": 0\n        },\n        "⍴": {\n          "category": 2,\n          "slot": 62,\n          "scopeDepth": 0\n        },\n        "⌽": {\n          "category": 2,\n          "slot": 63,\n          "scopeDepth": 0\n        },\n        "⊖": {\n          "category": 2,\n          "slot": 64,\n          "scopeDepth": 0\n        },\n        "/": {\n          "category": 3,\n          "slot": 65,\n          "scopeDepth": 0\n        },\n        "⌿": {\n          "category": 3,\n          "slot": 66,\n          "scopeDepth": 0\n        },\n        "⌷": {\n          "category": 2,\n          "slot": 67,\n          "scopeDepth": 0\n        },\n        "_index": {\n          "category": 2,\n          "slot": 68,\n          "scopeDepth": 0\n        },\n        "_substitute": {\n          "category": 2,\n          "slot": 69,\n          "scopeDepth": 0\n        },\n        "↑": {\n          "category": 2,\n          "slot": 70,\n          "scopeDepth": 0\n        },\n        "⍉": {\n          "category": 2,\n          "slot": 71,\n          "scopeDepth": 0\n        },\n        "⍠": {\n          "category": 4,\n          "slot": 72,\n          "scopeDepth": 0\n        },\n        "⍬": {\n          "scopeDepth": 0,\n          "slot": 73,\n          "category": 1\n        },\n        "_hook": {\n          "scopeDepth": 0,\n          "slot": 74,\n          "category": 4\n        },\n        "⊃": {\n          "scopeDepth": 0,\n          "slot": 75,\n          "category": 2\n        },\n        "⍪": {\n          "scopeDepth": 0,\n          "slot": 76,\n          "category": 2\n        },\n        "⊢": {\n          "scopeDepth": 0,\n          "slot": 77,\n          "category": 2\n        },\n        "⊣": {\n          "scopeDepth": 0,\n          "slot": 78,\n          "category": 2\n        },\n        "≢": {\n          "scopeDepth": 0,\n          "slot": 79,\n          "category": 2\n        },\n        "⌹": {\n          "scopeDepth": 0,\n          "slot": 80,\n          "category": 2\n        },\n        "⍨": {\n          "scopeDepth": 0,\n          "slot": 81,\n          "category": 3\n        }\n      }\n    }, code = _ref3.code, nSlots = _ref3.nSlots, vars = _ref3.vars;\n    env = [[]];\n\n    for (k in vars) {\n      v = vars[k];\n      env[0][v.slot] = vocabulary[k];\n    }\n\n    _vm({\n      code: code,\n      env: env\n    });\n\n    for (k in vars) {\n      v = vars[k];\n      vocabulary[k] = env[0][v.slot];\n    }\n\n    return {\n      nSlots: nSlots,\n      vars: vars,\n      env: env\n    };\n  }();\n\n  _aplify = function aplify(x) {\n    var y;\n\n    if (typeof x === \'string\') {\n      if (x.length === 1) {\n        return APLArray.scalar(x);\n      } else {\n        return new APLArray(x);\n      }\n    } else if (typeof x === \'number\') {\n      return APLArray.scalar(x);\n    } else if (x instanceof Array) {\n      return new APLArray(function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = x.length; _i < _len; _i++) {\n          y = x[_i];\n\n          _results.push((y = _aplify(y), y.shape.length ? y : y.unwrap()));\n        }\n\n        return _results;\n      }());\n    } else if (x instanceof APLArray) {\n      return x;\n    } else {\n      return aplError(\'Cannot aplify object \' + x);\n    }\n  };\n\n  this.apl = _apl = function apl(aplCode, opts) {\n    return _apl.ws(opts)(aplCode);\n  };\n\n  extend(_apl, {\n    format: _format,\n    approx: _approx,\n    parse: parse,\n    compileAST: compileAST,\n    repr: _repr\n  });\n\n  _apl.ws = function (opts) {\n    var ctx;\n\n    if (opts == null) {\n      opts = {};\n    }\n\n    ctx = Object.create(vocabulary);\n\n    if (opts["in"]) {\n      ctx[\'get_⎕\'] = ctx[\'get_⍞\'] = function () {\n        var s;\n        s = opts["in"]();\n\n        if (!(typeof s === \'string\')) {\n          throw Error("\\"if opts.in then ctx[\'get_⎕\'] = ctx[\'get_⍞\'] = -> s = opts.in(); assert typeof s is \'string\'; new APLArray s\\" at /tmp/apl/src/apl.coffee:61");\n        }\n\n        return new APLArray(s);\n      };\n    }\n\n    if (opts.out) {\n      ctx[\'set_⎕\'] = function (x) {\n        opts.out(_format(x).join(\'\\n\') + \'\\n\');\n        return x;\n      };\n\n      ctx[\'set_⍞\'] = function (x) {\n        opts.out(_format(x).join(\'\\n\'));\n        return x;\n      };\n    }\n\n    return function (aplCode) {\n      return exec(aplCode, {\n        ctx: ctx\n      });\n    };\n  };\n\n  if (typeof module !== "undefined" && module !== null) {\n    module.exports = _apl;\n\n    if (module === (typeof require !== "undefined" && require !== null ? require.main : void 0)) {\n      (function () {\n        var arg, b, file, k, rl, usage, ws, _i, _len, _ref3;\n\n        usage = \'Usage: apl.js filename.apl\\n\';\n        file = null;\n        _ref3 = process.argv.slice(2);\n\n        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n          arg = _ref3[_i];\n\n          if (arg === \'-h\' || arg === \'--help\') {\n            process.stderr.write(usage);\n            process.exit(0);\n          } else if (/^-/.test(arg)) {\n            process.stderr.write("unrecognized option: " + arg + "\\n" + usage);\n            process.exit(1);\n          } else if (file != null) {\n            process.stderr.write(usage);\n            process.exit(1);\n          } else {\n            file = arg;\n          }\n        }\n\n        if (file != null) {\n          exec(require(\'fs\').readFileSync(file, \'utf8\'));\n        } else if (!require(\'tty\').isatty()) {\n          exec(Buffer.concat(function () {\n            var _results;\n\n            _results = [];\n\n            while (true) {\n              b = new Buffer(1024);\n\n              if (!(k = require(\'fs\').readSync(0, b, 0, b.length, null))) {\n                break;\n              }\n\n              _results.push(b.slice(0, k));\n            }\n\n            return _results;\n          }()).toString(\'utf8\'));\n        } else {\n          process.stdout.write("ngn apl 2014-02-20 PLJ 2014-02-22\\n");\n          rl = require(\'readline\').createInterface(process.stdin, process.stdout);\n          rl.setPrompt(\'      \');\n          ws = _apl.ws();\n          rl.on(\'line\', function (line) {\n            var e;\n\n            try {\n              if (!line.match(/^[\\ \\t\\f\\r\\n]*$/)) {\n                process.stdout.write(_format(ws(line)).join(\'\\n\') + \'\\n\');\n              }\n            } catch (_error) {\n              e = _error;\n              process.stdout.write(e + \'\\n\');\n            }\n\n            rl.prompt();\n          });\n          rl.on(\'close\', function () {\n            process.stdout.write(\'\\n\');\n            return process.exit(0);\n          });\n          rl.prompt();\n        }\n      })();\n    }\n  }\n}).call(this); // Called by dyadic ⍕\n\nfunction ThornArg(_w) {\n  var myWidth, myDigit, myIsExp, myResult;\n  myWidth = _w.data[_w.offset];\n  myDigit = _w.data[_w.offset + 1];\n  if (myWidth != Math.floor(myWidth)) throw "DOMAIN ERROR";\n  if (myDigit != Math.floor(myDigit)) throw "DOMAIN ERROR";\n  myIsExp = myDigit < 0;\n  if (myIsExp) myDigit = Math.abs(myDigit + 1);\n  if (myDigit > 20) throw "DOMAIN ERROR";\n\n  if (myWidth != 0) {\n    if (myIsExp) {\n      if (myDigit == 0) {\n        if (myWidth < 3) throw "DOMAIN ERROR";\n      } else {\n        if (myWidth < myDigit + 4) throw "DOMAIN ERROR";\n      }\n    } else {\n      if (myWidth - myDigit > 21) throw "DOMAIN ERROR";\n      if (myDigit != 0 && myWidth < myDigit + 2) throw "DOMAIN ERROR";\n    }\n  }\n\n  myResult = [];\n  myResult.push(myWidth);\n  myResult.push(myDigit);\n  myResult.push(+myIsExp);\n  return myResult;\n}\n\nfunction Thorn(_w, _a) {\n  var myValue, myFill, myWidth, myDigit, myIsExp;\n  myWidth = _a.data[0];\n  myDigit = _a.data[1];\n  myIsExp = _a.data[2] == 1;\n\n  try {\n    if (typeof _w.data[0] == "string") {\n      myValue = _w.toString().split("\\n")[0];\n    } else {\n      if (_w.data.length == 1 && typeof _w.data[0] == "number") {\n        if (myIsExp) {\n          myValue = _w.data[0].toExponential(myDigit).replace(/\\+/g, "");\n\n          if (myValue.substring(0, 1) == "-") {\n            myValue = " " + myValue;\n          } else {\n            myValue = "  " + myValue;\n          }\n        } else {\n          myValue = _w.data[0].toFixed(myDigit);\n        }\n      } else {\n        myValue = new Array(Math.max(myWidth, 3) + 1).join("*");\n      }\n    }\n\n    myValue = myValue.replace(/-/g, "¯");\n\n    if (myWidth == 0) {\n      if (!myIsExp) myValue = " " + myValue;\n    } else {\n      myFill = myWidth - myValue.length;\n\n      if (myFill != 0) {\n        if (myFill < 0) {\n          myValue = new Array(myWidth + 1).join("*");\n        } else {\n          if (myIsExp) {\n            myValue = myValue + new Array(myFill + 1).join(" ");\n          } else {\n            myValue = new Array(myFill + 1).join(" ") + myValue;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    myValue = new Array(Math.max(myWidth, 3) + 1).join("*");\n  }\n\n  return myValue;\n} // Called by ⍎\n\n\nvar thisError = "";\n\nfunction EXECUTE(aTry, aCatch) {\n  try {\n    thisError = "";\n    return callAPL(aTry.toString());\n  } catch (err) {\n    thisError = err.toString();\n    var myCatch = aCatch.toString().trim();\n\n    if (myCatch.length == 0) {\n      throw thisError;\n    } else {\n      return callAPL(myCatch);\n    }\n  }\n} // Called by ⎕CT\n\n\nvar thisCT = 0;\n\nfunction TolerantEqual(x, y) {\n  // (|⍺-⍵)≤ ⎕CT× (|⍺)⌈ ∣⍵\n  return Math.abs(x - y) <= thisCT * Math.max(Math.abs(x), Math.abs(y));\n}\n\nfunction TolerantFloor(x) {\n  // Nearest← (×⍵)× ⌊0.5+ |⍵\n  //            Error        Permissible\n  //  Nearest- (Nearest- ⍵)> ⎕CT× 1⌈ |⍵\n  var myPermissible = Math.abs(x);\n  var myNearest = ((x > 0) - (x < 0)) * Math.floor(0.5 + myPermissible);\n  var myError = myNearest - x;\n  myPermissible = thisCT * Math.max(1, myPermissible);\n  return myNearest - (myError > myPermissible);\n}\n\nvar _PRELUDE_ = "⍘← { ⍝ Remember variant, and apply simple\\n ⍶ ⍵ \\n;\\n ⍺≢ ∅ : ⍺ ⍶ ⍵\\n 2= ⍴⍵ : ⍹ ⍵\\n ⍬ ⍹ ⍵\\n}\\n⍭← { ⍝ Apply variant defined by ⍘ \\n ∅ ⍶ (⍹ ⍬) ⍵\\n;\\n ∅ ⍶ (⍹ ⍬) ⍵ ⍺\\n}\\n" + "⎕enclose← ⊂\\n⊂← {⎕enclose ⍵ ; ⍺ ⊂⍭{¯1} ⍵}\\n⊂← ⊂ ⍘ {\\n (∆ ⍵)← ⍵\\n ⎕enclose[(≢⍴⍵)| ∆]⍵\\n;\\n (Axis ⍵ ⍺)← ⍵ \\n 1< ≢⍴⍺ : ↗\'RANK ERROR\' ⋄ Axis← (≢⍴⍵)| Axis\\n ⍺← 0≠ ⍺ {0= ⍴⍴⍺ : ⍵⍴ ⍺ ⋄ ⍺} last← (⍴⍵)[Axis]\\n ∆← ⍴⍵ ⋄ ∆[Axis]← 0 ⋄ ∆← ∆⍴ ⍬\\n drop← ⍺⍳ 1\\n ⍺ {drop= last : \'\'\\n  take← drop+ (drop↓ ⍺)⍳ 0\\n  ∆← ∆,[Axis] ⎕enclose[Axis]drop↓⍭{Axis} take↑⍭{Axis} ⍵ \\n  drop← take + (take↓⍺)⍳ 1\\n  ⍺ ∇ ⍵} ⍵\\n ∆\\n}\\n" + "⊃← {\\n 2> ≡⍵ : ⍵\\n maxRank← ⍴maxShape← ⍴↑⍵\\n {myRank← ⍴myShape← ⍴⍵\\n  myRank≤ maxRank : maxShape← maxShape⌈ (-maxRank)↑ (maxRank⍴ 1), myShape\\n  maxRank← myRank ⋄ maxShape← myShape⌈ (-myRank)↑ (myRank⍴ 1), maxShape\\n }¨ ⍵\\n myShape← maxRank⍴ 1 ⋄ myRank← -maxRank\\n ((⍴⍵), maxShape)⍴ ↑⍪/ {maxShape↑ (myRank↑ myShape, ⍴⍵)⍴ ⍵}¨ ,⍵\\n;\\n 1<⍴⍴⍺ : ↗\'RANK ERROR\'\\n x← ⍵\\n {\\n  1< ⍴⍴⍵ : ↗\'RANK ERROR\'\\n  ⍵← ,⍵\\n  (⍴⍵)≠ ⍴⍴x : ↗\'RANK ERROR\'\\n  ∨/ ⍵≥ ⍴x : ↗\'INDEX ERROR\'\\n  x← ⊃⍵⌷ x\\n }¨⍺\\n x\\n}\\n" + "⍋← ⍋ ⍠ {\\n 0= ⍴⍴⍺ : ↗\'RANK ERROR\'\\n 1= ⍴⍴⍺ : ⍋ ⍺⍳ ⊃⍵\\n ⍋1 0 2⍉ ⊖(⍴⍺)⊤ (,⍺)⍳ ⍪⊃⍵\\n}\\n⍒← ⍒ ⍠ {\\n 0= ⍴⍴⍺ : ↗\'RANK ERROR\'\\n 1= ⍴⍴⍺ : ⍒⍺⍳ ⊃⍵\\n ⍒1 0 2⍉ ⊖(⍴⍺)⊤ (,⍺)⍳ ⍪⊃⍵\\n}\\n" + "⍕← ⍕ ⍠ {\\n 1< ⍴⍴⍺ : ↗\'RANK ERROR\'\\n ⍺← ⍺ {\\n  1= ≢⍺ : ¯2↑ ⍺\\n  2= ≢⍺ : ⍺\\n  (⍴⍺)= 2× ¯1↑ ⍴⍵ : ⍺\\n  ↗\'LENGTH ERROR\'\\n } ⍵\\n ∆← ×/shape← ⍴⍵\\n 0= ∆ : ⍕ ⍵\\n 1= ∆ : ⍕ ⍺ {({«ThornArg(_w)»} ⍺) {«Thorn(_w, _a)»} ⍵} ⍵\\n ⍺← ⊂⍭{1}(2,⍨ ¯1↑ shape)⍴ ⍺\\n ∆← (×/¯1↓ shape), ¯1↑ shape\\n ⍵← ⊂⍭{0} ∆⍴ ⍵\\n ∆← (1 0× ∆)⍴ \'\'\\n ⍺ {\\n  myArg← ⊂{«ThornArg(_w)»} ⍺\\n  ⍵← ,myArg {,«Thorn(_w, _a)»}¨ ⍵\\n  0≠ 1↑ ⍺ : ∆← ∆, ⊃⍵\\n  0> 1↓ ⍺ : ∆← ∆, ⊃⍵\\n  ∆← ∆, ⊃(-⌈/ ≢¨⍵)↑¨ ⍵\\n }¨ ⍵\\n 2≥ ≢shape : ∆\\n (\'1\'= ,⍕((¯1↓ shape), 1)⍴ 1)⍀ ∆\\n}\\n" + "↑← ↑ ⍘ {\\n ↗\'NONCE ERROR\'\\n;\\n (Axis ⍵ ⍺)← ⍵ \\n alpha← ⍴⍵\\n alpha[(≢⍴⍵)| Axis]← ⍺\\n alpha↑ ⍵\\n}\\n↓← ↓ ⍘ {\\n ↗\'NONCE ERROR\'\\n;\\n (Axis ⍵ ⍺)← ⍵ \\n alpha← 0× ⍴⍵\\n alpha[(≢⍴⍵)| Axis]← ⍺\\n alpha↓ ⍵\\n}\\n" + "⌽← ⌽ ⍘ {\\n (Axis ⍵)← ⍵\\n ⌽[(≢⍴⍵)| Axis]⍵\\n;\\n (Axis ⍵ ⍺)← ⍵ ⋄ Axis← (≢⍴⍵)| Axis\\n (⍴⍴⍺)∧.≠ 0,¯1+⍴⍴⍵ : ↗\'RANK ERROR\' ⋄ \' \'∊2↑1⍴⍺ : ↗\'DOMAIN ERROR\'\\n ~Axis∊ Index← ⍳⍴⍴⍵ : ↗\'DOMAIN ERROR\' ⋄ Nest← 2≤ ≡⍵ ⋄ Data← ,⍵\\n ⍵←{Nest : (⍴⍵)⍴ ⍳×/⍴⍵ ⋄ ⍵} ⍵\\n Order← (Axis↑ Index), ((1+ Axis)↓ Index), Axis\\n ⍵← (⍴⍵)[Order]⍴ ∊⍺ ⌽¨ ⊂⍭{Axis}⍵\\n ⍵← {Axis≠ ¯1+ ⍴Index : Order ⍉ ⍵ ⋄ ⍵} ⍵\\n Nest : Data[⍵]\\n ⍵\\n}\\n" + "⎕file← {\\n ⍝ Return a value from local storage (each browser provides its own store)\\n «storeGet(\\"File \\" + _w.toSimpleString().trim())» \\n;\\n ⍝ Place a value into local storage\\n «storePut(\\"File \\" + _w.toSimpleString().trim(), _a.toString())» \\n}\\n⎕drop← {\\n ⍝ Remove a value from local storage\\n «storeDelete(\\"File \\" + _w.toSimpleString().trim())» \\n}\\n" + "⎕edit← {«pageLink(\\"Edit.html?File=File \\" + _w.toSimpleString().trim())»}\\n⎕link← {«pageLink(_w.toSimpleString())»}\\n" + "⎕split← {\\n ⍝ Split ⍺ into enclosed vectors at each ⍵\\n ⍺← ,⍺ ⋄ ⍵← ,⍵ ⋄ 0= ⍴⍺ : ⍺\\n ~\'\\\\\'∊ ⍵ : ,¨ «_a.toSimpleString().split(_w.toSimpleString())»\\n bs← {⍺← ⍺⌽ ⎕UCS 92 29 ⋄ ⍵← ,⍵ ⋄ ⍵[(⍵= ⍺[0])/⍳⍴⍵]← ⍺[1]}\\n ⍵← 0 bs ⍵ ⋄ ⍺← 0 bs ⍺     \\n 1 bs¨ «_a.toSimpleString().split(_w.toSimpleString())»\\n}\\n⎕join← {\\n ⍝ Join ⍺ enclosed vectors, with ⍵ between each\\n (-≢⍵)↓ ∊⍺,¨ ⊂⍵\\n}\\n⎕replace← {\\n ⍝ Replace Old with New in character vector ⍺\\n ,«_a.toString().replace(new RegExp(_w.data[_w.offset], \\"g\\"), _w.data[_w.offset + 1])»\\n}\\n⎕trim← {\\n ⍝ Remove white space from both ends of ⍵\\n ,«_w.toString().trim()»\\n}\\n⎕prompt← {\\n ⍝ A modern alternative to ⎕\\n ⍝ Tell the user ⍵ \\n «alert(_w.toString()) || \\"\\"»\\n;\\n ⍝ Ask the user ⍵; ⍺ is the default response\\n ,«prompt(_w.toString(), _a.toString())»\\n}\\n";'),r.REPLEngine=e})();