(()=>{"use strict";function n(n,e){for(var o=0;o<e.length;o++){var t=e[o];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}var e=function(){function e(n,o,t,r,i,s){var a=this;!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.sandbox=i,this.printed=!1,this.finished=!1,this.inputting=!1,this.lines=0,this.sandbox._init(),this.sandbox._error=function(n){a.finished=!0,r(n)},this.sandbox._print=function(n){a.printed=!0,o(n)},this.sandbox._prompt=function(){if(0==--a.lines&&!a.inputting&&!a.finished)return a.sandbox._finish()},this.sandbox._input=function(){if(!a.finished)return a.inputting=!0,n((function(n){return n.forEach((function(n){a.sandbox.inbuf.push(n.charCodeAt(0))})),a.sandbox.inbuf.push(13),a.inputting=!1,function(){throw new Error("Function not implemented.")}()}))},this.sandbox._finish=function(){if(!a.finished){a.sandbox.inbuf=[];var n=a.sandbox._stacktop(6);n.length?(n.length>5&&(n[0]="..."),t(n.join(" "))):(a.printed&&o("\n"),t("")),a.finished=!0}},s()}var o,t;return o=e,(t=[{key:"Eval",value:function(n){this.printed=!1,this.finished=!1,this.inputting=!1,this.lines=n.split("\n").length;try{this.sandbox._run(n)}catch(n){this.sandbox._error(n)}}},{key:"GetNextLineIndent",value:function(n){var e=function(n){var e=0;return n.split(/\s+/).forEach((function(n){switch(n){case":":e+=1;break;case";":e-=1}})),e};if(e(n)<=0)return 0;var o=e(n.split("\n").slice(-1)[0]);return o>0?1:o<0?o:0}}])&&n(o.prototype,t),e}(),o="undefined"!=typeof window&&null!==window?window:self;o.eval.call(o,"/**\n  @preserve\n\n  JS-Forth\n  http://www.forthfreak.net/index.cgi?jsforth\n  Licensed under th GNU GPL.\n\n  Disclaimer: JS-Forth is delivered as-is. No warranties,\n  implicit or explicit, towards its function, usability, fitness\n  for any purpose are given. It is distributed for educative\n  purposes, you may study it to your hearts delight. Should\n  you plan to execute JS-Forth on any computer, you declare\n  to not hold the programmer liable in any way for any damage\n  JS-Forth may cause, be it to that computer, peripherals, or any\n  other object in the range of several thousand kilometers, or\n  more. The person initiating execution of JS-Forth is the one\n  carrying sole responsibility for all and any damage resulting\n  from this action. Also, you do not hold the programmer liable\n  for any damage resulting from the study of JS-Forth.  Please\n  do not stick your tongue into the power supply of the computer\n  which is running JS-Forth.\n\n  By opening JS-Forth for reading or execution, you make a full\n  statement that you have read and understood all of the above\n  disclaimer, and proceed willingly, volunteerily, and of your\n  own choice on your own risk and responsability.\n\n  Having said that, I can assure you that JS-Forth has not been\n  written to perform any malicious action on your computer or\n  anyone elses. I run Js-Forth frequently, and no damage has\n  occured from doing so, though no extensive testing has been\n  done on it as a whole yet. Those parts which work do so in a\n  pretty stable manner. A major version jump to v0.01 may be imminent.\n*/\nvar version = '0';\nvar subversion = '5200804171342';\nvar title = \"## JS-Forth \".concat(version, \".\").concat(subversion, \" ##\"); // --------------------------------------------- vars you may wish to customize ---------------------------------------------------\n\nvar memend = 0x100000; // memory allocated to jsforth (1 megacells is more than plenty)\n\nvar maxcookies = 25; // number of disk sectors. >4 may be unsafe.\n\nvar cookiebasename = 'jsrepl-jsforth'; // cookie name for saved blocks (blk number gets appended)\n\nvar cookieexpirationdate = Date(Date.now() + 5 * 365 * 24 * 60 * 60 * 1000); // the date your hard disk will get erased.\n\nvar infolines = 1000; // backscroll buffer size of info screen\n\nvar paddistance = 512; // space between here and pad.\n\nvar padsize = 512; // remaining space above pad until dictionary overflow error\n\nvar maxbufs = 2; // number of buffers. works with any between 1 ... maxmem\n// default=2, more may be useful if working with many remote blocks\n\nvar blocktimeout = 5000; // file i/o error if request not completed with this time (ms)\n// --------------------------------------------------------------------------------------------------------------------------------\n// --- character codes\n\nvar backspace = 8;\nvar tab = 9;\nvar carriagereturn = 13;\nvar esc = 27;\nvar bl = 32;\nvar suspended = -1; // reason for suspending interpreter (event type)\n// -1: never started (helps source locator in see)\n\nvar dp = 0; // dictionary pointer\n\nvar catchframe = 0; // for catch/throw\n\nvar wc = 0; // header count\n\nvar inbuf = []; // accumulated input characters\n\nvar linelen = 80; // main screen\n\nvar lines = 30;\nvar linelen2 = 55; // info screen\n\nvar lines2 = lines;\nvar screensize = lines * linelen;\nvar tibsize = linelen + 1;\nvar dictionaryfull = memend - (paddistance + padsize); // heap memory tracking\n\nvar usedchunk = [];\nvar freechunk = [];\nvar heapend = memend; // word header bit masks\n\nvar immediate = 1;\nvar smudgebit = 2;\nvar precedencebit = immediate;\nvar s = []; // data stack\n\nvar r = []; // return stack\n\nvar m = []; // main memory\n\nvar h = []; // headers\n\nvar hf = []; // header flags (precendence bit, hide/reveal)\n\nvar x = []; // execution tokens\n\nvar t = []; // word type - accelerated execution because no\n\nvar sourceid = []; // nested loads/evaluate stack previous source id here\n// conditional branching to the corresponding\n// code for next per wordtype. this array contains\n// the proper next to use. this should also\n// simplify does>\n\nh[0] = ''; // in case header 0 gets accidently requested\n\nvar f = []; // float stack\n\nvar ip; // forth vm instruction pointer\n\nvar w; // forth vm word register\n\nvar sp = 0; // forth vm parameter stack pointer\n\nvar rp = 0; // forth vm return stack pointer\n\nvar tos; // stack cache\n\nvar ftos; // float stack cache\n// constants for standard compliance bit masks\n// a combination of those are written to the description of each word\n// through variable COMPLIANCE, subsets of provided words are masked\n\nvar standard = []; // standard selection and vocabularies share the same mechanism. therefore,\n// using both concepts is a bit of a mix here now.\n// standards and vocabularies use bit masks\n\nvar nextvocabulary = 1;\nvar uncertain = nextvocabulary;\nstandard[uncertain] = '   possibly other, need to look that up first';\nnextvocabulary <<= 1;\nvar fig = nextvocabulary;\nstandard[fig] = 'fig';\nnextvocabulary <<= 1;\nvar f79 = nextvocabulary;\nstandard[f79] = 'f79';\nnextvocabulary <<= 1;\nvar f83 = nextvocabulary;\nstandard[f83] = 'f83';\nnextvocabulary <<= 1;\nvar ans = nextvocabulary;\nstandard[ans] = 'dpans94';\nnextvocabulary <<= 1;\nvar foerthchen = nextvocabulary;\nstandard[foerthchen] = 'FOeRTHchen';\nnextvocabulary <<= 1;\nvar jsf = nextvocabulary;\nstandard[jsf] = 'JS-Forth';\nvar higheststandard = nextvocabulary;\nvar any = ans | f83 | f79 | fig | jsf; // but not foerthchen\n// --- no more standards, vocabularies follow ---\n\nnextvocabulary <<= 1;\nvar only = nextvocabulary;\nnextvocabulary <<= 1;\nvar forth = nextvocabulary;\nnextvocabulary <<= 1;\nvar hidden = nextvocabulary;\nnextvocabulary <<= 1;\nvar teststuff = nextvocabulary;\nvar lastsystemvocabulary = nextvocabulary;\nvar vocstack = []; // top element is in m[context]\n\nvar vocname = []; // contains xt of all vocs\n\nfunction printvocname(n) {\n  var temp = 0;\n\n  for (var _i = only; _i != 0x40000000; _i <<= 1) {\n    if (_i == n) {\n      type(\"\".concat(h[vocname[temp]], \" \"));\n      break;\n    }\n\n    temp++;\n  }\n}\n\nfunction jscomma(n) {\n  m[dp++] = n;\n  return dp - 1;\n}\n\nfunction jshiallot0(n) {\n  // heap (buffers, allocate)\n  for (var _i2 = n; _i2; _i2--) {\n    m[heapend++] = 0;\n  }\n\n  return heapend - n;\n} // variables, shared between javascript and forth:\n// addressed by m[varname] from javascript, define a constant\n// with value of address for access from forth.\n\n\nvar casesensitive = jscomma(0); // switch case sensitive/insensitive dictionary search\n\nvar debugging = jscomma(0); // get spilled with output on info display\n\nvar warnings = jscomma(-1); // meant to disable javascript warnings, but hides only error messages\n\nvar compliance = jscomma(jsf); // cause find, words to scope only those words complying with the selected standard\n\nvar fittype = jscomma(0); // ALLOCATE chunk matching:    0: first, other: best fit\n\nvar outfile = jscomma(-1); // switch between output routines:\n//  -1 : fast terminal\n//  -2 : slow terminal\n//  >=0 : output to consecutive blocks  ( not implemented )\n\nvar blk = jscomma(-1); // currently accessed block, as set by load\n\nvar scr = jscomma(0); // last block accessed through list or user tools\n\nvar context = jscomma(forth); // first searched vocabulary on vocabulary stack\n\nvar current = jscomma(forth); // the vocabulary compiled to\n\nvar lastxt = jscomma(0); // contains execution token of most recently compiled word\n\nvar base = jscomma(10); // radix for i/o number conversion\n\nvar state = jscomma(0); // switch interpret/compile\n\nvar innerloop = jscomma(0); // compile time helper variable for loops\n\nvar innercase = jscomma(0); // of counter for inner case\n\nvar span = jscomma(0); // obsolete -- expect stores string len in here\n\nvar toin = jscomma(0); // input buffer handling\n\nvar hashtib = jscomma(0); // obsolescent - contains # chars in tib\n\nvar tib = jshiallot0(tibsize); // input buffer\n\nvar parsebuf; // usually address of tib, but can be block address\n\nvar parsebuflen; // number of chars in parse buffer\n// ----------------------------------------------- mass memory buffers ---------------------------------------------\n\nvar nextbuf = 0; // index of next buffer to use\n\nvar buf = []; // buffer addresses\n\nvar bufdirty = []; // buffer dirty flag\n\nvar bufblk = []; // block in this buf, or -1\n\nvar blockstat = []; // -1: indexed by blk, gives -1 for unbuffered, or, if buffered, buffer id\n// ----- data storage for descriptions, stack effects -----\n// also trying to use these for vocabularies\n// \"standard\" is printed along with help. As this information is supplied\n// anyway, the compiler could use it, by making sure only words which belong\n// to a user specified standard are used, or printing warning otherwise.\n\nvar ds = []; // bitmask for compliancy and vocs\n\nvar dse = []; // stack effect, text\n\nvar lineofspaces = '';\n\nfor (var i = 0; i < linelen; i++) {\n  lineofspaces += ' ';\n}\n\nfunction describe(string1, bitmask) {\n  dse[wc] = string1;\n  ds[wc] = 0 | m[current];\n  if (bitmask) ds[wc] = bitmask | m[current];\n} // =================================================================================================\n//                                     dumb terminal emulator\n// =================================================================================================\n// ---- infos screen ----\n\n\nfunction printinfos() {// Nothing.\n}\n\nfunction info(string) {// Nothing.\n}\n\nfunction debug(string) {\n  if (m[debugging]) info(string);\n} // ---- interactive terminal screen ----\n// THIS SHOULD BE REPLACED BY THE DESIRED PRINTING FUNCTION.\n\n\nfunction _print(str) {\n  document.terminal.dialog.value += str;\n}\n\nfunction type(string) {\n  _print(string);\n}\n\nvar write = type;\n\nfunction cr() {\n  _print('\\n');\n}\n\nfunction cls() {// Nothing.\n}\n\nfunction backspaces(n) {// Nothing.\n}\n\nfunction emit(asc) {\n  type(String.fromCharCode(asc));\n}\n\nvar querytype = type; // =================================================================================================\n//                                   primitives constructor\n// =================================================================================================\n\nvar src = []; // -2: script file\n// -1: interactive console\n//  0... blk*1024+charpos\n\nfunction from() {\n  if (suspended) return -2;\n  if (m[blk] >= 0) return m[blk] * 1024 + m[toin];\n  return -1;\n}\n\nfunction newheader(name, flags) {\n  // wc = word count\n  h[++wc] = name; // header name\n\n  src[wc] = from();\n  hf[wc] = flags; // immediate/reveal\n\n  x[wc] = dp; // pointer to word body (was: xt)\n\n  m[lastxt] = wc; // last\n\n  ds[wc] = any | foerthchen | m[current]; // new words standard compliance\n\n  dse[wc] = ''; // new word stack effect\n\n  debug(\"compiling: \".concat(name));\n}\n\nfunction nextprimitive() {\n  x[w]();\n}\n\nfunction nexthilevel() {\n  w = x[w];\n  x[m[w]]();\n}\n\nfunction nextconstant() {\n  s[++sp] = tos;\n  tos = m[x[w] + 1];\n}\n\nfunction nextvariable() {\n  s[++sp] = tos;\n  tos = x[w] + 1;\n} // function nexthilevel()    { r[++rp] = ip ; ip = x[w]+1 ; }   // slower ...\n// there's a dovocabulary further below, and a dodoes\n\n\nfunction primitive(name, code, flags) {\n  newheader(name, flags | smudgebit);\n  x[wc] = code;\n  t[wc] = nextprimitive;\n  return wc;\n}\n\nfunction headerless() {\n  h[wc] = '';\n} // =================================================================================================\n//                                       misc helper words\n// =================================================================================================\n\n\ndefinitions(hidden);\n\nfunction pack(a, n) {\n  w = '';\n\n  for (var _i3 = n; _i3; _i3--) {\n    w += String.fromCharCode(m[a++]);\n  }\n\n  return w;\n}\n\nfunction forthpack() {\n  tos = pack(s[sp--], tos);\n}\n\nvar x_pack = primitive('pack', forthpack);\ndescribe('a n -- x', jsf);\n\nfunction unpackstring(string, address) {\n  // returns len\n  var stringlen = string.length;\n  var destaddr = address + stringlen;\n\n  for (var _i4 = stringlen; _i4; m[--destaddr] = string.charCodeAt(--_i4)) {}\n\n  return stringlen;\n} // unpack packed string x to address, return number of characters\n// can reuse the function above\n\n\nfunction unpack() {\n  // ( x a -- n )\n  var string = s[sp--]; // string\n\n  w = string.length; // string len\n\n  tos += w; // last dest address + 1\n\n  for (var _i5 = w; _i5; m[--tos] = string.charCodeAt(--_i5)) {}\n\n  tos = w;\n}\n\nvar x_unpack = primitive('unpack', unpack);\ndescribe('x a -- n', jsf);\n\nfunction definitions(vocabulary) {\n  m[current] = vocabulary;\n}\n\ndefinitions(forth);\n\nfunction forthstackeffect() {\n  // ( xt -- a n )\n  s[++sp] = dp;\n\n  if (dse[tos]) {\n    tos = unpackstring(\"( \".concat(dse[tos], \" )\"), dp);\n  } else {\n    tos = 0;\n  }\n}\n\nprimitive('stackeffect', forthstackeffect);\ndescribe('xt -- a n', jsf);\ndefinitions(hidden);\n\nfunction forthstorestackeffect() {\n  // ( a n -- )\n  forthpack();\n  dse[m[lastxt]] = tos;\n  tos = s[sp--];\n}\n\nvar x_storestackeffect = primitive('stackeffect!', forthstorestackeffect);\ndescribe('a n --', jsf);\ndefinitions(forth);\n\nfunction forthinfo() {\n  // ( a n -- )                   info\n  info(pack(s[sp--], tos));\n  tos = m[sp--];\n}\n\nprimitive('info', forthinfo);\ndescribe('a n --', jsf);\nvar clock;\n\nfunction forthstartclock() {\n  clock = new Date().getTime();\n}\n\nprimitive('startclock', forthstartclock);\ndescribe('--', jsf);\n\nfunction forthelapsed() {\n  w = new Date().getTime();\n  s[++sp] = tos;\n  tos = w - clock;\n}\n\nprimitive('elapsed', forthelapsed);\ndescribe('-- u', jsf); // ----- multi standard selection -----\n\ndefinitions(forth);\n\nfunction forthfig() {\n  m[compliance] = fig;\n}\n\nprimitive('fig', forthfig);\ndescribe('--', jsf);\n\nfunction forthfoerthchen() {\n  m[compliance] = foerthchen;\n}\n\nprimitive('foerthchen', forthfoerthchen);\ndescribe('--', jsf);\n\nfunction forthf79() {\n  m[compliance] = f79;\n}\n\nprimitive('f79', forthf79);\ndescribe('--', jsf);\n\nfunction forthf83() {\n  m[compliance] = f83;\n}\n\nprimitive('f83', forthf83);\ndescribe('--', f83 | jsf);\n\nfunction forthans() {\n  m[compliance] = ans;\n}\n\nprimitive('ans', forthans);\ndescribe('--', jsf);\n\nfunction forthjsforth() {\n  m[compliance] = jsf;\n}\n\nprimitive('jsf', forthjsforth);\ndescribe('--', any | foerthchen); // =================================================================================================\n//                                         virtual machine\n// =================================================================================================\n\ndefinitions(hidden);\n\nfunction forthnest() {\n  r[++rp] = ip;\n  ip = ++w;\n}\n\nvar x_nest = primitive('(nest)', forthnest);\ndescribe('--', jsf);\ndefinitions(forth);\n\nfunction forthunnest() {\n  ip = r[rp--];\n}\n\nvar x_unnest = primitive('exit', forthunnest);\ndescribe('--', any); // =================================================================================================\n//                                           catch, throw\n// =================================================================================================\n\nvar customerror = [];\nvar systemerror = [];\nsystemerror[1] = 'aborted';\nsystemerror[2] = 'aborted';\nsystemerror[3] = 'stack overflow';\nsystemerror[4] = 'stack underflow';\nsystemerror[5] = 'return stack overflow';\nsystemerror[6] = 'return stack underflow';\nsystemerror[7] = 'do loops nested too deeply';\nsystemerror[8] = 'dictionary overflow';\nsystemerror[9] = 'invalid memory address';\nsystemerror[10] = 'division by zero';\nsystemerror[11] = 'result out of range';\nsystemerror[12] = 'argument type mismatch';\nsystemerror[13] = 'word not found';\nsystemerror[14] = 'use only during compilation';\nsystemerror[15] = 'invalid forget';\nsystemerror[16] = 'attempt to use zero-length string as name';\nsystemerror[17] = 'pictured numeric ouput string overflow';\nsystemerror[18] = 'pictured numeric ouput string overflow';\nsystemerror[19] = 'word name too long';\nsystemerror[20] = 'write to a read-only location';\nsystemerror[21] = 'unsupported operation';\nsystemerror[22] = 'unstructured';\nsystemerror[23] = 'address alignment exception';\nsystemerror[24] = 'invalid numeric argument';\nsystemerror[25] = 'return stack imbalance';\nsystemerror[26] = 'loop parameters unavailable';\nsystemerror[27] = 'invalid recursion';\nsystemerror[28] = 'user interrupt';\nsystemerror[29] = 'compiler nesting';\nsystemerror[30] = 'obsolescent feature';\nsystemerror[31] = '>BODY used on non-CREATEd definition';\nsystemerror[32] = 'invalid name argument';\nsystemerror[33] = 'Block read exception';\nsystemerror[34] = 'Block write exception';\nsystemerror[35] = 'Invalid block number';\nsystemerror[36] = 'Invalid file position';\nsystemerror[37] = 'File I/O exception';\nsystemerror[38] = 'File not found'; // additional jsforth error messages:\n\nsystemerror[64] = 'use only while interpreting';\nsystemerror[65] = 'executed BODY> on a non-body address';\nsystemerror[66] = 'unstructured'; // message gets overwritten for more detail\n\nsystemerror[67] = 'TO must be used on a VALUE';\nsystemerror[68] = 'JavaScript boo, mostly the result of uninitialized memory access';\nsystemerror[69] = 'Too many vocabularies';\nsystemerror[70] = 'No cookie by that name found';\nsystemerror[71] = \"Can't write to read-only block\";\nsystemerror[72] = 'Invalid memory region specifier, or heap corrupted';\n\nfunction errordialog(x) {\n  if (x < 0) {\n    if (systemerror[-x]) return \"error(\".concat(x, \"): \").concat(systemerror[-x]);\n    return \"error #\".concat(x);\n  }\n\n  if (customerror[x]) return \"error: \".concat(customerror[x]);\n  return \"error #\".concat(x);\n} // THIS SHOULD BE REPLACED BY THE DESIRED ERROR FUNCTION.\n\n\nfunction _error(str) {\n  info(str);\n} // throw without catch frame - top level error handler\n\n\nfunction exception(x) {\n  var word;\n\n  if (m[blk] >= 0) {\n    var temp = m[toin] % 64;\n    word = pack(parsebuf + m[toin] - temp, temp);\n  } else {\n    word = pack(parsebuf, m[toin]);\n  }\n\n  _error(\"\".concat(word, \": \").concat(errordialog(x))); // just calling the virtual machine won't do, as that would require more and more javascript return stack.\n  //  stopping the interpreter, and have it restart with a one-time event at the warm start point solves this.\n\n\n  debug(\"issuing timed event 'warmstart vm in 1 ms'\");\n  suspended = warm;\n  setTimeout(function () {\n    virtualmachine(warm);\n  }, 1);\n  tos = s[sp--];\n}\n\ndefinitions(hidden);\n\nfunction forththrow0() {\n  catchframe = r[rp];\n  sp = r[--rp];\n  ip = r[--rp];\n  rp--;\n  tos = 0;\n}\n\nvar brthrow0 = dp;\nm[dp++] = primitive('throw0', forththrow0);\ndefinitions(forth);\n\nfunction forthcatch() {\n  r[++rp] = ip;\n  r[++rp] = sp;\n  r[++rp] = catchframe;\n  catchframe = rp;\n  r[++rp] = brthrow0;\n  forthexecute();\n}\n\nvar x_catch = primitive('catch', forthcatch);\ndescribe('xn ... x0 a -- xn ... x0 n', ans | jsf);\n\nfunction throwerror(x) {\n  if (catchframe) {\n    tos = x;\n    rp = catchframe;\n    catchframe = r[rp--];\n    sp = r[rp--];\n    ip = r[rp--];\n  } else {\n    exception(x);\n  }\n}\n\nfunction forththrow() {\n  if (tos != 0) {\n    throwerror(tos);\n  } else {\n    tos = s[sp--];\n  }\n}\n\nvar x_throw = primitive('throw', forththrow);\ndescribe('n --', ans | jsf | f83);\n\nfunction forthnewerror() {\n  if (tos < 0) {\n    systemerror[-tos] = pack(s[sp - 1], s[sp]);\n  } else {\n    customerror[tos] = pack(s[sp - 1], s[sp]);\n  }\n\n  sp -= 2;\n  tos = s[sp--];\n}\n\nprimitive('newerror', forthnewerror);\ndescribe('a n1 n2 --', jsf); // =================================================================================================\n//                                       run time words\n// =================================================================================================\n\ndefinitions(hidden);\n\nfunction forthdolit() {\n  s[++sp] = tos;\n  tos = m[ip++];\n}\n\nvar x_lit = primitive('(lit)', forthdolit);\n\nfunction forthbrsquote() {\n  s[++sp] = tos;\n  tos = m[ip++];\n  s[++sp] = ip;\n  ip += tos;\n}\n\nvar x_brsquote = primitive('(s\")', forthbrsquote);\n\nfunction forthbrcquote() {\n  s[++sp] = tos;\n  tos = ip++;\n  ip += m[tos];\n}\n\nvar x_brcquote = primitive('(c\")', forthbrcquote);\n\nfunction forthbrdotquote() {\n  forthbrsquote();\n  forthpack();\n  type(tos);\n  tos = s[sp--];\n}\n\nvar x_brdotquote = primitive('(.\")', forthbrdotquote);\n\nfunction forthdovar() {\n  s[++sp] = tos;\n  tos = ++w;\n}\n\nvar x_dovar = primitive('(var)', forthdovar);\n\nfunction forthdoconst() {\n  s[++sp] = tos;\n  tos = m[++w];\n}\n\nvar x_doconst = primitive('(const)', forthdoconst);\nvar x_dovalue = primitive('(value)', forthdoconst);\n\nfunction forthdofconst() {\n  f.push(ftos);\n  ftos = m[++w];\n}\n\nvar x_dofconst = primitive('(fconst)', forthdofconst); // function forthdodefer()    { ip=++w ; }\n// branch 1  works as nop,  branch -1 is infinite loop\n\nfunction forthbranch() {\n  ip += m[ip];\n}\n\nvar x_branch = primitive('(branch)', forthbranch);\n\nfunction forth0branch() {\n  if (tos) {\n    ip++;\n  } else {\n    ip += m[ip];\n  }\n\n  tos = s[sp--];\n}\n\nvar x_0branch = primitive('(0branch)', forth0branch);\n\nfunction forthwarminit() {\n  // not for interactive use\n  tos = r[rp];\n  rp = 0;\n  r[rp + 1] = 0;\n  r[rp] = tos;\n  tos = 0;\n  sp = 0;\n  s[sp + 1] = 0;\n  s[sp] = tos;\n  ftos = 0;\n\n  for (; f.length; f.pop()) {\n    ;\n  }\n\n  catchframe = 0;\n  m[state] = 0;\n  m[innerloop] = 0;\n  m[innercase] = 0;\n  m[blk] = -1;\n  m[outfile] = -1;\n\n  for (; inbuf.length; inbuf.pop()) {\n    ;\n  }\n}\n\nvar x_warminit = primitive('warminit', forthwarminit);\n\nfunction forthbrabortquote() {\n  if (tos) {\n    forthbrsquote();\n    forthpack();\n    systemerror[2] = tos;\n    throwerror(-2);\n  } else {\n    tos = s[sp--];\n    ip += m[ip] + 1;\n  }\n}\n\nvar x_brabortquote = primitive('(abort\")', forthbrabortquote);\n\nfunction forthbrto() {\n  m[m[ip++]] = tos;\n  tos = s[sp--];\n}\n\nvar x_brto = primitive('(to)', forthbrto); // --- not portable: output packed string literal ---\n\nfunction jsdotquote() {\n  type(m[ip++]);\n}\n\nvar dotquote = primitive('', jsdotquote); // =================================================================================================\n//                                        stack operators\n// =================================================================================================\n\ndefinitions(forth);\n\nfunction forthdup() {\n  s[++sp] = tos;\n} // dup\n\n\nvar x_dup = primitive('dup', forthdup);\ndescribe('x -- x x', any | foerthchen);\n\nfunction forthqdup() {\n  if (tos) s[++sp] = tos;\n} // ?dup\n\n\nvar x_qdup = primitive('?dup', forthqdup);\ndescribe('x -- 0 | x x', any);\n\nfunction forthdrop() {\n  tos = s[sp--];\n} // drop\n\n\nvar x_drop = primitive('drop', forthdrop);\ndescribe('x --', any | foerthchen);\n\nfunction forthswap() {\n  w = s[sp];\n  s[sp] = tos;\n  tos = w;\n} // swap\n\n\nvar x_swap = primitive('swap', forthswap);\ndescribe('x1 x2 -- x2 x1', any | foerthchen);\n\nfunction forthover() {\n  s[++sp] = tos;\n  tos = s[sp - 1];\n} // over\n\n\nvar x_over = primitive('over', forthover);\ndescribe('x1 x2 -- x1 x2 x1', any);\n\nfunction forthrot() {\n  // rot\n  w = s[sp];\n  s[sp] = tos;\n  tos = s[sp - 1];\n  s[sp - 1] = w;\n}\n\nvar x_rot = primitive('rot', forthrot);\ndescribe('x1 x2 x3 -- x2 x3 x1', any);\n\nfunction forthminrot() {\n  // -rot\n  w = s[sp - 1];\n  s[sp - 1] = tos;\n  tos = s[sp];\n  s[sp] = w;\n}\n\nprimitive('-rot', forthminrot);\ndescribe('x1 x2 x3 -- x3 x1 x2', jsf);\n\nfunction forthtuck() {\n  w = s[sp];\n  s[sp] = tos;\n  s[++sp] = w;\n}\n\nvar x_tuck = primitive('tuck', forthtuck); // tuck\n\ndescribe('x1 x2 -- x2 x1 x2', ans | jsf);\n\nfunction forthnip() {\n  sp--;\n} // nip\n\n\nvar x_nip = primitive('nip', forthnip);\ndescribe('x1 x2 -- x2', ans | jsf);\n\nfunction forth2dup() {\n  s[++sp] = tos;\n  s[++sp] = s[sp - 2];\n} // 2dup\n\n\nvar x_2dup = primitive('2dup', forth2dup);\ndescribe('x1 x2 -- x1 x2 x1 x2', any);\n\nfunction forth2drop() {\n  sp--;\n  tos = s[sp--];\n} // 2drop\n\n\nvar x_2drop = primitive('2drop', forth2drop);\ndescribe('x1 x2 --', any);\n\nfunction forth2swap() {\n  // 2swap\n  w = s[sp - 1];\n  s[sp - 1] = tos;\n  tos = w;\n  w = s[sp - 2];\n  s[sp - 2] = s[sp];\n  s[sp] = w;\n}\n\nprimitive('2swap', forth2swap);\ndescribe('x1 x2 x3 x4 -- x3 x4 x1 x2', any);\n\nfunction forth2over() {\n  // 2over\n  s[++sp] = tos;\n  tos = s[sp - 3];\n  s[++sp] = tos;\n  tos = s[sp - 3];\n}\n\nprimitive('2over', forth2over);\ndescribe('x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2', any);\n\nfunction forthmin() {\n  tos = Math.min(s[sp--], tos);\n} // min\n\n\nvar x_min = primitive('min', forthmin);\ndescribe('n1 n2 -- n3', any);\n\nfunction forthmax() {\n  tos = Math.max(s[sp--], tos);\n} // max\n\n\nprimitive('max', forthmax);\ndescribe('n1 n2 -- n3', any);\n\nfunction forthtor() {\n  r[++rp] = tos;\n  tos = s[sp--];\n} // >r\n\n\nvar x_tor = primitive('>r', forthtor);\ndescribe('x --', any | foerthchen);\n\nfunction forthrfrom() {\n  s[++sp] = tos;\n  tos = r[rp--];\n} // r>\n\n\nvar x_rfrom = primitive('r>', forthrfrom);\ndescribe('-- x', any | foerthchen);\n\nfunction forthrfetch() {\n  s[++sp] = tos;\n  tos = r[rp];\n} // r@\n\n\nvar x_rfetch = primitive('r@', forthrfetch);\ndescribe('-- x', any);\n\nfunction forthrdrop() {\n  rp--;\n} // rdrop\n\n\nvar x_rdrop = primitive('rdrop', forthrdrop);\ndescribe('-- x', jsf);\n\nfunction forth2tor() {\n  // 2>r\n  r[++rp] = s[sp--];\n  r[++rp] = tos;\n  tos = s[sp--];\n}\n\nvar x_2tor = primitive('2>r', forth2tor);\ndescribe('x1 x2 --', ans | jsf | uncertain);\n\nfunction forth2rfrom() {\n  // 2r>\n  s[++sp] = tos;\n  tos = r[rp--];\n  s[++sp] = r[rp--];\n}\n\nvar x_2rfrom = primitive('2r>', forth2rfrom);\ndescribe('-- x1 x2', ans | jsf | uncertain);\n\nfunction forth2rfetch() {\n  // 2r@\n  s[++sp] = tos;\n  tos = r[rp];\n  s[++sp] = r[rp - 1];\n}\n\nvar x_2rfetch = primitive('2r@', forth2rfetch);\ndescribe('-- x1 x2', ans | jsf | uncertain);\n\nfunction forthdepth() {\n  s[++sp] = tos;\n  tos = sp - 1;\n} // depth\n\n\nvar x_depth = primitive('depth', forthdepth);\ndescribe('-- n', ans | f83 | jsf | uncertain);\n\nfunction forthpick() {\n  tos = s[sp - tos];\n} // pick\n\n\nprimitive('pick', forthpick);\ndescribe('xu ... x1 x0 u -- xu ... x1 x0 xu', any);\n\nfunction forthroll() {\n  // roll\n  w = s[sp - tos];\n\n  for (; tos; --tos) {\n    s[sp - tos] = s[sp - tos + 1];\n  }\n\n  sp--;\n  tos = w;\n}\n\nprimitive('roll', forthroll);\ndescribe('xu xu-1 ... x0 u -- xu-1 ... x0 xu', any); // =================================================================================================\n//                                        memory operators\n// =================================================================================================\n\nfunction forthfetch() {\n  tos = m[tos];\n} // @\n\n\nvar x_fetch = primitive('@', forthfetch);\ndescribe('a -- x', any | foerthchen);\n\nfunction forthstore() {\n  m[tos] = s[sp--];\n  tos = s[sp--];\n} // !\n\n\nvar x_store = primitive('!', forthstore);\ndescribe('x a --', any | foerthchen);\n\nfunction forth2fetch() {\n  s[++sp] = m[tos + 1];\n  tos = m[tos];\n} // 2@\n\n\nvar x_2fetch = primitive('2@', forth2fetch);\ndescribe('a -- d', any);\n\nfunction forth2store() {\n  // 2!\n  m[tos++] = s[sp--];\n  m[tos] = s[sp--];\n  tos = s[sp--];\n}\n\nvar x_2store = primitive('2!', forth2store);\ndescribe('d a --', any);\n\nfunction forthcfetch() {\n  tos = m[tos] & 255;\n} // c@\n\n\nvar x_cfetch = primitive('c@', forthcfetch);\ndescribe('a -- c', any);\n\nfunction forthcstore() {\n  m[tos] = s[sp--] & 255;\n  tos = s[sp--];\n} // c!\n\n\nvar x_cstore = primitive('c!', forthcstore);\ndescribe('c a --', any);\n\nfunction forthcount() {\n  s[++sp] = tos + 1;\n  tos = m[tos] & 255;\n} // count\n\n\nvar x_count = primitive('count', forthcount);\ndescribe('a1 -- a2 c', any);\n\nfunction forthskim() {\n  s[++sp] = tos + 1;\n  tos = m[tos];\n} // skim\n\n\nvar x_skim = primitive('skim', forthskim);\ndescribe('a1 -- a2 x', jsf);\n\nfunction forthexchange() {\n  w = m[tos];\n  m[tos] = s[sp--];\n  tos = w;\n} // exchange\n\n\nvar x_exchange = primitive('exchange', forthexchange);\ndescribe('x1 a -- x2', jsf);\n\nfunction forthon() {\n  m[tos] = -1;\n  tos = s[sp--];\n} // on\n\n\nprimitive('on', forthon);\ndescribe('a --', jsf);\n\nfunction forthoff() {\n  m[tos] = 0;\n  tos = s[sp--];\n} // off\n\n\nvar x_off = primitive('off', forthoff);\ndescribe('a --', jsf);\n\nfunction forthfill() {\n  // fill\n  i = s[sp--];\n  var dest = s[sp--];\n\n  for (; i; i--) {\n    m[dest++] = tos;\n  }\n\n  tos = s[sp--];\n}\n\nvar x_fill = primitive('fill', forthfill);\ndescribe('a u c --', any);\n\nfunction fortherase() {\n  s[++sp] = tos;\n  tos = 0;\n  forthfill();\n}\n\nprimitive('erase', fortherase);\ndescribe('a u --', any);\n\nfunction forthslashstring() {\n  //  /string\n  w = tos;\n  tos = s[sp--];\n  if (tos < w) w = tos;\n  s[sp] += w;\n  tos -= w;\n}\n\nvar x_slashstring = primitive('/string', forthslashstring);\ndescribe('a1 n1 u -- a2 n2', ans | jsf | uncertain);\n\nfunction noop() {}\n\nprimitive('align', noop | immediate); // align\n\ndescribe('--', ans | jsf);\nprimitive('aligned', noop | immediate); // aligned\n\ndescribe('a1 -- a2', ans | jsf);\n\nfunction forthpad() {\n  s[++sp] = tos;\n  tos = dp + paddistance;\n}\n\nprimitive('pad', forthpad); // pad\n\ndescribe('-- a', any); // =================================================================================================\n//                                               i/o\n// =================================================================================================\n\nvar x_cr = primitive('cr', cr); // cr\n\ndescribe('--', any);\ndefinitions(forth);\n\nfunction forthspaces() {\n  // spaces\n  for (; tos > linelen; tos -= linelen) {\n    type(lineofspaces);\n  }\n\n  type(lineofspaces.substring(0, tos));\n  tos = s[sp--];\n}\n\nvar x_spaces = primitive('spaces', forthspaces);\ndescribe('n --', any);\ndefinitions(hidden); // --- messages written to dialog screen ---\n\ndefinitions(forth);\n\nfunction forthspace() {\n  type(' ');\n} // space\n\n\nvar x_space = primitive('space', forthspace);\ndescribe('--', any);\n\nfunction forthemit() {\n  emit(tos);\n  tos = s[sp--];\n} // emit\n\n\nvar x_emit = primitive('emit', forthemit);\ndescribe('c --', any | foerthchen);\n\nfunction forthtype() {\n  // type\n  forthpack();\n  type(tos);\n  tos = s[sp--];\n}\n\nvar x_type = primitive('type', forthtype);\ndescribe('--', any);\nvar x_page = primitive('page', cls); // page\n\ndescribe('--', ans | f83 | jsf);\nprimitive('cls', cls);\ndescribe('--', jsf); // THIS SHOULD BE REPLACED BY THE DESIRED PROMPTING FUNCTION.\n\nfunction _prompt() {// Nothing.\n}\n\nfunction forthprompt() {\n  // prompt\n  _prompt();\n}\n\nvar x_prompt = primitive('prompt', forthprompt);\ndescribe('--', any);\n\nfunction forthdots() {\n  // .s\n  s[++sp] = tos;\n\n  for (var _i6 = 1; _i6 < sp; type(\"\".concat(s[++_i6].toString(m[base]), \" \"))) {\n    ;\n  }\n\n  sp--;\n}\n\nvar x_dots = primitive('.s', forthdots);\ndescribe('--', any); // read string, delimited by c. return address and len\n// updates source\n\nfunction forthparse() {\n  // parse\n  var delimiter = tos;\n  w = m[toin] + parsebuf; //  parse address\n\n  var bufend = parsebuf + parsebuflen;\n  var nxtchar = m[w];\n\n  if (delimiter == bl) {\n    for (; w < bufend;) {\n      if (nxtchar != delimiter) break;\n      nxtchar = m[++w];\n    }\n  }\n\n  s[++sp] = w;\n\n  for (; w < bufend;) {\n    nxtchar = m[w];\n    if (nxtchar == delimiter) break;\n    w++;\n  }\n\n  tos = w - s[sp];\n  if (nxtchar == delimiter) w++;\n  m[toin] = w - parsebuf;\n}\n\nvar x_parse = primitive('parse', forthparse);\ndescribe('c -- a n', ans | jsf);\ndefinitions(hidden); // key and key?  come in two parts:\n//  part 1 signals to virtual machine to stop execution,\n//  part 2 will be executed after the input event occured\n// the high level key and key? word call both parts, and, at the\n// same time, provide the after-event reentry point.\n\nfunction forthkey1() {\n  if (!inbuf.length) {\n    suspended = w;\n\n    _input(function () {\n      virtualmachine(ip);\n    });\n  }\n}\n\nvar x_key1 = primitive('key1', forthkey1);\ndescribe('--', jsf);\n\nfunction forthkey2() {\n  s[++sp] = tos;\n  tos = inbuf.shift();\n}\n\nvar x_key2 = primitive('key2', forthkey2);\ndescribe('-- c', jsf);\n\nfunction forthkey1query() {\n  if (!inbuf.length) {\n    // key buffered - no need for event\n    suspended = w; // stop interpreter shortly to allow possible key event\n\n    setTimeout(function () {\n      virtualmachine(ip);\n    }, 0); // restart short time later\n  }\n}\n\nvar x_key1query = primitive('key1?', forthkey1query);\ndescribe('--', jsf);\n\nfunction forthkey2query() {\n  s[++sp] = tos;\n  tos = 0; // assume \"no key\"\n\n  if (inbuf.length) tos--; // flag \"key available\"\n}\n\nvar x_key2query = primitive('key2?', forthkey2query);\ndescribe('-- f', jsf); // ( bufaddr editaddr nkeys ascii -- bufaddr editaddr nkeys )\n\nfunction forthacceptprintable() {\n  w = tos;\n  tos = s[sp--]; // w:asc,  tos:n keys to go, s[sp]:editing address, s[sp-1]: buffer start\n\n  if (tos > 1) {\n    m[s[sp]] = w;\n    s[sp]++;\n    tos--;\n  }\n} // ( bufaddr editaddr nkeys ascii -- bufaddr editaddr nkeys )\n\n\nfunction forthacceptescape() {\n  tos = s[sp--]; // tos:n keys to go, s[sp]:editing address, s[sp-1]: buffer start\n\n  tos += s[sp] - s[sp - 1];\n  backspaces(s[sp] - s[sp - 1]);\n  s[sp] = s[sp - 1];\n} // ( bufaddr editaddr nkeys ascii -- bufaddr editaddr nkeys )\n// attempt internet explorer workaround\n\n\nfunction forthacceptbackspace() {\n  tos = s[sp--];\n\n  if (s[sp] > s[sp - 1]) {\n    tos++;\n    s[sp]--;\n    backspaces(1);\n  }\n}\n\nfunction forthacceptreturn() {\n  sp--;\n  tos = 0;\n}\n\nfunction forthaccepttab() {\n  tos = bl;\n  forthacceptprintable();\n} // ( bufaddr editaddr nkeys ascii -- bufaddr editaddr nkeys )\n\n\nfunction forthacceptcontrolchar(ctrlchar) {\n  if (ctrlchar == esc) {\n    forthacceptescape();\n    return;\n  }\n\n  if (ctrlchar == backspace) {\n    forthacceptbackspace();\n    return;\n  }\n\n  if (ctrlchar == 17) {\n    forthacceptbackspace();\n    return;\n  } // ctrl-q for IE\n\n\n  if (ctrlchar == carriagereturn) {\n    forthacceptreturn();\n    return;\n  }\n\n  if (ctrlchar == tab) {\n    forthaccepttab();\n    return;\n  }\n\n  tos = s[sp--];\n}\n\nfunction forthdecode() {\n  // ( bufaddr editaddr nkeys ascii -- bufaddr editaddr nkeys )\n  if (tos < bl) {\n    forthacceptcontrolchar(tos);\n  } else {\n    forthacceptprintable(tos);\n  }\n\n  debug(\"\".concat(s[sp - 1], \" \").concat(s[sp], \" \").concat(tos));\n}\n\nvar x_decode = primitive('decode', forthdecode);\ndescribe('a1 a2 n1 c -- a1 a3 n2 f', jsf);\ndefinitions(forth);\n\nfunction forthfast() {\n  m[outfile] = -1;\n}\n\nprimitive('fast', forthfast);\ndescribe('--', jsf);\n\nfunction forthslow() {\n  m[outfile] = -2;\n}\n\nprimitive('slow', forthslow);\ndescribe('--', jsf);\n\nfunction forthsource() {\n  s[++sp] = tos;\n  s[++sp] = parsebuf;\n  tos = parsebuflen;\n}\n\nvar x_source = primitive('source', forthsource);\ndescribe('-- a n', any);\n\nfunction forthstoresource() {\n  parsebuflen = tos;\n  parsebuf = s[sp--];\n  tos = s[sp--]; //   m[toin] = 0 ;\n}\n\nvar x_storesource = primitive('!source', forthstoresource);\ndescribe('a n --', jsf);\ndefinitions(hidden);\n\nfunction forthpushsource() {\n  sourceid.push(m[toin], parsebuf, parsebuflen);\n}\n\nvar x_pushsource = primitive('pushsource', forthpushsource);\n\nfunction forthpopsource() {\n  parsebuflen = sourceid.pop();\n  parsebuf = sourceid.pop();\n  m[toin] = sourceid.pop();\n}\n\nvar x_popsource = primitive('popsource', forthpopsource); // ------------- cookies ------------\n\nvar translatedchar = []; // each ascii requiring translation flags it here\n\nfor (i = 0; i < 256; i++) {\n  translatedchar[i] = '';\n} // assume no translation required\n\n\ntranslatedchar[0] = 'A';\ntranslatedchar[9] = 'B';\ntranslatedchar[10] = 'C';\ntranslatedchar[13] = 'D';\ntranslatedchar[32] = 'E';\ntranslatedchar[37] = 'F';\ntranslatedchar[59] = 'G';\nvar translatechar = [0, 9, 10, 13, 32, 37, 59];\n\nfunction encoded(text) {\n  var result = '';\n  var asc;\n\n  for (i = 0; i < text.length; i++) {\n    asc = text.charCodeAt(i);\n\n    if (translatedchar[asc]) {\n      result += \"%\".concat(translatedchar[asc]);\n    } else {\n      result += text.charAt(i);\n    }\n  }\n\n  return result;\n}\n\nfunction decoded(text) {\n  var result = '';\n  var asc;\n\n  for (i = 0; i < text.length; i++) {\n    asc = text.charAt(i);\n    if (asc == '%') asc = String.fromCharCode(translatechar[text.charCodeAt(++i) - 65]);\n    result += asc;\n  }\n\n  return result;\n}\n\nfunction setcookie(name, value, domain, expires, path, secure) {\n  var cook = \"\".concat(name, \"=\").concat(encoded(value.substr(0, 2048)));\n  cook += domain ? \"; domain=\".concat(domain) : '';\n  cook += expires ? \"; expires=\".concat(expires) : '';\n  cook += path ? \"; path=\".concat(domain) : '';\n  cook += secure ? \"; secure=\".concat(domain) : '';\n  document.cookie = cook;\n}\n\nfunction readcookie(name) {\n  var cookiebegin = document.cookie.indexOf(\"\".concat(name, \"=\"));\n  if (cookiebegin == -1) return null;\n  var temp = document.cookie.substr(cookiebegin + name.length + 1);\n  var cookieend = temp.indexOf(';');\n  if (cookieend != -1) return decoded(temp.substr(0, cookieend));\n  return decoded(temp);\n}\n\ndefinitions(forth);\n\nfunction forthsetcookie() {\n  setcookie(pack(s[sp - 2], s[sp - 1]), pack(s[sp], tos));\n  sp -= 3;\n  tos = s[sp--];\n}\n\nprimitive('cookie!', forthsetcookie);\ndescribe('a1 n1 a2 n2 --', jsf);\n\nfunction forthreadcookie() {\n  w = readcookie(pack(s[sp - 1], s[sp]));\n\n  if (w) {\n    s[--sp] = w;\n    unpack();\n  } else {\n    throwerror(-70);\n  }\n}\n\nprimitive('cookie@', forthreadcookie);\ndescribe('a1 n1 a2 -- n2', jsf); // =================================================================================================\n//                                          arithmetics\n// =================================================================================================\n\ndefinitions(forth);\n\nfunction forth1plus() {\n  tos++;\n} // 1+\n\n\nvar x_1plus = primitive('1+', forth1plus);\ndescribe('x -- x+1', ans | f83 | jsf);\nprimitive('cell+', forth1plus); // cell+\n\ndescribe('x -- x+cell', ans | f83 | jsf);\nprimitive('char+', forth1plus); // char+\n\ndescribe('x -- x+char', ans | jsf);\n\nfunction forth1minus() {\n  tos--;\n} // 1-\n\n\nvar x_1minus = primitive('1-', forth1minus);\ndescribe('x -- x-1', any);\nprimitive('cell-', forth1minus); // cell-\n\ndescribe('x -- x-cell', ans | f83 | jsf);\n\nfunction forth2mul() {\n  tos <<= 1;\n} // 2*\n\n\nvar x_2mul = primitive('2*', forth2mul);\ndescribe('x1 -- x2', any);\n\nfunction forth2div() {\n  tos >>= 1;\n} // 2/\n\n\nvar x_2div = primitive('2/', forth2div);\ndescribe('n1 -- n2', any);\n\nfunction forthplus() {\n  tos += s[sp--];\n} // +\n\n\nvar x_plus = primitive('+', forthplus);\ndescribe('x1 x2 -- x1+x2', any | foerthchen);\n\nfunction forthminus() {\n  tos = s[sp--] - tos;\n} // -\n\n\nvar x_minus = primitive('-', forthminus);\ndescribe('x1 x2 -- x1-x2', any);\n\nfunction forthmul() {\n  tos = tos * s[sp--] & 0xffffffff;\n} // *\n\n\nvar x_mul = primitive('*', forthmul);\ndescribe('x1 x2 -- x1*x2', any | foerthchen);\nvar floorfix = 1 - 1e-16;\n\nfunction forthdiv() {\n  // /\n  if (tos) {\n    tos = s[sp--] / tos;\n    if (tos < 0) tos += floorfix;\n    tos = Math.floor(tos);\n    return;\n  }\n\n  throwerror(-10);\n}\n\nvar x_div = primitive('/', forthdiv);\ndescribe('x1 x2 -- x1/x2', any);\n\nfunction forthstarslash() {\n  // */\n  if (tos) {\n    tos = s[sp--] * s[sp--] / tos;\n    if (tos < 0) tos += floorfix;\n    tos = Math.floor(tos);\n    return;\n  }\n\n  throwerror(-10);\n}\n\nvar x_starslash = primitive('*/', forthstarslash);\ndescribe('x1 x2 x3 -- x1*x2/x3', any);\n\nfunction forthmod() {\n  // mod\n  if (tos) {\n    tos = s[sp--] % tos;\n    return;\n  }\n\n  throwerror(-10);\n}\n\nvar x_mod = primitive('mod', forthmod);\ndescribe('x1 x2 -- x3', any);\n\nfunction forthslashmod() {\n  // /mod\n  if (tos) {\n    w = s[sp] % tos;\n    tos = s[sp] / tos;\n    if (tos < 0) tos += floorfix;\n    tos = Math.floor(tos);\n    s[sp] = w;\n    return;\n  }\n\n  throwerror(-10);\n}\n\nvar x_slashmod = primitive('/mod', forthslashmod);\ndescribe('x1 x2 -- x3 x4', any | foerthchen);\n\nfunction forthstarslashmod() {\n  // */mod\n  if (tos) {\n    w = s[sp--] * s[sp];\n    s[sp] = w % tos;\n    tos = w / tos;\n    if (tos < 0) tos += floorfix;\n    tos = Math.floor(tos);\n    return;\n  }\n\n  throwerror(-10);\n}\n\nvar x_starslashmod = primitive('*/mod', forthstarslashmod);\ndescribe('x1 x2 x3 -- x4 x5', any);\n\nfunction forthnegate() {\n  tos = -tos;\n} // negate\n\n\nvar x_negate = primitive('negate', forthnegate);\ndescribe('n -- -n', any);\n\nfunction forthabs() {\n  tos = Math.abs(tos);\n} // abs\n\n\nvar x_abs = primitive('abs', forthabs);\ndescribe('n -- u', any);\n\nfunction forthlshift() {\n  if (tos > 31) {\n    tos = 0;\n    sp--;\n  } else {\n    tos = s[sp--] << tos; // lshift\n  }\n}\n\nvar x_lshift = primitive('lshift', forthlshift);\ndescribe('x1 u --x2', ans | f83 | jsf);\nprimitive('<<', forthlshift);\ndescribe('x1 u -- x2', jsf);\n\nfunction forthrshift() {\n  if (tos > 31) {\n    tos = 0;\n    sp--;\n  } else {\n    tos = s[sp--] >>> tos; // rshift\n  }\n}\n\nvar x_rshift = primitive('rshift', forthrshift);\ndescribe('u1 u2 -- x3', ans | f83 | jsf);\nprimitive('>>', forthrshift);\ndescribe('u1 u2 -- u3', jsf);\n\nfunction forthplusstore() {\n  m[tos] += s[sp--];\n  tos = s[sp--];\n} // +!\n\n\nvar x_plusstore = primitive('+!', forthplusstore);\ndescribe('x a --', any);\nprimitive('cells', noop, immediate);\ndescribe('x1 -- x2', ans | f83 | jsf);\nprimitive('chars', noop, immediate); // chars\n\ndescribe('x1 -- x2', ans | jsf);\n\nfunction forthrange() {\n  var temp = tos;\n  tos = s[sp];\n  s[sp] += temp;\n}\n\nvar x_range = primitive('range', forthrange);\ndescribe('x n -- x+n x', ans | jsf | f83); // ----- double and mixed len math -----\n\nfunction forthstod() {\n  // s>d\n  s[++sp] = tos;\n  tos &= 0x80000000;\n  if (tos) tos = -1;\n}\n\nvar x_stod = primitive('s>d', forthstod);\ndescribe('x -- d', any);\n\nfunction forthdnegate() {\n  // dnegate\n  tos = -tos;\n  s[sp] = -s[sp];\n  if (s[sp]) tos--;\n}\n\nprimitive('dnegate', forthdnegate);\ndescribe('d1 -- -d1', any);\n\nfunction forthdabs() {\n  // dabs\n  if (tos < 0) {\n    tos = -tos;\n    s[sp] = -s[sp];\n    if (s[sp]) tos--;\n  }\n}\n\nvar x_dabs = primitive('dabs', forthdabs);\ndescribe('d -- ud', any);\n\nfunction forthdplus() {\n  // d+\n  if (tos < 0) tos += 0x100000000;\n  var low2 = s[sp--];\n  if (low2 < 0) low2 += 0x100000000;\n  var high1 = s[sp--];\n  if (high1 < 0) high1 += 0x100000000;\n  var low1 = s[sp];\n  if (low1 < 0) low1 += 0x100000000;\n  tos += high1;\n  w = low1 + low2;\n\n  if (w > 0x100000000) {\n    // detect carry\n    w &= 0xffffffff;\n    tos++; // apply carry\n  }\n\n  s[sp] = w;\n  tos &= 0xffffffff;\n}\n\nvar x_dplus = primitive('d+', forthdplus);\ndescribe('d1 d2 -- d1+d2', any);\n\nfunction forthummul() {\n  // ( u1 u2 -- ud )                       // um*\n  var resultlo = 0;\n  var resulthi = 0;\n  var temp = s[sp];\n\n  for (var _i7 = 32; _i7; --_i7) {\n    resulthi <<= 1;\n    if (resultlo & 0x80000000) resulthi++;\n    resultlo <<= 1;\n\n    if (tos & 0x80000000) {\n      if (resultlo + temp > 0xffffffff) resulthi++;\n      resultlo += temp;\n    }\n\n    tos <<= 1;\n  }\n\n  s[sp] = resultlo;\n  tos = resulthi;\n}\n\nvar x_ummul = primitive('um*', forthummul);\ndescribe('n1 n2 -- ud', any);\n\nfunction forthmmul() {\n  // m*\n  var temp = tos < 0 ^ s[sp] < 0;\n  tos = Math.abs(tos);\n  s[sp] = Math.abs(s[sp]);\n  forthummul();\n  if (temp) forthdnegate();\n}\n\nvar x_mmul = primitive('m*', forthmmul);\ndescribe('n1 n2 -- d', any);\n\nfunction forthdless() {\n  // d<\n  w = tos;\n  tos = 0;\n\n  if (s[sp - 1] < w) {\n    tos = -1;\n  } else if (s[sp - 1] == w) {\n    if (s[sp - 2] < s[sp]) tos = -1;\n  }\n\n  sp -= 3;\n}\n\nprimitive('d<', forthdless);\ndescribe('d1 d2 -- f', any);\n\nfunction forthdequ() {\n  // d=\n  tos = -(tos == s[sp - 1] & s[sp] == s[sp - 2]);\n  sp -= 3;\n}\n\nprimitive('d=', forthdequ);\ndescribe('d1 d2 -- f', any);\n\nfunction forthumslashmod() {\n  //    ( d u1 -- u2 u3 )\n  // skip leading zeroes  (not done)\n  // shift-and-subtract division\n  // tos = divisor\n  var quotient = 0;\n  var remainder = 0; // portion of divident\n\n  var divbit = 0;\n\n  if (tos) {\n    // hi part not 0 ?\n    divbit = 0x80000000;\n\n    for (; divbit; divbit >>>= 1) {\n      // skip trailinz zeroes\n      if ((tos & divbit) == 0) break; // \"late in\" in contrast to \"early out\"\n    }\n  }\n\n  for (var j = 2; j; j--) {\n    // crunch 2x 32 bit\n    var divident = s[sp--]; // next divident portion\n\n    for (; divbit; divbit >>>= 1) {\n      remainder <<= 1;\n      if (divident & divbit) remainder++;\n      quotient <<= 1;\n\n      if (remainder >= tos) {\n        remainder -= tos;\n        quotient++;\n      }\n    }\n\n    divbit = 0x80000000;\n  }\n\n  tos = quotient;\n  s[++sp] = remainder;\n}\n\nprimitive('um/mod', forthumslashmod);\ndescribe('d u1 -- u2 u3', any);\n\nfunction forthudslashmod() {\n  //    ( d1 u1 -- u2 d2 )\n  w = tos;\n  s[++sp] = 0;\n  forthumslashmod();\n  s[++sp] = w;\n  w = tos;\n  tos = s[sp--];\n  forthumslashmod();\n  s[++sp] = tos;\n  tos = w;\n}\n\nvar x_udslashmod = primitive('ud/mod', forthudslashmod);\ndescribe('d1 u1 -- u2 d2', jsf); // =================================================================================================\n//                                               bool\n// =================================================================================================\n\ndefinitions(forth);\n\nfunction forthor() {\n  tos |= s[sp--];\n} // or\n\n\nvar x_or = primitive('or', forthor);\ndescribe('x1 x2 -- x3', any | foerthchen);\n\nfunction forthand() {\n  tos &= s[sp--];\n} // and\n\n\nvar x_and = primitive('and', forthand);\ndescribe('x1 x2 -- x3', any | foerthchen);\n\nfunction forthxor() {\n  tos ^= s[sp--];\n} // xor\n\n\nprimitive('xor', forthxor);\ndescribe('x1 x2 -- x3', any | foerthchen);\n\nfunction forthinvert() {\n  tos ^= -1;\n} // invert\n\n\nprimitive('invert', forthinvert);\ndescribe('x1 -- x2', ans | jsf);\nprimitive('not', forthinvert); // not\n\ndescribe('x1 -- x2', fig | f79); // =================================================================================================\n//                                              logic\n// =================================================================================================\n\nfunction forthequ() {\n  tos = -(tos == s[sp--]);\n} // =\n\n\nvar x_equ = primitive('=', forthequ);\ndescribe('x1 x2 -- f', any);\n\nfunction forthnequ() {\n  tos = -(tos != s[sp--]);\n} // <>\n\n\nvar x_nequ = primitive('<>', forthnequ);\ndescribe('x1 x2 -- f', any);\n\nfunction forthmore() {\n  tos = -(tos < s[sp--]);\n} // >\n\n\nvar x_more = primitive('>', forthmore);\ndescribe('n1 n2 -- f', any);\n\nfunction forthless() {\n  tos = -(tos > s[sp--]);\n} // <\n\n\nvar x_less = primitive('<', forthless);\ndescribe('n1 n2 -- f', any);\n\nfunction forth0equ() {\n  tos = -(tos == 0);\n} // 0=\n\n\nvar x_0equ = primitive('0=', forth0equ);\ndescribe('x -- f', any);\n\nfunction forth0nequ() {\n  tos = -(tos != 0);\n} // 0<>\n\n\nprimitive('0<>', forth0nequ);\ndescribe('x -- f', any);\n\nfunction forth0less() {\n  tos = -(tos < 0);\n} // 0<\n\n\nvar x_0less = primitive('0<', forth0less);\ndescribe('n -- f', any);\n\nfunction forth0greater() {\n  tos = -(tos > 0);\n} // 0>\n\n\nvar x_0greater = primitive('0>', forth0greater);\ndescribe('n -- f', any);\n\nfunction forthuless() {\n  // u<\n  w = s[sp--];\n  if (tos < 0) tos += 0x100000000;\n  if (w < 0) w += 0x100000000;\n  tos = -(w < tos);\n}\n\nprimitive('u<', forthuless);\ndescribe('u1 u2 -- f', any);\n\nfunction forthumore() {\n  // u>\n  w = s[sp--];\n  if (tos < 0) tos += 0x100000000;\n  if (w < 0) w += 0x100000000;\n  tos = -(w > tos);\n}\n\nprimitive('u>', forthumore);\ndescribe('u1 u2 -- f', any);\n\nfunction forthwithin() {\n  // ( x1 x2 x3 -- flag )              // within\n  w = s[sp--];\n  var temp = s[sp--];\n  var temp2 = tos;\n  tos = -1;\n\n  if (w < temp2) {\n    if (w <= temp) {\n      if (temp < temp2) return;\n    }\n  }\n\n  if (w > temp2) {\n    if (w <= temp) return;\n    if (temp < temp2) return;\n  }\n\n  tos++;\n}\n\nprimitive('within', forthwithin);\ndescribe('x1 x2 x3 -- f', any); // =================================================================================================\n//                                    pictured number conversion\n// =================================================================================================\n// non standard stack: does currently not expect double, but single number\n// that's why further implementation has been postponed - need double math first.\n// ( d -- d )\n\nvar picturedoutpos;\nvar picturedoutlen;\n\nfunction forthlesshash() {\n  // <#\n  picturedoutpos = dp + paddistance;\n  picturedoutlen = 0; // avoiding len calc allow to allot\n} // during pic num conv\n\n\nvar x_lesshash = primitive('<#', forthlesshash);\ndescribe('--', any);\n\nfunction forthhold() {\n  m[--picturedoutpos] = tos;\n  picturedoutlen++;\n  tos = s[sp--];\n}\n\nvar x_hold = primitive('hold', forthhold);\ndescribe('c --', any);\n\nfunction forthsign() {\n  if (tos < 0) {\n    m[--picturedoutpos] = 45;\n    picturedoutlen++;\n  }\n\n  tos = s[sp--];\n}\n\nvar x_sign = primitive('sign', forthsign);\ndescribe('n --', any);\n\nfunction forthhashmore() {\n  // #>\n  s[sp] = picturedoutpos;\n  tos = picturedoutlen;\n} // during pic num conv\n\n\nvar x_hashmore = primitive('#>', forthhashmore);\ndescribe('-- a n', any); // =================================================================================================\n//                                               does>\n// =================================================================================================\n\ndefinitions(hidden); // linkage code for word, created by defining word.\n\nfunction dodoes() {\n  s[++sp] = tos;\n  tos = x[w]; // push words address of defined word\n\n  r[++rp] = ip; // nest\n\n  ip = m[tos++]; // set ip to does> part, and tos to body of defined word\n\n  w = m[ip++];\n  t[w](); // next\n} // compiled to end of create part by does>\n// executed during execution of defining word\n\n\nfunction setdoes() {\n  // tos: xt of does> part\n  m[x[wc]] = ip + 1; // created word points to does>\n\n  t[wc] = dodoes; // created word linkage code is dodoes\n}\n\nvar x_setdoes = primitive('setdoes', setdoes); // =================================================================================================\n//                                             flow control\n// =================================================================================================\n\ndefinitions(hidden);\n\nfunction forthbrfor() {\n  r[++rp] = tos;\n  r[++rp] = tos;\n  ip++;\n  tos = s[sp--];\n}\n\nvar x_brfor = primitive('(for)', forthbrfor);\n\nfunction forthbrnext() {\n  r[rp]--;\n\n  if (r[rp]) {\n    ip += m[ip];\n  } else {\n    ip++;\n    rp -= 2;\n  }\n}\n\nvar x_brnext = primitive('(next)', forthbrnext);\n\nfunction forthbrdo() {\n  r[++rp] = s[sp--];\n  r[++rp] = tos;\n  ip++;\n  tos = s[sp--];\n}\n\nvar x_brdo = primitive('(do)', forthbrdo);\n\nfunction forthbrqdo() {\n  if (tos == s[sp]) {\n    sp--;\n    ip += m[ip];\n  } else {\n    r[++rp] = s[sp--];\n    r[++rp] = tos;\n    ip++;\n  }\n\n  tos = s[sp--];\n}\n\nvar x_brqdo = primitive('(?do)', forthbrqdo); // fig/f79 leave\n\nfunction forthbrleave79() {\n  r[rp] = r[rp - 1] - 1;\n}\n\nvar x_brleave79 = primitive('(leave)', forthbrleave79); // ans/f83 leave\n\nfunction forthbrleave() {\n  rp -= 2;\n  ip = m[ip];\n  ip += m[ip];\n}\n\nvar x_brleave = primitive('(leave)', forthbrleave);\n\nfunction forthbrqleave() {\n  if (tos) {\n    rp -= 2;\n    ip = m[ip];\n    ip += m[ip];\n  } else {\n    ip++;\n  }\n\n  tos = s[sp--];\n}\n\nvar x_brqleave = primitive('(?leave)', forthbrqleave);\n\nfunction forthbrloop() {\n  r[rp]++;\n\n  if (r[rp] != r[rp - 1]) {\n    ip += m[ip];\n  } else {\n    ip++;\n    rp -= 2;\n  }\n}\n\nvar x_brloop = primitive('(loop)', forthbrloop);\ndescribe('--', jsf);\n\nfunction forthbrplusloop() {\n  // (+loop)\n  w = r[rp] - r[rp - 1];\n  r[rp] += tos;\n  tos = s[sp--];\n\n  if ((r[rp] - r[rp - 1] ^ w) > 0) {\n    ip += m[ip];\n  } else {\n    ip++;\n    rp -= 2;\n  }\n}\n\nvar x_brplusloop = primitive('(+loop)', forthbrplusloop);\ndescribe('n --', jsf);\n\nfunction forthbrunloop() {\n  rp -= 2;\n}\n\nvar x_brunloop = primitive('(unloop)', forthbrunloop);\ndescribe('--', jsf);\n\nfunction forthbrof() {\n  // (of)\n  w = tos;\n  tos = s[sp--];\n\n  if (w == tos) {\n    tos = s[sp--];\n    ip++;\n  } else {\n    ip += m[ip];\n  }\n}\n\nvar x_brof = primitive('(of)', forthbrof);\ndescribe('x1 x2 -- x1 |', jsf);\ndefinitions(forth);\n\nfunction forthexecute() {\n  w = tos;\n  tos = s[sp--];\n  t[w]();\n}\n\nvar x_execute = primitive('execute', forthexecute);\ndescribe('xt --', any);\n\nfunction forthperform() {\n  w = m[tos];\n  tos = s[sp--];\n  t[w]();\n}\n\nvar x_perform = primitive('perform', forthperform);\ndescribe('a --', jsf);\n\nfunction forthi() {\n  s[++sp] = tos;\n  tos = r[rp];\n}\n\nvar x_i = primitive('i', forthi);\ndescribe('-- x', any);\n\nfunction forthj() {\n  s[++sp] = tos;\n  tos = r[rp - 2];\n}\n\nvar x_j = primitive('j', forthj);\ndescribe('-- x', any);\ndefinitions(hidden);\nvar controlflow = ['', 'if', '', 'begin', 'while', 'do or ?do', 'for', 'case', 'of'];\nvar controlflowwant = ['', 'else or then', 'then', 'while,until or again', 'repeat', 'loop or +loop', 'next', 'endcase', 'endof'];\n\nfunction forthunstructured() {\n  systemerror[66] = \"unstructured, missing \".concat(controlflow[tos], \", expected \").concat(controlflowwant[s[sp]]);\n  throwerror(-66);\n}\n\nvar x_unstructured = primitive('unstructured', forthunstructured); // =================================================================================================\n//                                             strings\n// =================================================================================================\n\ndefinitions(forth);\n\nfunction forthmove() {\n  // move\n  if (s[sp] > s[sp + 1]) {\n    dest = s[sp--] + tos;\n    src = s[sp--] + tos;\n\n    for (; tos; tos--) {\n      m[--dest] = m[--src];\n    }\n  } else {\n    var dest = s[sp--];\n    var src = s[sp--];\n\n    for (; tos; tos--) {\n      m[dest++] = m[src++];\n    }\n  }\n\n  tos = s[sp--];\n}\n\nvar x_move = primitive('move', forthmove);\ndescribe('a1 a2 u --', any);\nprimitive('cmove', forthmove);\ndescribe('a1 a2 u', any);\ndefinitions(hidden);\n\nfunction forthmovestr() {\n  // ( a1 n a2 -- )      // move$\n  w = s[sp];\n  m[tos++] = w;\n  s[sp] = tos;\n  tos = w;\n  forthmove();\n}\n\nvar x_movestr = primitive('move$', forthmovestr);\ndescribe('a1 n a2 --', jsf);\ndefinitions(forth);\n\nfunction forthmintrailing() {\n  // a1 n1 -- a2 n2 )\n  var temp = s[sp] + tos;\n\n  for (i = tos; i; i--) {\n    if (m[--temp] != 32) break;\n    tos--;\n  }\n}\n\nvar x_mintrailing = primitive('-trailing', forthmintrailing);\ndescribe('a1 u1 -- a2 u2', any); // ----- number input conversion -----\n\nfunction forthdigit() {\n  // ( c -- u | -1 )\n  tos -= 48;\n\n  if (tos > 9) {\n    if (tos < 17) tos = -1;\n    tos -= 7;\n  }\n\n  if (tos > 41) tos -= 32;\n\n  if (tos >= 0) {\n    if (tos < m[base]) return;\n  }\n\n  tos = -1;\n}\n\nvar x_digit = primitive('digit', forthdigit);\ndescribe('c -- u|-1', jsf);\ndefinitions(hidden);\n\nfunction forthqsinglenumber() {\n  // a n -- x -1 | 0 )\n  var digit;\n  var sign = 0;\n  var radix = m[base];\n  i = tos; // number of digits to test/convert\n\n  tos = -1; // assume valid number\n\n  w = s[sp]; // addr of next digit\n\n  s[sp] = 0; // accumulator\n\n  if (m[w] == 45) {\n    // leading -\n    sign = -1;\n    w++; // strip\n\n    i--;\n  }\n\n  for (var i; i; i--) {\n    // for all digits\n    digit = m[w++] - 48; // read digit\n\n    if (digit == -2) exception('no input support for floating point numbers yet');\n\n    if (digit > 9) {\n      if (digit < 17) {\n        tos = 0;\n        break;\n      }\n\n      digit -= 7;\n    }\n\n    if (digit > 41) digit -= 32;\n\n    if (digit < 0) {\n      tos = 0;\n      break;\n    }\n\n    if (digit >= radix) {\n      tos = 0;\n      break;\n    }\n\n    s[sp] *= radix;\n    s[sp] += digit;\n  }\n\n  if (tos) {\n    if (sign) s[sp] = -s[sp];\n    s[sp] &= 0xffffffff;\n  } else {\n    sp--; // drop string address\n  }\n} // parseFloat(string) ;\n\n\nfunction forthqnumber() {\n  // a n -- x -1 | 0 )\n  if (m[s[sp] + tos - 1] == 46) {\n    exception('no input support for double length numbers yet');\n    sp--;\n    tos = 0;\n  } else {\n    forthqsinglenumber();\n  }\n}\n\nvar x_qnumber = primitive('?number', forthqnumber);\n\nfunction forthinterpretnumber() {\n  // ( a n -- x -1 | d -1 | r -1 | -1 | 0 )\n  forthqnumber();\n\n  if (tos) {\n    if (m[state]) {\n      m[dp++] = x_lit;\n      m[dp++] = s[sp--];\n      tos = -1;\n    }\n  }\n}\n\nvar x_interpretnumber = primitive('interpretnumber', forthinterpretnumber); // function forthinterpretnumber()\n//    first char = - ?\n//    if remember skip then\n//    for all chars in string:\n//       next char = digit ?\n//      if accumulate\n//      else\n//        char = . ?\n//        if\n//\n//        else\n//          otherlegalchars? none if NaN then\n//        then\n//      then\n//    next\n//    negate?\n//    state @ if\n//      compile lit\n//    then  ;\n// =================================================================================================\n//                                      dictionary, compiling\n// =================================================================================================\n\ndefinitions(forth); // this has been speeded up a lot, by using an\n// improvement suggested by TheBlueWizard.\n\nfunction forthwords() {\n  // words\n  for (var _i8 = wc; _i8; _i8--) {\n    if (h[_i8]) {\n      if (m[context] & ds[_i8]) {\n        if (m[compliance] & ds[_i8]) querytype(\"\".concat(h[_i8], \" \"));\n      }\n    }\n  }\n}\n\nvar x_words = primitive('words', forthwords);\ndescribe('--', f83 | ans | jsf | foerthchen | only);\n\nfunction forthvlist() {\n  forthwords();\n}\n\nprimitive('vlist', forthvlist);\ndescribe('--', f79 | fig);\n\nfunction forthhere() {\n  s[++sp] = tos;\n  tos = dp;\n} // here\n\n\nvar x_here = primitive('here', forthhere);\ndescribe('-- a', any);\n\nfunction forthallot() {\n  // allot\n  if (dp + tos > dictionaryfull) {\n    throwerror(-8);\n  } else {\n    dp += tos;\n    tos = s[sp--];\n  }\n}\n\nvar x_allot = primitive('allot', forthallot);\ndescribe('n --', any);\n\nfunction forthhide() {\n  hf[wc] &= !smudgebit;\n} // hide\n\n\nvar x_hide = primitive('hide', forthhide);\ndescribe('--', f83);\n\nfunction forthreveal() {\n  hf[wc] |= smudgebit;\n} // reveal\n\n\nvar x_reveal = primitive('reveal', forthreveal);\ndescribe('--', f83);\n\nfunction comma(x) {\n  if (dp + 1 >= dictionaryfull) {\n    throwerror(-8);\n  } else {\n    m[dp++] = x;\n  }\n}\n\nfunction forthcomma() {\n  comma(tos);\n  tos = s[sp--];\n} // ,\n\n\nvar x_comma = primitive(',', forthcomma);\ndescribe('x --', any);\nvar x_ccomma = primitive('c,', forthcomma); // c,\n\ndescribe('c --', any);\n\nfunction compile() {\n  for (var _i9 = 0; _i9 < arguments.length; jscomma(arguments[_i9++])) {\n    ;\n  }\n}\n\ndefinitions(hidden); // non-standard function, internal use.   find (more standard) builds on this one.\n// return header number = xt\n\nfunction forthsearch1() {\n  // ( packedname -- a2 | 0 )\n  for (var _i10 = wc; _i10; _i10--) {\n    // loop through headers last first\n    w = h[_i10];\n\n    if (w) {\n      // header exists\n      if (m[context] & ds[_i10]) {\n        // header in context dir\n        if (hf[_i10] & smudgebit) {\n          // smudge bit set too ?\n          if (!m[casesensitive]) w = w.toLowerCase();\n\n          if (w == tos) {\n            // header match ?\n            if (m[compliance] & ds[_i10]) {\n              // complies with standard ?\n              tos = _i10; // yes, return xt\n\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  tos = 0; // all tried, no match\n} // this can be done better, but works for now.\n\n\nfunction forthsearch() {\n  // ( a1 n -- a2 | 0 )\n  forthpack();\n  if (!m[casesensitive]) tos = tos.toLowerCase();\n  var packedname = tos;\n  var orgcontext = m[context];\n  forthsearch1(); // search context voc first\n\n  if (!tos) {\n    // go on, search voc stack if not found\n    for (var _i11 = vocstack.length; _i11;) {\n      tos = 0; // assume \"not found\"\n\n      _i11--;\n\n      if (m[context] != vocstack[_i11]) {\n        // don't search voc, if already searched\n        m[context] = vocstack[_i11]; // make next voc context\n\n        tos = packedname;\n        forthsearch1();\n      }\n\n      if (tos) break; // found ? escape\n    }\n  }\n\n  m[context] = orgcontext; // restore original context\n}\n\nvar x_search = primitive('search', forthsearch);\ndefinitions(forth);\n\nfunction forthfind() {\n  // ( a -- a 0 | x1 1 | xt -1 )   (1=immediate)\n  s[++sp] = tos;\n  s[++sp] = tos + 1;\n  tos = m[tos] & 255;\n  forthsearch(); // ( a 0 | a xt )\n\n  if (tos) {\n    s[sp] = tos;\n\n    if (hf[tos] & precedencebit) {\n      tos = 1;\n    } else {\n      tos = -1;\n    }\n  }\n}\n\nvar x_find = primitive('find', forthfind);\ndescribe('a1 -- a2 0 | a2 xt', ans | f83 | jsf);\n\nfunction forthtobody() {\n  // ( a1 -- a2 )\n  if (tos <= primitives) throwerror(-31);\n  tos = x[tos] + 1;\n}\n\nvar x_tobody = primitive('>body', forthtobody);\ndescribe('a1 -- a2', any);\n\nfunction forthbodyfrom() {\n  // ( a1 -- a2 )\n  tos--;\n\n  for (var _i12 = wc; _i12; _i12--) {\n    // loop through headers last first\n    if (h[_i12]) {\n      if (x[_i12] == tos) {\n        // word pointer match ?\n        tos = _i12; // yes, return xt\n\n        return;\n      }\n    }\n  }\n\n  throwerror(-65);\n}\n\nprimitive('body>', forthbodyfrom);\ndescribe('a1 -- a2', jsf);\ndefinitions(hidden);\n\nfunction forthqimm() {\n  tos = -(hf[tos] & precedencebit);\n} // ( xt -- f )\n\n\nvar x_qimm = primitive('?immediate', forthqimm); // ?immediate\n\nfunction forthcompiling() {\n  s[++sp] = tos;\n  tos = m[state];\n} // compiling\n\n\nvar x_compiling = primitive('compiling', forthcompiling);\ndefinitions(forth);\n\nfunction forthimmediate() {\n  hf[wc] |= precedencebit;\n} // immediate\n\n\nprimitive('immediate', forthimmediate);\ndescribe('--', any);\n\nfunction forthbrclose() {\n  m[state] = true;\n} // ]\n\n\nvar x_brclose = primitive(']', forthbrclose);\ndescribe('--', any);\n\nfunction forthbropen() {\n  m[state] = false;\n} // [\n\n\nvar x_bropen = primitive('[', forthbropen, immediate);\ndescribe('--', any);\ndefinitions(hidden);\n\nfunction forthnewheader() {\n  // newheader\n  forthpack();\n  newheader(tos);\n  tos = s[sp--];\n}\n\nvar x_newheader = primitive('newheader', forthnewheader);\ndefinitions(forth);\n\nfunction forthdotname() {\n  // ( xt -- )                              // .name\n  type(h[tos]);\n  tos = s[sp--];\n}\n\nvar x_dotname = primitive('.name', forthdotname);\ndescribe('xt --', jsf);\n\nfunction forthname() {\n  // ( xt -- a n )                          // name\n  sp++;\n  s[++sp] = h[tos];\n  tos = dp;\n  s[sp - 1] = tos;\n  unpack();\n}\n\nprimitive('name', forthname);\ndescribe('x1 -- a u', jsf);\ndefinitions(hidden);\n\nfunction forthcreateheader() {\n  s[++sp] = tos;\n  tos = bl;\n  forthparse();\n  forthnewheader();\n}\n\nvar x_createheader = primitive('createheader', forthcreateheader);\n\nfunction forthuse() {\n  forthcreateheader();\n  forthcomma();\n  t[wc] = nexthilevel;\n}\n\nvar x_use = primitive('use', forthuse);\ndefinitions(forth);\n\nfunction forthcolonnoname() {\n  // :noname\n  s[++sp] = tos;\n  newheader('');\n  tos = wc;\n  comma(x_nest);\n  m[state] = -1;\n  t[wc] = nexthilevel;\n}\n\nprimitive(':noname', forthcolonnoname);\ndescribe('-- a', ans | jsf);\n\nfunction forthunused() {\n  s[++sp] = tos;\n  tos = dictionaryfull - dp;\n}\n\nprimitive('unused', forthunused);\ndescribe('-- u', ans | jsf);\n\nfunction forthheap() {\n  // ( -- a )\n  s[++sp] = tos;\n  tos = heapend;\n}\n\nprimitive('heap', forthheap);\ndescribe('-- a', jsf);\n\nfunction forthbrmarker() {\n  // ( wc dp -- )\n  dp = tos;\n  wc = s[sp--];\n  m[lastxt] = wc;\n  tos = s[sp--];\n}\n\nprimitive('(marker)', forthbrmarker);\ndescribe('wc dp heap --', jsf); // =================================================================================================\n//                                          mass storage\n// =================================================================================================\n// ------------------------------------------- memory drive --------------------------------------------\n\nvar ramblock = [];\nvar screenline;\n\nfunction saveblock() {\n  for (i = screenline.length; i < 16; i++) {\n    screenline.push('');\n  }\n\n  for (i = screenline.length; i > 16; i--) {\n    screenline.pop();\n  }\n\n  ramblock.push(screenline);\n}\n\nscreenline = [];\nscreenline.push('( ramdrive block 0 - essential block words      -load- )');\nscreenline.push(': copy (s u1 u2 -- ) swap block swap buffer c/s move update ;');\nscreenline.push(': clear (s u -- ) buffer c/s blank update ;');\nscreenline.push(': index1 (s u -- )  dup scr ! 2 .r space 0 .line ;');\nscreenline.push(': index (s u1 u2 -- ) 1+ swap ?do cr i index1 loop ;');\nscreenline.push(': ls (s -- ) 0 capacity 1- index ;');\nscreenline.push(': w (s -- ) last @ 1+ 1 do i name dup if ');\nscreenline.push('      2dup info s\"   \" ...info  i stackeffect ...info');\nscreenline.push('   then 2drop loop ;');\nscreenline.push(': --\x3e  (s -- ) blk @ 1+ block c/s !source >in off ; immediate');\nscreenline.push(': uppercase dup char a char z 1+ within 32 and - ;');\nscreenline.push(': p  (s -- )  scr @ 1-  0 max  scr ! ;');\nscreenline.push(': n  (s -- )  scr @ 1+ capacity 1- min scr ! ;');\nscreenline.push(': view (s -- ) begin key dup esc <> while uppercase');\nscreenline.push('  dup char N = if n else dup char P = if p then then');\nscreenline.push('  drop cls l repeat drop ;');\nsaveblock();\nscreenline = [];\nscreenline.push('( ramdrive block 1 - MARKER + info screen words -load- )');\nscreenline.push(': marker here last @ create , ,');\nscreenline.push('         does> skim swap @ (marker) ;');\nscreenline.push('');\nscreenline.push(': cr2  (s -- ) s\" \" info ;');\nscreenline.push('');\nscreenline.push(': .line2 (s u -- ) c/l * screen + c/l -trailing info ;');\nscreenline.push('');\nscreenline.push('( list screen on info window )');\nscreenline.push(': list2 (s u -- ) scr ! l/s 0 do i .line2 loop ;');\nscreenline.push('');\nscreenline.push('( list all screens on info, enable backscroll )');\nscreenline.push(': sources (s -- )  capacity 0 do i list2 loop all ;');\nsaveblock();\nscreenline = [];\nscreenline.push('( ramdrive block 2 - hex dump                   -load- )');\nscreenline.push('hidden definitions  6 constant dumps/line');\nscreenline.push(': safe-emit (s c -- ) dup bl 128 within 0=');\nscreenline.push('      if drop char . then emit ;');\nscreenline.push(': ######## (s u -- ) 0 <# 8 for # next #> type ;');\nscreenline.push(': .cell (s u -- ) 16 base exchange swap ######## space base ! ;');\nscreenline.push(': .addr (s u -- ) .cell ;');\nscreenline.push(': pad_dump1 (s n -- ) 4 swap - 3 * spaces ;');\nscreenline.push(': dump_cells (s a n -- ) for skim .cell next drop ;');\nscreenline.push(': dump_chars (s a n -- ) for count safe-emit next drop ;');\nscreenline.push(': dump1line (s a n -- ) dumps/line min dup if over .addr');\nscreenline.push('     2 spaces 2dup dump_cells dup pad_dump1 2 spaces');\nscreenline.push('   2dup dump_chars then 2drop ;');\nscreenline.push('forth definitions hidden');\nscreenline.push(': dump (s a n -- ) begin ?dup while 2dup cr dump1line');\nscreenline.push('  dumps/line /string repeat drop ; forth');\nsaveblock();\nscreenline = [];\nscreenline.push('( ramdrive block 3 - modified retro editor )');\nscreenline.push(': line (s u -- a )  c/l * screen + ;');\nscreenline.push(': s    (s u -- )    scr ! ;');\nscreenline.push(': ia (s a u -- )    line + >r 0 parse r> swap cmove ;');\nscreenline.push(': r  (s u -- )      0 swap ia ;');\nscreenline.push(': d  (s u -- )      line c/l blank ;');\nscreenline.push(': x (s -- )         clear ;');\nscreenline.push(': v (s -- )         l ;');\nscreenline.push('( extensions: bubble up and down lines )');\nscreenline.push(': >pad (s a n -- )  pad swap move ;');\nscreenline.push(': pad> (s a n -- )  pad -rot move ;');\nscreenline.push(': lines (s u1 u2 -- a1 a2 ) line swap line swap ;');\nscreenline.push(': xchg lines over >r dup c/l >pad c/l move r> c/l pad> ;');\nscreenline.push(': bu (s u1 -- )    ?dup if dup 1- xchg then ;');\nscreenline.push(': bd (s u1 -- )    dup l/s 1- < if dup 1+ bu then drop ;');\nsaveblock();\nscreenline = new Array('( ramdrive block 4 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 5 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 6 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 7 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 8 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 9 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 10 - empty )');\nsaveblock();\nscreenline = new Array('( ramdrive block 11 - empty )');\nsaveblock(); // ---------------------------- ram drive ----------------------------\n\nfunction loadblockfromram(n, a) {\n  // unpack block n to address\n  debug(\"ram drive: block \".concat(n, \" to addr \").concat(a));\n  var temp = a;\n\n  for (i = 0; i < 16; i++) {\n    s[++sp] = lineofspaces.substr(0, 64);\n    tos = temp;\n    unpack();\n    s[++sp] = ramblock[n][i].substr(0, 64);\n    tos = temp;\n    unpack();\n    temp += 64;\n  }\n\n  return a;\n}\n\nfunction savebuftoram(addr, blocknum) {\n  debug(\"ram drive: from \".concat(addr, \" to ramblock \").concat(blocknum));\n\n  for (i = 0; i < 16; i++) {\n    ramblock[blocknum][i] = pack(addr, 64);\n    addr += 64;\n  }\n}\n\nfunction ramdrivecapacity() {\n  return ramblock.length;\n} // ------------------------- cookie drive ------------------------------\n\n\nvar cookiesectorsize = 1024; // decrease size to spread block across multiple cookies\n\nfunction loadblockfromcookie(blknum, destaddr) {\n  // unpack block to address\n  debug(\"cookie drive: block \".concat(blknum, \" to addr \").concat(destaddr));\n\n  for (var _i13 = 0; _i13 < 1024; _i13 += cookiesectorsize) {\n    var cookiename = \"\".concat(cookiebasename + blknum, \"_\").concat(_i13);\n    var temp = readcookie(cookiename, destaddr + _i13);\n\n    if (temp) {\n      unpackstring(temp.substr(0, cookiesectorsize), destaddr + _i13);\n    } else {\n      temp = destaddr + _i13;\n\n      for (var j = 0; j < cookiesectorsize; j++) {\n        m[temp++] = bl;\n      }\n    }\n  }\n\n  return destaddr;\n}\n\nfunction savebuftocookie(addr, blknum) {\n  debug(\"cookie drive: from \".concat(addr, \" to block \").concat(blknum));\n\n  for (var _i14 = 0; _i14 < 1024; _i14 += cookiesectorsize) {\n    setcookie(\"\".concat(cookiebasename + blknum, \"_\").concat(_i14), pack(addr + _i14, cookiesectorsize), null, cookieexpirationdate);\n  }\n}\n\nfunction cookiedrivecapacity() {\n  return maxcookies;\n} // for now\n\n\nfunction localcapacity() {\n  return ramdrivecapacity() + cookiedrivecapacity();\n} // ------------------------------ peer drives ------------------------------\n// -------------------------------------------------------------------------\n\n\nfunction capacity() {\n  return localcapacity();\n}\n\nfunction forthcapacity() {\n  s[++sp] = tos;\n  tos = capacity();\n}\n\nprimitive('capacity', forthcapacity);\ndescribe('-- u', jsf);\n\nfunction forthlocalcapacity() {\n  s[++sp] = tos;\n  tos = localcapacity();\n}\n\nprimitive('localcapacity', forthlocalcapacity);\ndescribe('-- u', jsf); // ------------------------ buffers ------------------------\n// block mapping hardcoded in here\n\nfunction savebuf(buffer) {\n  var starttime = new Date().getTime();\n  var bufaddr = buf[buffer];\n  var blknum = bufblk[buffer];\n\n  if (blknum < maxcookies) {\n    savebuftocookie(bufaddr, blknum);\n  } else {\n    var temp = localcapacity();\n    savebuftoram(bufaddr, blknum - maxcookies);\n  }\n\n  bufdirty[buffer] = 0; // set clean\n\n  var stoptime = new Date().getTime();\n  debug(\"block \".concat(blknum, \" write took \").concat(stoptime - starttime, \"ms\"));\n}\n\nfunction loadblock(blknum, buffer) {\n  var starttime = new Date().getTime();\n\n  if (blknum < maxcookies) {\n    var blockdata = loadblockfromcookie(blknum, buffer);\n  } else {\n    var temp = localcapacity();\n    blockdata = loadblockfromram(blknum - maxcookies, buffer);\n  }\n\n  var stoptime = new Date().getTime();\n  debug(\"block \".concat(blknum, \" read took \").concat(stoptime - starttime, \"ms\"));\n  return blockdata;\n} // --------------------------------------------------------------\n\n\nvar hotbuffer; // for update\n\nfunction forthblockorbuffer(flag) {\n  // ( u -- a )  /  flag=true:block    false:buffer\n  if (tos >= capacity() || tos < 0) throwerror(-35);\n\n  if (blockstat[tos] >= 0) {\n    // block already mapped:\n    hotbuffer = blockstat[tos];\n    tos = buf[hotbuffer]; // return buffer address\n  } else {\n    // block not mapped:\n    nextbuf++; // next available buffer\n\n    nextbuf %= maxbufs;\n\n    if (bufblk[nextbuf] >= 0) {\n      // buffer used for another block\n      if (bufdirty[nextbuf]) savebuf(nextbuf); // dirty ?\n\n      blockstat[bufblk[nextbuf]] = -1; // write block info \"unbuffered\"\n    }\n\n    var temp = tos;\n\n    if (flag) {\n      tos = loadblock(tos, buf[nextbuf]); // block: fill block with data from mass memory.\n    } else {\n      tos = buf[nextbuf]; // buffer: indefinite buffer contents.\n    }\n\n    hotbuffer = nextbuf;\n    bufblk[nextbuf] = temp; // associate buf with block#\n\n    blockstat[temp] = nextbuf; // set block info \"buffered in ...\"\n  }\n}\n\nfunction forthbuffer() {\n  forthblockorbuffer(false);\n} // ( u -- a )\n\n\nvar x_buffer = primitive('buffer', forthbuffer);\ndescribe('u -- a', any);\n\nfunction forthblock() {\n  forthblockorbuffer(true);\n} // ( u -- a )\n\n\nvar x_block = primitive('block', forthblock);\ndescribe('u -- a', any);\n\nfunction forthupdate() {\n  bufdirty[hotbuffer] = -1;\n}\n\nprimitive('update', forthupdate);\ndescribe('--', any);\n\nfunction forthsavebuffers() {\n  for (var _i15 = 0; _i15 < maxbufs; _i15++) {\n    // for all buffers\n    if (bufdirty[_i15]) savebuf(_i15); // save if dirty\n\n    blockstat[bufblk[_i15]] = -1; // write block info \"unbuffered\"\n  }\n}\n\nprimitive('save-buffers', forthsavebuffers);\ndescribe('--', any);\n\nfunction forthemptybuffers() {\n  for (var _i16 = 0; _i16 < maxbufs; _i16++) {\n    if (bufblk[_i16] >= 0) {\n      // buffer has block in ?\n      blockstat[bufblk[_i16]] = -1; // mark block as not buffered anymore\n\n      bufblk[_i16] = -1; // mark buffer as not containing a block\n\n      bufdirty[_i16] = 0; // set clean\n    }\n  }\n}\n\nprimitive('empty-buffers', forthemptybuffers);\ndescribe('--', any);\n\nfunction forthblockstats() {\n  cr();\n  type('checking blocks:');\n  var temp = capacity();\n\n  for (var _i17 = 0; _i17 < temp; _i17++) {\n    if (blockstat[_i17] != -1) {\n      cr();\n      type(\"   blk #\".concat(_i17, \": buf \").concat(blockstat[_i17]));\n    }\n  }\n}\n\nfunction forthbufstats() {\n  cr();\n  type('checking buffers:');\n\n  for (i = 0; i < maxbufs; i++) {\n    cr();\n    type(\"   buf #\".concat(i, \":\"));\n\n    if (bufblk[i] < 0) {\n      type(' empty');\n    } else {\n      type(\" blk \".concat(bufblk[i]));\n    }\n\n    if (bufdirty[i]) type(' dirty');\n  }\n\n  forthblockstats();\n}\n\nprimitive('bufstats', forthbufstats);\ndescribe('--', jsf); // =================================================================================================\n//                                          vocabularies\n// =================================================================================================\n// i'll try to use the standards selector to implement conventional vocabularies\n\ndefinitions(forth);\n\nfunction dovocabulary() {\n  w = x[w];\n  m[context] = m[w];\n  standard = standard & (higheststandard << 1) - 1 | m[context];\n}\n\nfunction forthvocabulary() {\n  if (nextvocabulary >= 0x20000000) {\n    throwerror(-69);\n  } else {\n    forthcreateheader();\n    vocname.push(wc);\n    t[wc] = dovocabulary;\n    nextvocabulary <<= 1;\n    m[dp++] = nextvocabulary;\n    forthreveal();\n  }\n}\n\nprimitive('vocabulary', forthvocabulary);\ndescribe('<new vocabulary name> --', any);\n\nfunction forthonly() {\n  for (var _i18 = vocstack.length; _i18; _i18--) {\n    vocstack.pop();\n  }\n\n  m[context] = only;\n  vocstack.push(only);\n}\n\nprimitive('only', forthonly);\ndescribe('--', any);\nvocname.push(wc);\n\nfunction forthforth() {\n  m[context] = forth;\n}\n\nprimitive('forth', forthforth);\ndescribe('--', any | only);\nvocname.push(wc);\n\nfunction forthhidden() {\n  m[context] = hidden;\n}\n\nprimitive('hidden', forthhidden);\ndescribe('--', jsf | f83 | ans);\nvocname.push(wc);\n\nfunction forthteststuff() {\n  m[context] = teststuff;\n}\n\nprimitive('teststuff', forthteststuff);\ndescribe('--', jsf);\nvocname.push(wc);\n\nfunction forthdefinitions() {\n  m[current] = m[context];\n}\n\nprimitive('definitions', forthdefinitions);\ndescribe('--', any);\n\nfunction forthorder() {\n  printvocname(m[context]);\n\n  for (var _i19 = vocstack.length; _i19; _i19--) {\n    printvocname(vocstack[_i19 - 1]);\n  }\n\n  type('      ');\n  printvocname(m[current]);\n}\n\nprimitive('order', forthorder);\ndescribe('--', ans | jsf | only);\n\nfunction forthalso() {\n  vocstack.push(m[context]);\n}\n\nprimitive('also', forthalso);\ndescribe('--', ans | jsf);\n\nfunction forthprevious() {\n  m[context] = vocstack.pop();\n}\n\nprimitive('previous', forthprevious);\ndescribe('--', ans | jsf);\n\nfunction forthvocs() {\n  for (i = vocname.length; i; type(\"\".concat(h[vocname[--i]], \" \"))) {\n    ;\n  }\n}\n\nprimitive('vocs', forthvocs);\ndescribe('--', fig | f79 | f83 | jsf); // =================================================================================================\n//                                        floating point\n// =================================================================================================\n\ndefinitions(teststuff); // fconstants, testing\n\nfunction forth1point5() {\n  f.push(ftos);\n  ftos = 1.5;\n}\n\nprimitive('1.5', forth1point5);\n\nfunction forthmin1point5() {\n  f.push(ftos);\n  ftos = -1.5;\n}\n\nprimitive('-1.5', forthmin1point5);\n\nfunction forth2point8() {\n  f.push(ftos);\n  ftos = 2.8;\n}\n\nprimitive('2.8', forth2point8);\n\nfunction forthmin2point8() {\n  f.push(ftos);\n  ftos = -2.8;\n}\n\nprimitive('-2.8', forthmin2point8);\ndefinitions(forth);\n\nfunction forthfdots() {\n  // f.s\n  f.push(ftos);\n\n  for (var _i20 = 1; _i20 < f.length; type(\"\".concat(f[_i20++], \" \"))) {\n    ;\n  }\n\n  ftos = f.pop();\n}\n\nprimitive('f.s', forthfdots);\ndescribe('--', any);\n\nfunction forthfdrop() {\n  ftos = f.pop();\n} // fdrop\n\n\nprimitive('fdrop', forthfdrop);\ndescribe('r --', any);\n\nfunction forthfdup() {\n  f.push(ftos);\n} // fdup\n\n\nprimitive('fdup', forthfdup);\ndescribe('r -- r r', any);\n\nfunction forthfswap() {\n  // fswap\n  w = f.pop();\n  f.push(ftos);\n  ftos = w;\n}\n\nprimitive('fswap', forthfswap);\ndescribe('r1 r2 -- r2 r1', any);\n\nfunction forthfover() {\n  // fover\n  f.push(ftos);\n  ftos = f[f.length - 2];\n}\n\nprimitive('fover', forthfover);\ndescribe('r1 r2 -- r1 r2 r1', any);\n\nfunction forthffetch() {\n  // f@\n  f.push(ftos);\n  ftos = m[tos];\n  tos = s[sp--];\n}\n\nprimitive('f@', forthffetch);\ndescribe('a -- r', any);\n\nfunction forthfstore() {\n  // f!\n  m[tos] = ftos;\n  ftos = f.pop();\n  tos = s[sp--];\n}\n\nprimitive('f!', forthfstore);\ndescribe('r a --', any);\n\nfunction forthfequ() {\n  // f=\n  s[++sp] = tos;\n  tos = -(ftos == f.pop());\n}\n\nprimitive('f=', forthfequ);\ndescribe('r1 r2 -- f', any);\n\nfunction forthfnequ() {\n  // f<>\n  s[++sp] = tos;\n  tos = -(ftos != f.pop());\n}\n\nprimitive('f<>', forthfnequ);\ndescribe('r1 r2 -- f', any);\n\nfunction forthfmore() {\n  // f>\n  s[++sp] = tos;\n  tos = -(f.pop() > ftos);\n}\n\nprimitive('f>', forthfmore);\ndescribe('r1 r2 -- f', any);\n\nfunction forthfless() {\n  // f<\n  s[++sp] = tos;\n  tos = -(f.pop() < ftos);\n}\n\nprimitive('f<', forthfless);\ndescribe('r1 r2 -- f', any);\n\nfunction forthf0equ() {\n  // f0=\n  s[++sp] = tos;\n  tos = -(ftos == 0);\n  ftos = f.pop();\n}\n\nprimitive('f0=', forthf0equ);\ndescribe('r -- f', any);\n\nfunction forthf0nequ() {\n  // f0<>\n  s[++sp] = tos;\n  tos = -(ftos != 0);\n  ftos = f.pop();\n}\n\nprimitive('f0<>', forthf0nequ);\ndescribe('r -- f', any);\n\nfunction forthf0less() {\n  // f0<\n  s[++sp] = tos;\n  tos = -(ftos < 0);\n  ftos = f.pop();\n}\n\nprimitive('f0<', forthf0less);\ndescribe('r -- f', any);\n\nfunction forthf0greater() {\n  // f0>\n  s[++sp] = tos;\n  tos = -(ftos > 0);\n  ftos = f.pop();\n}\n\nprimitive('f0>', forthf0greater);\ndescribe('r -- f', any);\n\nfunction forthfnegate() {\n  // fnegate\n  ftos = -ftos;\n}\n\nprimitive('fnegate', forthfnegate);\ndescribe('r1 -- r2', any);\n\nfunction forthfabs() {\n  // fabs\n  ftos = Math.abs(ftos);\n}\n\nprimitive('fabs', forthfabs);\ndescribe('r1 -- r2', any);\n\nfunction forthfround() {\n  // fround\n  ftos = Math.round(ftos);\n}\n\nprimitive('fround', forthfround);\ndescribe('r1 -- r2', any);\n\nfunction forthfdepth() {\n  // fdepth\n  s[sp++] = tos;\n  tos = f.length;\n}\n\nprimitive('fdepth', forthfdepth);\ndescribe(' -- u', any);\n\nfunction forthdtof() {\n  // d>f\n  f.push(ftos);\n  ftos = tos * 0x100000000 + s[sp--];\n  tos = s[sp--];\n}\n\nprimitive('d>f', forthdtof);\ndescribe('d --', jsf | ans);\n\nfunction forthftod() {\n  // f>d\n  s[++sp] = tos;\n  tos = ftos;\n  ftos = f.pop();\n  s[++sp] = tos & 0xffffffff;\n  tos /= 0x100000000;\n  if (tos < 0) tos += floorfix;\n  tos = Math.floor(tos);\n}\n\nprimitive('f>d', forthftod);\ndescribe('r -- d', jsf | ans);\n\nfunction forthstof() {\n  // s>f\n  f.push(ftos);\n  ftos = tos;\n  tos = s[sp--];\n}\n\nprimitive('s>f', forthstof);\ndescribe('x --', jsf);\n\nfunction forthfplus() {\n  // f+\n  ftos += f.pop();\n}\n\nprimitive('f+', forthfplus);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfminus() {\n  // f-\n  ftos = f.pop() - ftos;\n}\n\nprimitive('f-', forthfminus);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfmul() {\n  // f*\n  ftos *= f.pop();\n}\n\nprimitive('f*', forthfmul);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfdiv() {\n  // f/\n  var temp = f.pop();\n  ftos = temp / ftos;\n}\n\nprimitive('f/', forthfdiv);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfsin() {\n  // fsin\n  ftos = Math.sin(ftos);\n}\n\nprimitive('fsin', forthfsin);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfcos() {\n  // fcos\n  ftos = Math.cos(ftos);\n}\n\nprimitive('fcos', forthfcos);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthftan() {\n  // ftan\n  ftos = Math.tan(ftos);\n}\n\nprimitive('ftan', forthftan);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfasin() {\n  // fasin\n  ftos = Math.asin(ftos);\n}\n\nprimitive('fasin', forthfasin);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfatan() {\n  // fatan\n  ftos = Math.atan(ftos);\n}\n\nprimitive('fatan', forthfatan);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfatan2() {\n  // fatan2\n  ftos = Math.atan2(f.pop(), ftos);\n}\n\nprimitive('fatan2', forthfatan2);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfacos() {\n  // facos\n  ftos = Math.acos(ftos);\n}\n\nprimitive('facos', forthfacos);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfpower() {\n  // f**\n  ftos = Math.pow(f.pop(), ftos);\n}\n\nprimitive('f**', forthfpower);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfln() {\n  // fln\n  ftos = Math.log(ftos);\n}\n\nprimitive('fln', forthfln);\ndescribe('r1 -- r2', jsf | ans); // function forthflog()  {                                                // flog\n//   ftos = Math.log(10,ftos) ;\n// }\n// primitive(\"flog\",forthflog) ;\n// describe(\"r1 -- r2\",jsf|ans) ;\n// (Math.log) : e based\n\nfunction forthfalog() {\n  // falog\n  ftos = Math.pow(10, ftos);\n}\n\nprimitive('falog', forthfalog);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfsqrt() {\n  // fsqrt\n  ftos = Math.sqrt(ftos);\n}\n\nprimitive('fsqrt', forthfsqrt);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfmin() {\n  // fmin\n  ftos = Math.min(ftos, f.pop());\n}\n\nprimitive('fmin', forthfmin);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfmax() {\n  // fmax\n  ftos = Math.max(ftos, f.pop());\n}\n\nprimitive('fmax', forthfmax);\ndescribe('r1 r2 -- r3', jsf | ans);\n\nfunction forthfdot() {\n  // f.\n  type(\"\".concat(ftos, \" \"));\n  ftos = f.pop();\n}\n\nprimitive('f.', forthfdot);\ndescribe('r --', jsf | ans);\n\nfunction forthpi() {\n  // pi\n  f.push(ftos);\n  ftos = Math.PI;\n}\n\nprimitive('pi', forthpi);\ndescribe('-- r', jsf | ans);\n\nfunction forthreciproc() {\n  // 1/F\n  ftos = 1 / ftos;\n}\n\nprimitive('1/f', forthreciproc);\ndescribe('r1 -- r2', jsf | ans);\n\nfunction forthfcomma() {\n  m[dp++] = ftos;\n  ftos = f.pop();\n} // f,\n\n\nvar x_fcomma = primitive('f,', forthfcomma);\ndescribe('r --', any);\nprimitive('falign', noop, immediate); // falign\n\ndescribe('--', ans);\nprimitive('faligned', noop, immediate); // faligned\n\ndescribe('--', ans); // =================================================================================================\n//                                             heap\n// =================================================================================================\n\nvar nusedchunks = 0;\nvar nfreechunks = 0; // return data address of chunk\n\nfunction newchunk(size) {\n  m[heapend++] = nusedchunks;\n  m[heapend++] = size;\n  usedchunk[nusedchunks++] = heapend;\n  var temp = heapend;\n  heapend += tos;\n  return temp;\n} // return data address of chunk\n\n\nfunction splitchunk(fit, newsize) {\n  var chunkaddr = freechunk[fit];\n  var chunksizeleft = m[chunkaddr - 1] - (newsize + 2);\n\n  if (chunksizeleft > 0) {\n    // split chunk into two:\n    m[chunkaddr - 1] = chunksizeleft++; // new size old chunk\n\n    chunkaddr += chunksizeleft; // new addr new chunk\n\n    m[chunkaddr++] = newsize; // new size new chunk\n  } else {\n    // use chunk completely:\n    freechunk[fit] = freechunk[--nfreechunks]; // last chunk takes place of used chunk\n\n    freechunk.pop(); // shorten array of freed chunks\n  }\n\n  m[chunkaddr - 2] = nusedchunks; // index into usedchunks array to this chunk\n\n  usedchunk[nusedchunks++] = chunkaddr; // move new chunk to usedchunks\n\n  return chunkaddr;\n}\n\nfunction searchfit(size) {\n  var fit = -1;\n\n  if (nfreechunks) {\n    var temp = 0xffffffff; // any chunk is better\n\n    for (var _i21 = 0; _i21 < nfreechunks; _i21++) {\n      var slack = m[freechunk[_i21] - 1] - size;\n      if (slack == 0) return _i21;\n\n      if (slack > 2) {\n        if (!fittype) return _i21;\n\n        if (slack < temp) {\n          fit = _i21;\n          temp = slack;\n        }\n      }\n    }\n  }\n\n  return fit;\n}\n\nfunction forthallocate() {\n  // ( u -- a 0 | err )\n  var fit = searchfit(tos);\n\n  if (fit < 0) {\n    s[++sp] = newchunk(tos);\n  } else {\n    s[++sp] = splitchunk(fit, tos);\n  }\n\n  tos = 0;\n}\n\nprimitive('allocate', forthallocate);\ndescribe('u -- a 0 | err', ans | jsf);\n\nfunction forthfree() {\n  // ( a -- 0 | err )\n  var temp = Math.min(m[tos - 2], nusedchunks - 1);\n  var chunkaddr = usedchunk[temp];\n\n  if (chunkaddr != tos) {\n    throwerror(-72);\n  } else {\n    freechunk[nfreechunks++] = chunkaddr;\n    nusedchunks--;\n    var lastchunk = usedchunk.pop();\n\n    if (temp < nusedchunks) {\n      m[lastchunk - 2] = temp;\n      usedchunk[temp] = lastchunk;\n    }\n  }\n\n  freechunk.sort();\n  chunkaddr = freechunk[0] + m[freechunk[0] - 1] + 2; // combining from end of memory towards lower addresses may be quicker .\n\n  for (temp = 1; temp < nfreechunks; temp++) {\n    if (freechunk[temp] == chunkaddr) {\n      // merge chunks\n      chunksize = m[freechunk[temp] - 1] + 2;\n      m[freechunk[temp - 1] - 1] += chunksize;\n      chunkaddr += chunksize;\n      nfreechunks--;\n\n      for (var _i22 = temp; _i22 < nfreechunks; freechunk[_i22++] = freechunk[_i22]) {\n        ;\n      }\n\n      freechunk.pop();\n      temp--;\n    } else {\n      chunkaddr = freechunk[temp] + m[freechunk[temp] - 1] + 2;\n    }\n  }\n\n  temp = freechunk[nfreechunks - 1];\n\n  if (temp + m[temp - 1] == heapend) {\n    nfreechunks--;\n    heapend = freechunk.pop() - 2;\n  }\n\n  tos = 0;\n}\n\nprimitive('free', forthfree);\ndescribe('a -- 0 | err', ans | jsf); // RESIZE\n//    freed areas appendable ?\n//    yes: append\n//    no: allocate new, copy\n\nfunction forthdotallocated() {\n  type('allocated:');\n\n  for (var i = 0; i < nusedchunks; i++) {\n    cr();\n    type(\"\".concat(i, \"/\").concat(m[usedchunk[i] - 2], \": \").concat(usedchunk[i], \" \").concat(m[usedchunk[i] - 1]));\n  }\n\n  cr();\n  type('freed:');\n\n  for (i = 0; i < nfreechunks; i++) {\n    cr();\n    type(\"\".concat(i, \": \").concat(freechunk[i], \" \").concat(m[freechunk[i] - 1]));\n  }\n}\n\nprimitive('.allocated', forthdotallocated);\ndescribe('--', jsf); // =================================================================================================\n//                                     peephole optimizer\n// =================================================================================================\n// function forthpeephole()  {                   \\\\ ( xt1 -- xt2 )\n// }\n// var x_peephole = primitive(\"peephole\",forthpeephole) ;\n// describe(\"xt1 -- xt2\",jsf) ;\n// =================================================================================================\n//                                             utility\n// =================================================================================================\n\ndefinitions(forth);\n\nfunction forthbye() {\n  forthsavebuffers();\n  window.close();\n}\n\nprimitive('bye', forthbye);\ndescribe('--', any | foerthchen);\n\nfunction forthdecimal() {\n  m[base] = 10;\n}\n\nvar x_decimal = primitive('decimal', forthdecimal);\ndescribe('--', any);\n\nfunction forthhex() {\n  m[base] = 16;\n}\n\nvar x_hex = primitive('hex', forthhex);\ndescribe('--', any); // ( a n -- )   execute as javascript\n\nfunction fortheval() {\n  forthpack();\n  eval(tos);\n  tos = s[sp--];\n}\n\nvar x_eval = primitive('eval', fortheval);\ndescribe('a n --', jsf); // ----------- javascript popup dialogs ------------\n// pops up an alert\n\nfunction forthalert() {\n  // ( a n -- )\n  forthpack();\n  alert(tos);\n  tos = s[sp--];\n}\n\nprimitive('alert', forthalert);\ndescribe('a n --', jsf); // pops up a confirm window\n\nfunction forthconfirm() {\n  // ( a n -- f )\n  forthpack();\n  tos = -confirm(tos);\n}\n\nprimitive('confirm', forthconfirm);\ndescribe('a n -- d', jsf);\n\nfunction forthenter() {\n  // ( a1 n1 a2 -- n2 )\n  tos = unpackstring(prompt(pack(s[sp - 1], s[sp])), tos);\n  sp -= 2;\n}\n\nprimitive('enter', forthenter);\ndescribe('a1 n1 a2 -- n2', jsf); // --------------- time ----------------\n\nfunction forthms() {\n  suspended = w;\n  setTimeout(function () {\n    virtualmachine(ip);\n  }, tos);\n  tos = s[sp--];\n}\n\nvar x_ms = primitive('ms', forthms);\ndescribe('u --', jsf);\n\nfunction forthepoch() {\n  // ( -- u )\n  s[++sp] = tos;\n  w = new Date().getTime();\n  tos = Math.floor(w / 1000);\n}\n\nprimitive('epoch', forthepoch);\ndescribe('-- u', jsf); // ------------- random ---------------\n\nfunction forthrandom() {\n  tos = Math.floor(Math.random() * tos);\n}\n\nprimitive('random', forthrandom);\ndescribe('u1 -- u2', jsf); // --------- helpers for see -----------\n\ndefinitions(hidden); // where is source ?  -1:console   -2: script   0..: blk*1024+charpos\n\nfunction forthlocate() {\n  tos = src[tos];\n} // ( xt -- n )\n\n\nprimitive('locate', forthlocate);\ndescribe('xt -- n', jsf); // fails with does> words\n\nfunction forthwordtype() {\n  // ( xt1 -- xt2 )\n  if (tos <= primitives) {\n    tos = 0; // primitive\n  } else {\n    tos = m[x[tos]]; // other\n  }\n}\n\nprimitive('wordtype', forthwordtype);\ndescribe('xt1 -- xt2', jsf); // returns source of a primitive\n\nfunction forthdisassemble() {\n  // ( xt a -- n )\n  var temp = \"\".concat(x[s[sp--]], \" \");\n  tos = unpackstring(temp, tos);\n}\n\nprimitive('disassemble', forthdisassemble);\ndescribe('xt a -- n', jsf);\ndefinitions(forth); // ----- info screen tools -----\n\nfunction infosall() {\n  /* No-op. */\n}\n\nprimitive('all', infosall);\ndescribe('--', jsf);\n\nfunction infostail() {\n  /* No-op. */\n}\n\nprimitive('tail', infostail);\ndescribe('--', jsf);\n\nfunction setinfoslines() {\n  infolines = tos;\n  info(\"* buffer size set to \".concat(tos, \" lines.\"));\n  tos = s[sp--];\n}\n\nprimitive('infolines', setinfoslines);\ndescribe('u --', jsf); // --------------------------------------\n\nfunction forthloadhelp() {\n  //  ( a n -- )\n  var temp = \"\".concat('docs/jsforth.html' + '#').concat(pack(s[sp], tos));\n  window.frames.help.window.location.replace(temp.toUpperCase());\n  sp--;\n  tos = s[sp--];\n}\n\nvar x_loadhelp = primitive('loadhelp', forthloadhelp); // =================================================================================================\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n//                               no more primitives below this point\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n\nvar primitives = wc; // =================================================================================================\n//                               builders for non-primitive words\n// =================================================================================================\n// could speed this up with proper linkage code in t[wc]\n\nfunction constant(name, value) {\n  newheader(name, smudgebit);\n  comma(x_doconst);\n  comma(value);\n  t[wc] = nextconstant;\n  return wc;\n}\n\nfunction variable(name) {\n  newheader(name, smudgebit);\n  comma(x_dovar);\n  comma(0);\n  t[wc] = nextvariable;\n  return wc;\n}\n\nfunction colon(name, flags) {\n  newheader(name, flags | smudgebit);\n  comma(x_nest);\n  t[wc] = nexthilevel;\n  return wc;\n}\n\nfunction alias(name, flags) {\n  newheader(name, flags | smudgebit);\n  x[wc] = x[wc - 1];\n  t[wc] = t[wc - 1];\n  return wc;\n}\n\nfunction semicolon() {\n  jscomma(x_unnest);\n} // =================================================================================================\n//                               control flow for using in this script\n// =================================================================================================\n\n\nfunction IF() {\n  m[dp++] = x_0branch;\n  s[++sp] = tos;\n  tos = dp;\n  dp++;\n}\n\nfunction ELSE() {\n  m[dp++] = x_branch;\n  s[++sp] = dp;\n  dp++;\n  m[tos] = dp - tos;\n  tos = s[sp--];\n}\n\nfunction THEN() {\n  m[tos] = dp - tos;\n  tos = s[sp--];\n}\n\nfunction BEGIN() {\n  s[++sp] = tos;\n  tos = dp;\n}\n\nfunction UNTIL() {\n  m[dp++] = x_0branch;\n  m[dp] = tos - dp++;\n  tos = s[sp--];\n}\n\nfunction WHILE() {\n  IF();\n}\n\nfunction REPEAT() {\n  m[dp++] = x_branch;\n  m[dp] = s[sp--] - dp++;\n  m[tos] = dp - tos;\n  tos = s[sp--];\n}\n\nfunction AGAIN() {\n  m[dp++] = x_branch;\n  m[dp] = tos - dp++;\n  tos = s[sp--];\n}\n\nfunction makeDO(xt) {\n  m[dp++] = xt;\n  s[++sp] = m[innerloop];\n  m[innerloop] = dp;\n  s[++sp] = dp;\n  dp++;\n}\n\nfunction DO() {\n  makeDO(x_brdo);\n}\n\nfunction QDO() {\n  makeDO(x_brqdo);\n}\n\nfunction LOOP() {\n  m[dp++] = x_brloop;\n  m[dp++] = s[sp] + 2 - dp;\n  m[s[sp]] = dp - s[sp--];\n  m[innerloop] = s[sp--];\n}\n\nfunction LEAVE() {\n  m[dp++] = x_brleave;\n  m[dp++] = m[innerloop];\n}\n\nfunction QLEAVE() {\n  m[dp++] = x_brqleave;\n  m[dp++] = m[innerloop];\n} // =================================================================================================\n//                           forth-visible constants and variables\n// =================================================================================================\n\n\ndefinitions(hidden);\nvar x_innerloop = constant('innerloop', innerloop);\nvar x_innercase = constant('innercase', innercase);\ndefinitions(forth);\nvar x_minus1 = constant('-1', -1);\ndescribe('-- -1', jsf | foerthchen);\nvar x_0 = constant('0', 0);\ndescribe('-- 0', any);\nvar x_1 = constant('1', 1);\ndescribe('-- 1', any);\nconstant('cell', 1);\ndescribe('-- u', ans | jsf);\nvar x_2 = constant('2', 2);\ndescribe('-- 2', any);\nvar x_bl = constant('bl', bl);\ndescribe('-- c', any);\nvar x_esc = constant('esc', esc);\ndescribe('-- c', jsf);\nconstant('compliance', compliance);\ndescribe('-- a', jsf);\nconstant('true', -1);\ndescribe('-- -1', any);\nconstant('false', 0);\ndescribe('-- 0', any);\nconstant('casesensitive', casesensitive);\ndescribe('-- a', jsf);\nconstant('warnings', warnings);\ndescribe('-- a', jsf);\nconstant('debugger', debugging);\ndescribe('-- a', jsf);\nvar x_xontext = constant('context', context);\ndescribe('-- a', jsf);\nvar x_current = constant('current', current);\ndescribe('-- a', jsf);\nvar x_blk = constant('blk', blk);\ndescribe('-- a', any);\nvar x_scr = constant('scr', scr);\ndescribe('-- a', any);\nvar x_lastxt = constant('last', lastxt);\ndescribe('-- a', jsf);\nvar x_base = constant('base', base);\ndescribe('-- a', any);\nvar x_tib = constant('tib', tib);\ndescribe('-- a', any);\nvar x_span = constant('span', span);\ndescribe('-- a', fig | f79 | f83 | ans);\nvar x_hashtib = constant('#tib', hashtib);\ndescribe('-- a', 'obsolete, variable containing #chars in tib', fig | f79 | f83 | ans);\nvar x_in = constant('>in', toin);\ndescribe('-- a', any);\nvar x_state = constant('state', state);\ndescribe('-- a', any);\nconstant('outfile', outfile);\ndescribe('-- a', jsf);\nconstant('fit', fittype);\ndescribe('-- a', jsf);\nconstant('c/l', 64);\ndescribe('-- u', jsf);\nconstant('l/s', 16);\ndescribe('-- u', jsf);\nconstant('c/s', 1024);\ndescribe('-- u', jsf);\nvar x_literal = colon('literal', immediate);\ncompile(x_lit, x_lit, x_comma, x_comma);\nsemicolon();\ndescribe('x --', any); // =================================================================================================\n//                                             errors\n// =================================================================================================\n\ndefinitions(hidden);\nvar x_stackunderflow = colon('underflow');\ncompile(x_lit, -4, x_throw);\nvar x_notfound = colon('notfound');\ncompile(x_lit, -13, x_throw);\ndefinitions(hidden);\ndefinitions(forth);\nvar x_abort = colon('abort');\ncompile(x_lit, -1, x_throw);\ndescribe('--', any); // =================================================================================================\n//                                          compilation\n// =================================================================================================\n\nvar x_qcomp = colon('?comp');\ncompile(x_compiling, x_0equ);\nIF();\ncompile(x_lit, -14, x_throw);\nTHEN();\nsemicolon();\ndescribe('--', jsf);\nvar x_qexec = colon('?exec');\ncompile(x_compiling);\nIF();\ncompile(x_lit, -64, x_throw);\nTHEN();\nsemicolon();\ndescribe('--', jsf);\nvar x_compilecomma = colon('compile,', immediate);\ncompile(x_qcomp, x_comma);\nsemicolon();\ndescribe('xt --', any); // =================================================================================================\n//                                             strings\n// =================================================================================================\n\ndefinitions(hidden);\nvar x_commastr = colon(',$');\ncompile(x_here, x_over, x_1plus, x_allot, x_movestr);\nsemicolon();\ndescribe('a n --', jsf);\ndefinitions(forth); // # ( <stream> -- ) compile a string from input stream\n\nvar x_commaquote = colon(',\"');\ncompile(x_lit, 34, x_parse, x_commastr);\nsemicolon();\ndescribe('--', jsf); // # ( <stream> -- ) compile a string from input stream\n\nvar x_commatick = colon(\",'\");\ncompile(x_lit, 39, x_parse, x_commastr);\nsemicolon();\ndescribe('--', jsf);\n\nfunction forthscan() {\n  // ( a1 n2 c -- a2 n2 )\n  var temp = s[sp--];\n\n  for (; temp; temp--) {\n    if (m[s[sp]] == tos) break;\n    s[sp]++;\n  }\n\n  tos = temp;\n}\n\nprimitive('scan', forthscan);\ndescribe('a1 n2 c -- a2 n2', any);\n\nfunction forthskip() {\n  // ( a1 n2 c -- a2 n2 )\n  var temp = s[sp--];\n\n  for (; temp; temp--) {\n    if (m[s[sp]] != tos) break;\n    s[sp]++;\n  }\n\n  tos = temp;\n}\n\nprimitive('skip', forthskip);\ndescribe('a1 n2 c -- a2 n2', any);\ndefinitions(hidden);\nvar x_compilestringword = colon('string\\\",');\ncompile(x_qcomp, x_comma, x_commaquote);\nsemicolon();\nvar x_compiletickstringword = colon(\"string',\");\ncompile(x_qcomp, x_comma, x_commatick);\nsemicolon();\ndefinitions(forth);\nvar x_squote = colon('s\"', immediate);\ncompile(x_lit, x_brsquote, x_compilestringword);\nsemicolon();\ndescribe('--', any);\nvar x_cquote = colon('c\"', immediate);\ncompile(x_lit, x_brcquote, x_compilestringword);\nsemicolon();\ndescribe('--', ans | jsf);\nvar x_dotquote = colon('.\"', immediate);\ncompile(x_lit, x_brdotquote, x_compilestringword);\nsemicolon();\ndescribe('--', any | foerthchen);\ncolon(\"s'\", immediate);\ncompile(x_lit, x_brsquote, x_compiletickstringword);\nsemicolon();\ndescribe('--', any);\ncolon(\".'\", immediate);\ncompile(x_lit, x_brdotquote, x_compiletickstringword);\nsemicolon();\ndescribe('--', any | foerthchen);\nvar x_dumul = colon('du*'); // ( ud1 u -- ud2 )\n\ncompile(x_tuck, x_2tor, x_ummul, x_0, x_2rfrom, x_mul, x_dplus);\nsemicolon();\ncolon('>number');\ncompile(x_2dup, x_plus, x_tor);\ncompile(x_0);\nQDO();\ncompile(x_count, x_digit, x_dup, x_0less);\nIF();\ncompile(x_drop, x_1minus);\nLEAVE();\nTHEN();\ncompile(x_swap, x_tor, x_tor);\ncompile(x_base, x_fetch, x_dumul);\ncompile(x_rfrom, x_0, x_dplus);\ncompile(x_rfrom);\nLOOP();\ncompile(x_rfrom, x_over, x_minus);\nsemicolon();\ndescribe('ud1 a1 u1 -- ud2 a2 u2', ans | jsf); // function forthtonumber()  {              // ( ud1 a1 u1 -- ud2 a2 u2 )\n//   var digit ;\n//   var radix = m[base] ;\n//   w = s[sp] ;\n//   for ( ; tos ; tos-- )   {\n//      digit = m[w] - 48 ;\n//      if ( digit > 16 )  digit -= 7 ;\n//      if ( digit > 36 )  digit -= 32 ;\n//      if ( (digit >= 0) && (digit < radix) )  {\n//         s[sp-2] *= radix ;\n//         s[sp-2] += digit ;\n//         w++ ;\n//      } else  {\n//         s[sp] = w ;\n//         break ;\n//      }\n//   }\n// }\n// primitive(\">number\",forthtonumber) ;\n// describe(\"d1 a1 n1 -- d2 a2 n2\",ans|jsf) ;\n\nvar x_abortquote = colon('abort\"', immediate);\ncompile(x_lit, x_brabortquote, x_compilestringword);\nsemicolon();\ndescribe('--', any); // =================================================================================================\n//                                         defining words\n// =================================================================================================\n// ( a <stream> -- )\n\nvar x_create = colon('create');\ncompile(x_lit, x_dovar, x_use, x_reveal);\nsemicolon();\ndescribe('--', any);\nvar x_const = colon('constant');\ncompile(x_lit, x_doconst, x_use, x_comma, x_reveal); // which is left in here for the moment. doesn't hurt.\n\nsemicolon();\ndescribe('x --', any);\ncolon('fconstant');\ncompile(x_lit, x_dofconst, x_use, x_fcomma, x_reveal);\nsemicolon();\ndescribe('r -- ) ( -- r )', ans | jsf);\ncolon('value');\ncompile(x_lit, x_dovalue, x_use, x_comma, x_reveal);\nsemicolon();\ndescribe('x --', ans | jsf);\ncolon('variable');\ncompile(x_create, x_0, x_comma);\nsemicolon();\ndescribe('--', any);\nalias('fvariable');\ndescribe('-- ) ( -- a', any);\ncolon(';', immediate);\ncompile(x_lit, x_unnest, x_comma, x_bropen, x_reveal);\nsemicolon();\ndescribe('--', any | foerthchen);\ncolon(':');\ncompile(x_lit, x_nest, x_use, x_brclose);\nsemicolon();\ndescribe('<wordname> --', any | foerthchen);\ncolon('does>', immediate);\ncompile(x_lit, x_setdoes, x_compilecomma);\ncompile(x_lit, x_unnest, x_compilecomma);\nsemicolon();\ndescribe('--', any); // =================================================================================================\n//                                                i/o\n// =================================================================================================\n\nvar x_keyq = colon('key?');\ncompile(x_key1query, x_key2query);\nsemicolon();\ndescribe('-- f', jsf);\ncolon('?terminal');\ncompile(x_keyq);\nsemicolon();\ndescribe('-- f', fig | f79);\nvar x_key = colon('key');\ncompile(x_key1, x_key2);\nsemicolon();\ndescribe('-- c', any);\nvar x_word = colon('word');\ncompile(x_parse, x_here, x_movestr, x_here);\nsemicolon();\ndescribe('c -- a', any | foerthchen);\nvar x_accept = colon('accept'); // ( a n1 -- n2 )\n\ncompile(x_over, x_swap, x_1plus);\nBEGIN();\ncompile(x_qdup);\nWHILE();\ncompile(x_key, x_decode);\nREPEAT();\ncompile(x_swap, x_minus);\nsemicolon();\ndescribe('a n1 -- n2', ans | jsf);\ncolon('expect');\ncompile(x_accept, x_span, x_store);\nsemicolon();\ndescribe('a n --', fig | f79 | f83 | ans);\nvar x_query = colon('query');\ncompile(x_tib, x_dup, x_lit, tibsize, x_accept);\ncompile(x_dup, x_hashtib, x_store, x_storesource);\ncompile(x_in, x_off);\nsemicolon();\ndescribe('--', any);\nvar x_sbr = colon('s(');\ncompile(x_lit, 41, x_parse);\nsemicolon();\ndescribe('-- a n', jsf);\ncolon('.(', immediate);\ncompile(x_sbr, x_type);\nsemicolon();\ndescribe('<stream> --', ans | jsf);\nvar x_char = colon('char', immediate); // char\n\ncompile(x_bl, x_parse, x_drop, x_cfetch);\ncompile(x_compiling);\nIF();\ncompile(x_literal);\nTHEN();\nsemicolon();\ndescribe('<stream> -- c', ans | jsf);\nalias('[char]', immediate); // [char]\n\ndescribe('<stream> -- c', ans | jsf);\ncolon('\\\\', immediate);\ncompile(x_0, x_parse, x_2drop);\nsemicolon();\ndescribe('<stream> --', any);\ncolon('(', immediate);\ncompile(x_lit, 41, x_parse, x_2drop);\nsemicolon();\ndescribe('<stream> --', any);\ncolon('(s', immediate);\ncompile(x_lit, 41, x_parse, x_mintrailing, x_storestackeffect);\nsemicolon();\ndescribe('<stream> --', any);\nvar x_hash = colon('#');\ncompile(x_base, x_fetch, x_udslashmod, x_rot, x_lit, 9, x_over, x_less);\nIF();\ncompile(x_lit, 39, x_plus);\nTHEN();\ncompile(x_lit, 48, x_plus, x_hold);\nsemicolon();\ndescribe('d1 -- d2', any);\nvar x_hashs = colon('#s');\nBEGIN();\ncompile(x_hash, x_2dup, x_or, x_0equ);\nUNTIL();\nsemicolon();\ndescribe('d1 -- d2', any);\nvar x_parenddot = colon('(d.)');\ncompile(x_dup, x_tor, x_dabs, x_lesshash, x_hashs, x_rfrom, x_sign, x_hashmore, x_type);\nsemicolon();\ndescribe('d --', any);\nvar x_ddot = colon('d.'); // d.\n\ncompile(x_parenddot, x_space);\nsemicolon();\ndescribe('d --', any);\nvar x_ddotr = colon('d.r'); // d.r\n\ncompile(x_tor);\ncompile(x_dup, x_tor, x_dabs, x_lesshash, x_hashs, x_rfrom, x_sign, x_hashmore);\ncompile(x_rfrom, x_2dup, x_more);\nIF();\nBEGIN();\ncompile(x_qdup);\nWHILE();\ncompile(x_1minus, x_lit, 42, x_emit);\nREPEAT();\ncompile(x_2drop);\nELSE();\ncompile(x_over, x_minus, x_spaces, x_type);\nTHEN();\nsemicolon();\ndescribe('d --', any);\nvar x_udot = colon('u.'); // u.\n\ncompile(x_0, x_ddot);\nsemicolon();\ndescribe('u --', any);\nvar x_dot = colon('.'); // .\n\ncompile(x_stod, x_ddot);\nsemicolon();\ndescribe('n --', any);\ncolon('(.)');\ncompile(x_stod, x_parenddot);\nsemicolon();\ndescribe('n --', foerthchen);\ncolon('u.r'); // u.r  ( u1 u2 -- )\n\ncompile(x_0, x_swap, x_ddotr);\nsemicolon();\ndescribe('u1 u2 --', any);\nvar x_dotr = colon('.r'); // .r  ( n u -- )\n\ncompile(x_tor, x_stod, x_rfrom, x_ddotr);\nsemicolon();\ndescribe('n u --', any); // =================================================================================================\n//                                        flow control\n// =================================================================================================\n\ndefinitions(hidden);\nvar x_structured = colon('structured');\ncompile(x_2dup, x_nequ);\nIF();\ncompile(x_unstructured);\nTHEN();\ncompile(x_2drop);\nsemicolon();\nvar x_resolve = colon('resolve');\ncompile(x_here, x_minus, x_comma);\nsemicolon();\nvar x_resolveback = colon('<resolve');\ncompile(x_here, x_over, x_minus, x_swap, x_store);\nsemicolon();\nvar x_qclause = colon('?clause');\ncompile(x_lit, x_0branch, x_comma);\nsemicolon();\nvar x_clause = colon('clause');\ncompile(x_lit, x_branch, x_comma);\nsemicolon();\nvar x_mark = colon('mark');\ncompile(x_here, x_0, x_comma);\nsemicolon();\ndefinitions(forth);\nvar x_for = colon('for', immediate);\ncompile(x_qcomp, x_lit, x_brfor, x_comma);\ncompile(x_here, x_innerloop, x_exchange);\ncompile(x_here, x_0, x_comma);\ncompile(x_lit, 6);\nsemicolon();\ndescribe('n --', jsf);\nvar x_next = colon('next', immediate);\ncompile(x_qcomp, x_lit, 6, x_structured);\ncompile(x_lit, x_brnext, x_comma);\ncompile(x_dup, x_1plus, x_resolve);\ncompile(x_resolveback, x_innerloop, x_store);\nsemicolon();\ndescribe('--', jsf);\nvar x_if = colon('if', immediate);\ncompile(x_qcomp, x_qclause, x_mark, x_1);\nsemicolon();\ndescribe('f --', any);\nvar x_else = colon('else', immediate);\ncompile(x_qcomp, x_1, x_structured, x_clause, x_mark);\ncompile(x_swap, x_resolveback, x_2);\nsemicolon();\ndescribe('--', any);\nvar x_then = colon('then', immediate);\ncompile(x_qcomp, x_dup, x_2, x_equ, x_plus);\ncompile(x_1, x_structured, x_resolveback);\nsemicolon();\ndescribe('--', any);\nalias('endif', immediate);\ndescribe('-- ) ( --', jsf);\nvar x_begin = colon('begin', immediate);\ncompile(x_qcomp, x_here, x_lit, 3);\nsemicolon();\ndescribe('--', any);\nvar x_while = colon('while', immediate);\ncompile(x_qcomp, x_lit, 3, x_structured);\ncompile(x_qclause, x_mark, x_lit, 4);\nsemicolon();\ndescribe('f --', any);\nvar x_repeat = colon('repeat', immediate);\ncompile(x_qcomp, x_lit, 4, x_structured);\ncompile(x_swap, x_clause, x_resolve);\ncompile(x_resolveback);\nsemicolon();\ndescribe('--', any);\nvar x_again = colon('again', immediate);\ncompile(x_qcomp, x_lit, 3, x_structured, x_clause, x_resolve);\nsemicolon();\ndescribe('--', any);\nvar x_until = colon('until', immediate);\ncompile(x_qcomp, x_lit, 3, x_structured, x_qclause, x_resolve);\nsemicolon();\ndescribe('f --', any);\nvar x_do = colon('do', immediate);\ncompile(x_qcomp, x_lit, x_brdo, x_comma);\ncompile(x_here, x_innerloop, x_exchange);\ncompile(x_here, x_0, x_comma);\ncompile(x_lit, 5);\nsemicolon();\ndescribe('x1 x2 --', any);\nvar x_qdo = colon('?do', immediate);\ncompile(x_qcomp, x_lit, x_brqdo, x_comma);\ncompile(x_here, x_innerloop, x_exchange);\ncompile(x_here, x_0, x_comma);\ncompile(x_lit, 5);\nsemicolon();\ndescribe('x1 x2 --', any);\nvar x_loop = colon('loop', immediate);\ncompile(x_qcomp, x_lit, 5, x_structured);\ncompile(x_lit, x_brloop, x_comma);\ncompile(x_dup, x_1plus, x_resolve);\ncompile(x_resolveback);\ncompile(x_innerloop, x_store);\nsemicolon();\ndescribe('--', any);\nvar x_plusloop = colon('+loop', immediate);\ncompile(x_qcomp, x_lit, 5, x_structured);\ncompile(x_lit, x_brplusloop, x_comma);\ncompile(x_dup, x_1plus, x_resolve);\ncompile(x_resolveback);\ncompile(x_innerloop, x_store);\nsemicolon();\ndescribe('n --', any);\ndefinitions(hidden);\nvar x_leavecomma = colon('leave,');\ncompile(x_qcomp, x_innerloop, x_fetch, x_qdup, x_0equ);\nIF();\ncompile(x_lit, -26, x_throw);\nTHEN();\ncompile(x_swap, x_comma, x_comma);\nsemicolon();\ndescribe('xt --', any);\ndefinitions(forth); // fig/f79 leave is different from later leave:\n// leaving loop was only done when loop was reached,\n// statements between leave and loop were still executed.\n\ncolon('leave', immediate);\ncompile(x_lit, x_brleave79, x_comma);\nsemicolon();\ndescribe('--', f79 | fig);\nvar x_leave = colon('leave', immediate);\ncompile(x_lit, x_brleave, x_leavecomma);\nsemicolon();\ndescribe('--', ans | f83 | jsf);\nvar x_qleave = colon('?leave', immediate);\ncompile(x_lit, x_brqleave, x_leavecomma);\nsemicolon();\ndescribe('f --', jsf);\ncolon('unloop', immediate);\ncompile(x_qcomp, x_innerloop, x_fetch, x_0equ);\nIF();\ncompile(x_lit, -26, x_throw);\nTHEN();\ncompile(x_lit, x_brunloop, x_comma, x_unnest);\nsemicolon();\ndescribe('--', ans | f83 | jsf); // structure check is still limited.\n// doesn't complain when of .. endof is used outside of case .. endcase\n\ncolon('case', immediate);\ncompile(x_qcomp);\ncompile(x_0, x_innercase, x_exchange);\ncompile(x_lit, 7);\nsemicolon();\ndescribe('--', ans | f83 | jsf);\ncolon('of', immediate);\ncompile(x_qcomp);\ncompile(x_lit, x_brof, x_comma, x_mark);\ncompile(x_1, x_innercase, x_plusstore);\ncompile(x_lit, 8);\nsemicolon();\ndescribe('--', ans | f83 | jsf);\ncolon('endof', immediate);\ncompile(x_qcomp, x_lit, 8, x_structured);\ncompile(x_clause, x_mark);\ncompile(x_swap, x_resolveback);\nsemicolon();\ndescribe('--', ans | f83 | jsf);\ncolon('endcase', immediate);\ncompile(x_qcomp);\ncompile(x_lit, x_drop, x_comma);\ncompile(x_innercase, x_fetch);\nBEGIN();\ncompile(x_qdup);\nWHILE();\ncompile(x_1minus, x_swap, x_resolveback);\nREPEAT();\ncompile(x_lit, 7, x_structured);\ncompile(x_innercase, x_store);\nsemicolon();\ndescribe('--', ans | f83 | jsf); // =================================================================================================\n//                                   dictionary + compiling\n// =================================================================================================\n\ndefinitions(forth);\nvar x_tick = colon(\"'\");\ncompile(x_bl, x_parse, x_search, x_qdup, x_0equ);\nIF();\ncompile(x_notfound);\nTHEN();\nsemicolon();\ndescribe('<stream> -- xt', ans | f83 | jsf);\ncolon(\"'\");\ncompile(x_tick, x_tobody);\nsemicolon();\ndescribe('<stream> -- a', fig | f79);\nvar x_brtick = colon(\"[']\", immediate);\ncompile(x_tick, x_literal);\nsemicolon();\ndescribe('-- a', any);\ncolon('[compile]', immediate);\ncompile(x_tick, x_comma);\nsemicolon();\ndescribe('--', any);\ncolon('recurse', immediate);\ncompile(x_lastxt, x_fetch, x_comma);\nsemicolon();\ndescribe('--', ans | f83 | jsf);\ncolon('to', immediate);\ncompile(x_tick, x_tobody, x_dup, x_1minus, x_fetch, x_lit, x_dovalue, x_nequ, x_lit, -67, x_and, x_throw);\ncompile(x_compiling);\nIF();\ncompile(x_lit, x_brto, x_comma, x_comma);\nELSE();\ncompile(x_store);\nTHEN();\nsemicolon();\ndescribe('<stream> x --', ans | jsf); // =================================================================================================\n//                                          interpreter\n// =================================================================================================\n\ndefinitions(hidden);\nvar x_interpret = colon('interpret'); // ( -- )\n\nBEGIN();\ncompile(x_bl, x_parse, x_dup);\nWHILE();\ncompile(x_2dup, x_search, x_qdup);\nIF();\ncompile(x_nip, x_nip, x_dup, x_qimm);\nIF();\ncompile(x_execute);\nELSE();\ncompile(x_compiling);\nIF();\ncompile(x_comma);\nELSE();\ncompile(x_execute);\nTHEN();\nTHEN();\ncompile(x_depth, x_0less);\nIF();\ncompile(x_stackunderflow);\nTHEN();\nELSE();\ncompile(x_interpretnumber, x_0equ);\nIF();\ncompile(x_notfound);\nTHEN();\nTHEN();\nREPEAT();\ncompile(x_2drop);\nsemicolon();\ndescribe('--', jsf);\ndefinitions(forth);\nvar x_evaluate = colon('evaluate'); // ( a n -- )\n\ncompile(x_pushsource);\ncompile(x_in, x_off);\ncompile(x_storesource);\ncompile(x_interpret);\ncompile(x_popsource);\nsemicolon();\ndescribe('a n --', ans | jsf);\nvar x_load = colon('load');\ncompile(x_dup, x_blk, x_exchange, x_tor);\ncompile(x_block, x_lit, 1024, x_evaluate);\ncompile(x_rfrom, x_dup, x_blk, x_store);\ncompile(x_dup, x_0less, x_0equ);\nIF();\ncompile(x_dup, x_block, x_lit, 1024, x_storesource);\nTHEN();\ncompile(x_drop);\nsemicolon();\ndescribe('u --', any);\nvar x_screen = colon('screen');\ncompile(x_scr, x_fetch, x_block);\nsemicolon();\ndescribe('-- a', jsf);\nvar x_dotline = colon('.line');\ncompile(x_lit, 64, x_mul, x_screen, x_plus, x_lit, 64, x_mintrailing, x_type);\nsemicolon();\ndescribe('u --', jsf);\nvar x_plusload = colon('+load');\ncompile(x_blk, x_fetch, x_plus, x_load);\nsemicolon();\ndescribe('u --', any);\ncolon('thru');\ncompile(x_1plus, x_swap);\nQDO();\ncompile(x_i, x_load);\nLOOP();\nsemicolon();\ndescribe('u1 u2 --', any);\ncolon('+thru');\ncompile(x_1plus, x_swap);\nQDO();\ncompile(x_i, x_plusload);\nLOOP();\nsemicolon();\ndescribe('u1 u2 --', any);\nvar x_l = colon('l');\ncompile(x_lit, 16, x_0);\nDO();\ncompile(x_cr, x_i, x_2, x_dotr, x_lit, 124, x_emit, x_i, x_dotline);\nLOOP();\nsemicolon();\ndescribe('--', jsf);\ncolon('list');\ncompile(x_scr, x_store, x_l);\nsemicolon();\ndescribe('u --', any);\ncolon('blank');\ncompile(x_bl, x_fill);\nsemicolon();\ndescribe('a u --', any); // =================================================================================================\n//                                              utility\n// =================================================================================================\n\ncolon('help');\ncompile(x_bl, x_parse, x_loadhelp);\nsemicolon();\ndefinitions(teststuff);\nvar x_x = colon('x'); // execute rest of line as javscript\n\ncompile(x_0, x_parse, x_eval);\nsemicolon();\ndescribe('<stream> --', jsf);\nvar x_jsconsole = colon('');\nBEGIN();\ncompile(x_cr, x_lit, 62, x_emit, x_query, x_x);\nAGAIN();\nsemicolon();\ncolon('js'); // javascript console\n\nBEGIN();\ncompile(x_lit, x_jsconsole, x_catch, x_drop);\nAGAIN();\nsemicolon();\ndescribe('--', jsf); // =================================================================================================\n//                                     interpreter entry points\n// =================================================================================================\n\ndefinitions(forth);\nvar x_quit = colon('quit');\nBEGIN();\ncompile(x_query, x_source, x_qdup);\nIF();\ncompile(x_evaluate);\ncompile(x_0);\nTHEN();\ncompile(x_drop, x_prompt);\nAGAIN();\ndescribe('??? --', any);\nsemicolon();\nvar x_warm = colon('warm');\ncompile(x_warminit, x_quit);\ndescribe('??? --', jsf);\ndefinitions(hidden);\nvar x_error = colon('error');\ncompile(x_throw);\ndescribe('??? n --', jsf);\ndefinitions(forth);\nvar warm = dp;\ncomma(x_warm); // called with  virtualmachine(warm)\n\nvar error = dp;\ncomma(x_error); // called from  javascript onError\n\nfunction virtualmachine(entrypoint) {\n  suspended = 0;\n  ip = entrypoint;\n\n  do {\n    w = m[ip++]; // read next xt from address list\n\n    t[w](); // execute\n  } while (!suspended);\n} // =================================================================================================\n//                                        jsrepl helpers\n// =================================================================================================\n\n\nfunction _init() {\n  virtualmachine(warm);\n}\n\nfunction _run(str) {\n  for (var _i23 = 0; _i23 < str.length; _i23++) {\n    var chr = str.charCodeAt(_i23);\n    inbuf.push(chr === 10 ? 13 : chr);\n  }\n\n  inbuf.push(carriagereturn);\n  virtualmachine(ip);\n}\n\nfunction _stacktop(elementCount) {\n  // Must be called during execution.\n  var buffer = [];\n  s[++sp] = tos;\n\n  for (var _i24 = 1; _i24 < sp && _i24 <= elementCount; _i24++) {\n    buffer.push(s[sp - _i24 + 1].toString(m[base]));\n  }\n\n  sp--;\n  return buffer.reverse();\n}\n\nfunction _input(callback) {// Nothing.\n}\n\ndefinitions(forth);\n\nfunction _finish() {\n  console.log('finished.');\n}\n\nprimitive('_finish', function () {\n  _finish();\n});\ndescribe('--', jsf);"),o.REPLEngine=e})();