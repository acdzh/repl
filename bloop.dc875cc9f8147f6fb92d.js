(()=>{"use strict";function n(n,e){for(var o=0;o<e.length;o++){var r=e[o];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}var e=function(){function e(n,o,r,a,s,i){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.input=n,this.output=o,this.result=r,this.error=a,this.sandbox=s,this.ready=i,this.sandbox.BFloop.init(this.output),this.ready()}var o,r;return o=e,(r=[{key:"Eval",value:function(n){try{var e=this.sandbox.BFloop.compile(n);this.result(this.sandbox.eval(e))}catch(n){this.error(n)}}},{key:"EvalSync",value:function(n){var e=this.sandbox.BFloop.compile(n);return this.sandbox.eval(e)}},{key:"GetNextLineIndent",value:function(n){var e=/BLOCK\s+(\d+)\s*:\s*BEGIN/gi,o=/BLOCK\s+(\d+)\s*:\s*END/gi,r=function(n){var r=n.match(e)||[],a=n.match(o)||[];return r.length-a.length};return!(r(n)<=0)&&r(n.split("\n").slice(-1)[0])>0}}])&&n(o.prototype,r),e}(),o="undefined"!=typeof window&&null!==window?window:self;o.eval.call(o,'/**\n * @preserve\n * BlooPJS\n * Copyright (c) 2011 Tim Ryan\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n/* spiffy links */\n// http://www.amazon.com/gp/product/offer-listing/0394756827/ref=dp_pb_a//102-3710615-5652939?condition=all\n// http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl?_key=FLooP\n// http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl?_key=BLooP\n// http://www.pdc.kth.se/~jas/retro/retromuseum.html\n// http://c2.com/cgi/wiki?BloopFloopAndGloop\n\n/* parsing variables */\nBFloop = function () {\n  var BlooP = "BlooP";\n  var parseCode = null;\n  var codeLines = null;\n  var ns = null;\n  var val = null;\n  var code = "";\n  var computedCode = "";\n  var formals = [];\n  var blocks = [];\n  var LOOP_UNUSED = null;\n  var LOOP_USED = 1;\n  var LOOP_NEW_ABORTABLE = 2;\n  var LOOP_ABORTABLE = 3;\n  var LOOP_ABORTED = 4;\n  /* handlers */\n\n  var noop = function noop() {};\n\n  var outputFunc, warningFunc, noticeFunc;\n  outputFunc = errorFunc = warningFunc = noticeFunc = noop;\n\n  function init(outputHandler, warningHandler, noticeHandler) {\n    outputFunc = outputHandler || noop;\n    warningFunc = warningHandler || noop;\n    noticeFunc = noticeHandler || noop;\n  }\n\n  function compile(codeInput) {\n    // clear existing variables\n    parseCode = codeLines = computedCode = code = "";\n    parseCode = codeInput;\n    if (!parseCode) return false;\n    parseCode = parseCode.toUpperCase();\n    parseCode = parseCode.replace(/\\?/g, "q");\n    parseCode = parseCode.replace(/-/g, "_"); // For examples from the book and the web to be copy pasted easily\n    // we allow unicode x (multiplaction) and unicode arrow (assignment)\n\n    parseCode = parseCode.replace(new RegExp(String.fromCharCode(8656), \'g\'), \'<=\');\n    parseCode = parseCode.replace(new RegExp(String.fromCharCode(215), \'g\'), \'*\'); // get number of lines in code\n\n    codeLines = parseCode.split("\\n").length + 1; // parse all functions\n\n    while (!parseCode.match(/^$/)) {\n      parse();\n      computedCode += code;\n    }\n\n    return computedCode;\n  }\n  /* compiler output functions */\n\n\n  function error(warning) {\n    throw new Error("Error: Line " + (codeLines - parseCode.split("\\n").length) + ":\\n" + warning);\n  }\n\n  function warn(warning) {\n    warningFunc("Warning: Line " + (codeLines - parseCode.split("\\n").length) + ":\\n" + warning);\n  }\n\n  function notice(warning) {\n    noticeFunc("Notice: Line " + (codeLines - parseCode.split("\\n").length) + ":\\n" + warning);\n  }\n  /*********************/\n\n  /* Parsing Functions */\n\n  /*********************/\n\n\n  function scan() {\n    val = null;\n\n    MATCH: while (true) {\n      var breakS = [/^\'\'/, /^<=/, /^[+*!=<>(){}":;,.-]/, /^\\[/, /^\\]/, /^DEFINE\\b/, /^PROCEDURE\\b/, /^BLOCK\\b/, /^LOOP\\b/, /^AT\\b/, /^MOST\\b/, /^TIMES\\b/, /^MU_LOOP\\b/, /^CELL\\b/, /^OUTPUT\\b/, /^YES\\b/, /^NO\\b/, /^QUIT\\b/, /^ABORT\\b/, /^IF\\b/, /^THEN\\b/, /^AND\\b/, /^OR\\b/, /^PRINT\\b/];\n      if (parseCode.match(/^$/)) return false;\n\n      if (parseCode.match(/^\\/\\*.*?\\*\\//)) {\n        parseCode = parseCode.replace(/^\\/\\*.*\\*\\//, "");\n        continue MATCH;\n      }\n\n      if (parseCode.match(/^BLOCK\\s+(\\d+)\\s*:\\s*BEGIN/)) {\n        ns = "BEGIN";\n        val = parseCode.match(/^BLOCK\\s+(\\d+)\\s*:\\s*BEGIN/)[1];\n        parseCode = parseCode.replace(/^BLOCK\\s+(\\d+)\\s*:\\s*BEGIN/, "");\n        break MATCH;\n      }\n\n      if (parseCode.match(/^BLOCK\\s+(\\d+)\\s*:\\s*END/)) {\n        ns = "END";\n        val = parseCode.match(/^BLOCK\\s+(\\d+)\\s*:\\s*END/)[1];\n        parseCode = parseCode.replace(/^BLOCK\\s+(\\d+)\\s*:\\s*END/, "");\n        break MATCH;\n      }\n\n      for (var i = 0, max = breakS.length; i < max; i++) {\n        if (parseCode.match(breakS[i])) {\n          ns = parseCode.match(breakS[i])[0];\n          parseCode = parseCode.replace(breakS[i], "");\n          break MATCH;\n        }\n      }\n\n      if (parseCode.match(/^\\s+/)) {\n        parseCode = parseCode.replace(/^\\s+/, "");\n        continue MATCH;\n      }\n\n      if (parseCode.match(/^[A-Z]\\w*/)) {\n        ns = "ID";\n        val = parseCode.match(/^[A-Z]\\w*/)[0];\n        parseCode = parseCode.replace(/^[A-Z]\\w*/, "");\n        break MATCH;\n      }\n\n      if (parseCode.match(/^\\d+/)) {\n        ns = "NUMBER";\n        val = parseCode.match(/^\\d+/)[0];\n        parseCode = parseCode.replace(/^\\d+/, "");\n        break MATCH;\n      }\n\n      if (parseCode.match(/^\'/)) {\n        string();\n        break MATCH;\n      }\n\n      invChar = parseCode.match(/^./);\n      invChar = invChar[0];\n      invChar = invChar.replace(/_/g, "-");\n      invChar = invChar.replace(/q/g, "?");\n      error("BlooP: invalid character " + invChar);\n      parseCode = parseCode.replace(/^./, "");\n      break MATCH;\n    }\n  }\n\n  function string() {\n    var result = "";\n\n    while (true) {\n      if (parseCode.search(/^\'[^\']*\'/) == -1) break;\n      result += parseCode.match(/^\'[^\']*\'/)[0];\n      parseCode = parseCode.replace(/^\'[^\']*\'/, "");\n    }\n\n    ns = "STRING";\n    val = result.substring(1, result.length - 1);\n  }\n\n  function parse() {\n    code = "";\n    formals = blocks = [];\n    scan();\n\n    if (ns == "DEFINE") {\n      definition();\n    } else {\n      expression();\n      if (code.match(/q/)) code += " ? \\"YES\\" : \\"NO\\"";\n      code += ";\\n";\n    }\n\n    if (ns != ".") warn("excess junk at end of function");\n  }\n\n  function descan(locNs, locVal) {\n    if (locNs == "BEGIN" || locNs == "END") return "BLOCK " + locVal + ": " + locNs;\n    if (locVal == "") return locNs;\n    return locNs + " " + locVal;\n  }\n\n  function need(needVar) {\n    var oldval = val;\n\n    if (needVar != ns) {\n      warn("expected " + descan(needVar, val) + ", got " + descan(ns, ""));\n    }\n\n    scan();\n    return oldval;\n  }\n\n  function definition() {\n    var name = "";\n    scan();\n    need("PROCEDURE");\n    need("\'\'");\n    name = need("ID");\n    code += "function " + name;\n    name = name.replace(/q/, "?");\n    name = name.replace(/_/g, "-");\n    need("\'\'");\n    need("[");\n    getformals();\n    need("]");\n    need(":");\n    code += " {\\n";\n    code += "var cell = new Array();\\n";\n    code += "var output = 0;\\n";\n    statement();\n    code += "return output;\\n";\n    code += "}\\n\\n";\n  }\n\n  function getformals() {\n    formals = [];\n\n    while (true) {\n      formals.push(need("ID"));\n      if (ns != ",") break;\n      scan();\n    }\n\n    code += "(" + formals.join(", ") + ")";\n  }\n\n  function statement() {\n    if (ns == "BEGIN") {\n      block();\n      return;\n    }\n\n    if (ns == "LOOP") {\n      loop();\n      return;\n    }\n\n    if (ns == "MU_LOOP") {\n      mu_loop();\n      return;\n    }\n\n    if (ns == "QUIT") {\n      quit();\n      return;\n    }\n\n    if (ns == "ABORT") {\n      abort();\n      return;\n    }\n\n    if (ns == "IF") {\n      f_if();\n      return;\n    }\n\n    if (ns == "PRINT") {\n      print();\n      return;\n    }\n\n    assign();\n    return;\n  }\n\n  function block() {\n    var begin = val;\n    var end = "";\n\n    if (blocks[begin] == LOOP_UNUSED) {\n      blocks[begin] = LOOP_USED;\n      code += "BLOCK" + begin + ": {\\n";\n    } else if (blocks[begin] == LOOP_USED || blocks[begin] == LOOP_ABORTABLE) {\n      warn("BLOCK " + begin + " appears twice");\n    } else if (blocks[begin] == LOOP_NEW_ABORTABLE) {\n      blocks[begin] = LOOP_ABORTABLE;\n    }\n\n    scan();\n\n    while (ns != "END") {\n      statement();\n    }\n\n    end = val;\n    if (begin == end) notice("BLOCK " + begin + ": BEGIN matches with BLOCK " + end + ": END");\n    scan();\n    if (blocks[begin] != LOOP_ABORTABLE && blocks[begin] != LOOP_ABORTED) code += "}\\n";\n    if (ns == ";") scan();\n  }\n\n  function loop() {\n    var atmost = "";\n    scan();\n\n    if (ns == "AT") {\n      scan();\n      need("MOST");\n      atmost = 1;\n    }\n\n    if (atmost) code += "BLOCK#: ";\n    code += "for (var counter = 0, ";\n    code += "limit = ";\n    expression();\n    code += "; counter < limit; counter++) {\\n";\n    need("TIMES");\n    need(":");\n\n    if (atmost) {\n      if (ns != "BEGIN") warn("LOOP AT MOST requires following BLOCK");\n      code = code.replace(/#/, val);\n      blocks[val] = LOOP_NEW_ABORTABLE;\n    }\n\n    statement();\n    code += "}\\n";\n  }\n\n  function mu_loop() {\n    if (BlooP == "BlooP") error("MU-LOOP not supported -- use FlooP");\n    var loopnum = 0;\n    scan();\n    need(":");\n    if (ns != "BEGIN") warn("LOOP requires following BLOCK");\n    loopnum = val;\n    code += "BLOCK" + loopnum + ": while (true) {\\n";\n    blocks[loopnum] = LOOP_NEW_ABORTABLE;\n    statement();\n    code += "}\\n";\n    if (blocks[loopnum] != LOOP_ABORTED) warn("FlooP: MU-LOOP without ABORT LOOP may run forever");\n  }\n\n  function quit() {\n    var blocknum = "";\n    scan();\n    need("BLOCK");\n    blocknum = need("NUMBER");\n    if (blocks[blocknum] == LOOP_UNUSED) error("QUIT BLOCK refers to non-existent BLOCK");\n    code += "break BLOCK" + blocknum + ";\\n";\n    need(";");\n  }\n\n  function abort() {\n    var loopnum = "";\n    scan();\n    need("LOOP");\n    loopnum = need("NUMBER");\n    if (blocks[loopnum] != LOOP_ABORTABLE && blocks[loopnum] != LOOP_ABORTED) error("ABORT LOOP on non-abortable loop or non-loop");\n    code += "break BLOCK" + loopnum + ";\\n";\n    need(";");\n    blocks[loopnum] = LOOP_ABORTED;\n  }\n\n  function f_if() {\n    code += "if (";\n    scan();\n\n    if (ns == "{") {\n      scan();\n\n      while (true) {\n        expression();\n\n        if (ns == "AND") {\n          code += " && ";\n          scan();\n        } else if (ns == "OR") {\n          code += " || ";\n          scan();\n        } else {\n          break;\n        }\n      }\n\n      need("}");\n    } else {\n      expression();\n    }\n\n    code += ") {\\n";\n    need(",");\n    need("THEN");\n    need(":");\n    statement();\n    code += "}\\n";\n  }\n\n  function print() {\n    scan();\n    need("[");\n    code += "BFloop.printstring(";\n\n    while (true) {\n      expression();\n      if (ns != ",") break;\n      scan();\n      code += ", ";\n    }\n\n    need("]");\n    code += ");\\n";\n    if (ns == ";") scan();\n  }\n\n  function assign() {\n    if (ns == "OUTPUT") {\n      code += "output";\n      scan();\n    } else if (ns == "CELL") {\n      cell();\n    } else {\n      error("invalid syntax");\n\n      while (ns != ";") {\n        scan();\n      }\n\n      scan();\n      return;\n    }\n\n    need("<=");\n    code += " = ";\n    expression();\n    code += ";\\n";\n    if (ns == ";") scan();\n  }\n\n  function expression() {\n    if (ns == "STRING") {\n      val = val.replace("\\\\", "\\\\\\\\");\n      val = val.replace("\'", "\\\\\'");\n      code += "\'" + val + "\'";\n      scan();\n    } else if (ns == "YES") {\n      code += "1";\n      scan();\n    } else if (ns == "NO") {\n      code += "0";\n      scan();\n    } else {\n      while (true) {\n        term();\n\n        if (ns == "=") {\n          code += " == ";\n        } else if (ns == "<") {\n          code += " < ";\n        } else if (ns == ">") {\n          code += " > ";\n        } else {\n          break;\n        }\n\n        scan();\n      }\n    }\n  }\n\n  function term() {\n    while (true) {\n      factor();\n      if (ns != "+") break;\n      scan();\n      code += " + ";\n    }\n  }\n\n  function factor() {\n    while (true) {\n      primary();\n      if (ns != "*") break;\n      scan();\n      code += " * ";\n    }\n  }\n\n  function primary() {\n    if (ns == "CELL") {\n      cell();\n    } else if (ns == "OUTPUT") {\n      code += "output";\n      scan();\n    } else if (ns == "ID") {\n      var id = val;\n      scan();\n\n      if (ns == "[") {\n        scan();\n        code += id + "(";\n\n        while (true) {\n          expression();\n          if (ns != ",") break;\n          scan();\n          code += ", ";\n        }\n\n        need("]");\n        code += ")";\n        return;\n      }\n\n      for (var i = 0, max = formals.length; i < max; i++) {\n        if (formals[i] == id) break;\n\n        if (i == max - 1) {\n          id = id.replace(/q/, "?");\n          id = id.replace(/_/, "-");\n          warn("unknown variable " + id);\n        }\n      }\n\n      code += id;\n    } else if (ns == "NUMBER") {\n      code += val;\n      scan();\n    } else {\n      warn("unexpected " + descan(ns, val) + " found");\n      scan();\n    }\n  }\n\n  function cell() {\n    scan();\n    need("(");\n    code += "cell[" + need("NUMBER") + "]";\n    need(")");\n  }\n  /*********************/\n\n  /* Program Functions */\n\n  /*********************/\n\n\n  function printstring() {\n    var output = " > ";\n\n    for (var i = 0; i < arguments.length; i++) {\n      output += arguments[i];\n    }\n\n    outputFunc(output + "\\n");\n  }\n\n  return {\n    init: init,\n    compile: compile,\n    printstring: printstring\n  };\n}();'),o.REPLEngine=e})();